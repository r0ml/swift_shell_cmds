
// Generated by Robert M. Lefkowitz <r0ml@liberally.net> in 2024 using ChatGPT
// from a file containing the following notice:

/*
 * SPDX-License-Identifier: BSD-3-Clause
 *
 * Copyright (c) 1994
 *  The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Jan-Simon Pendry.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

import CMigration

let magic = "%"

func ISMAGICNO(_ p: String ) -> Bool {
  return p.count > 1 && p.hasPrefix(magic) && p.dropFirst().first!.isNumber
}

struct CommandOptions {
  var debug = false
  var magic : Character = "%"
  var nargs = -1
  var cmd : String = ""
  var arg_max : Int = 0
  var shell : String = ""
  var name : String = ""

  var args : ArraySlice<String> = []
}

@main final class apply : ShellCommand {
  var opts = CommandOptions()

  func parseOptions() throws(CmdErr) -> CommandOptions {
    let go = BSDGetopt("a:d0123456789")
    while let (k, v) = try go.getopt() {
      switch k {
        case "a":
          guard v.count == 1 else {
            throw CmdErr(1, "illegal magic character specification")
          }
          if let x = v.first { opts.magic = x }
        case "d":
          opts.debug = true
        case "0", "1", "2", "3", "4", "5", "6", "7", "8", "9":
          guard opts.nargs == -1 else {
            throw CmdErr(1, "only one -# argument may be specified")
          }
          opts.nargs = Int(String(k))!
        default:
          throw CmdErr(1)
      }
    }

    opts.args = ArraySlice(go.remaining)

    guard opts.args.count >= 2 else {
      throw CmdErr(1)
    }
    
    let p = opts.args.first ?? ""

    // Get the largest %digits number
    let mm = p.matches(of: /%([1-9])/)
    let n = mm.reduce(0, { max($0, Int($1.output.1)!)})

    let tmpShell = getenv("SHELL")
    opts.shell = tmpShell ?? Darwin._PATH_BSHELL
    let slashp = opts.shell.lastIndex(of: "/")
    opts.name = slashp != nil ? String(opts.shell[opts.shell.index(after: slashp!)...]) : opts.shell

    opts.cmd = opts.args.first!
    
    if n == 0 {
      // If nargs not set, default to a single argument.
      if opts.nargs == -1 {
        opts.nargs = 1
      }
      for i in 1...opts.nargs {
        let buf = " \(opts.magic)\(i)"
        opts.cmd.append(buf)
      }

      // If nargs is set to the special value 0, eat a single argument for each command execution.
      if opts.nargs == 0 {
        opts.nargs = 1
      }
    } else {
      opts.nargs = n
    }
    opts.args.removeFirst()
    opts.arg_max = Darwin.sysconf(Darwin._SC_ARG_MAX)
    return opts
  }

  func runCommand(_ opts : CommandOptions) async throws(CmdErr) {
    var cmdbuf = ""
    var rval = 0
    var arg = opts.args

    while true {
      guard arg.count >= opts.nargs else { break }
      let pkt = Array(arg.prefix(opts.nargs))
      arg.removeFirst(opts.nargs)

      cmdbuf = "exec "
      var cmdx = Substring(opts.cmd)

      while !cmdx.isEmpty {
        if let j = cmdx.firstMatch(of: /%([1-9])/) {
          cmdbuf.append(contentsOf: cmdx.prefix(upTo: j.range.lowerBound))
          cmdbuf.append(pkt[Int(j.output.1)!-1])
          cmdx = cmdx.suffix(from: j.range.upperBound)
        } else {
          cmdbuf.append(contentsOf: cmdx)
          cmdx.removeAll()
        }
      }

      if cmdbuf.count > opts.arg_max {
        throw CmdErr(1, "Argument list too long")
      }

      if opts.debug {
        print(cmdbuf)
      } else {
        if await 0 != execShell(String(cmdbuf), opts.shell, opts.name) {
          rval = 1
        }
      }
    }

    if arg.count != 0 {
      throw CmdErr(1, "expecting additional argument\(opts.nargs - arg.count != 1 ? "s" : "") after \"\(opts.args.last!)\"")
    }
    throw CmdErr(rval)

  }

  /// Execute a shell `command` using passed `shell` and `use_name`  arguments.
  func execShell(_ command: String, _ useShell: String, _ useName: String) async -> Int {
    do {
      let _ = try ProcessRunner.run(command: useShell, arguments: ["-c", command])
    } catch let e as Errno {
      return Int(e.rawValue)
    } catch(let e) {
      print(e)
      return -1
    }

    /*
    let task = Process()
    task.launchPath = useShell
    task.arguments = ["-c", command]
    task.launch()
    task.waitUntilExit()
    return Int(task.terminationStatus)
     */
    return 0
  }

  var usage : String = "usage: apply [-a magic] [-d] [-0123456789] command arguments ..."
}
