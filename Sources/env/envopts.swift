
// Generated by Robert M. Lefkowitz <r0ml@liberally.net> in 2024 using ChatGPT
// from a file containing the following notice:

/*
 * SPDX-License-Identifier: BSD-2-Clause-FreeBSD
 *
 * Copyright (c) 2005  - Garance Alistair Drosehn <gad@FreeBSD.org>.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *   1. Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *   2. Redistributions in binary form must reproduce the above copyright
 *      notice, this list of conditions and the following disclaimer in the
 *      documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * The views and conclusions contained in the software and documentation
 * are those of the authors and should not be interpreted as representing
 * official policies, either expressed or implied, of the FreeBSD Project.
 */

import CMigration
import Darwin

import stdio_h

extension Env {

  /*
   * The is*() routines take a parameter of 'Int', but expect values in the range
   * of unsigned char.  Define some wrappers which take a value of type 'Character',
   * whether signed or unsigned, and ensure the value ends up in the right range.
   */
  /*
   func isalnumch(_ anyChar: Character) -> Bool {
   return isalnum(UInt8(anyChar.asciiValue ?? 0))
   }

   func isalphach(_ anyChar: Character) -> Bool {
   return isalpha(UInt8(anyChar.asciiValue ?? 0))
   }

   func isspacech(_ anyChar: Character) -> Bool {
   return isspace(UInt8(anyChar.asciiValue ?? 0))
   }
   */

  /*
   * Routine to determine if a given fully-qualified filename is executable.
   * This is copied almost verbatim from FreeBSD's usr.bin/which/which.c.
   */
  func is_there(_ candidate: String) -> Bool {

    /* XXX work around access(2) false positives for superuser */
    if Darwin.access(candidate, X_OK) == 0,
       let fin = try? FileMetadata(for: FilePath(candidate), followSymlinks: true),
       fin.filetype == .regular,
        (Darwin.getuid() != 0 || fin.permissions.containsAny(of: [.ownerExecute, .groupExecute, .otherExecute])) {
         if env_verbosity > 1 {
        var se = FileDescriptor.standardError
        print("#env   matched:\t'\(candidate)'", to: &se)
      }
      return true
    }
    return false
  }

  /**
   * Routine to search through an alternate path-list, looking for a given
   * filename to execute.  If the file is found, replace the original
   * unqualified name with a fully-qualified path.  This allows `env' to
   * execute programs from a specific strict list of possible paths, without
   * changing the value of PATH seen by the program which will be executed.
   * E.G.:
   *  #!/usr/bin/env -S-P/usr/local/bin:/usr/bin perl
   * will execute /usr/local/bin/perl or /usr/bin/perl (whichever is found
   * first), no matter what the current value of PATH is, and without
   * changing the value of PATH that the script will see when it runs.
   *
   * This is similar to the print_matches() routine in usr.bin/which/which.c.
   */
  // FIXME: use searchPath from CMigration?
  func search_paths(_ path: String, _ argv: String) -> String {
    //    var candidate = [CChar](repeating: 0, count: Int(PATH_MAX))
    //    var d: String?
    let filename = argv
    var fqname: String?

    /* If the file has a `/' in it, then no search is done */
    if filename.contains("/") {
      return filename
    }

    if env_verbosity > 1 {
      stdio_h.fputs("#env Searching:\t'\(path)'\n", stdio_h.stderr)
      stdio_h.fputs("#env  for file:\t'\(filename)'\n", stdio_h.stderr)
    }

    fqname = nil
    for pathComponent in path.split(separator: ":") {
      var d = pathComponent
      if d.isEmpty {
        d = "."
      }
      let candidate = "\(d)/\(filename)"
      if is_there(candidate) {
        fqname = candidate
        break
      }
    }

    if fqname == nil {
      errno = Darwin.ENOENT
      err(127, filename)
    }
    return fqname!
  }

  /**
   * Routine to split a string into multiple parameters, while recognizing a
   * few special characters.  It recognizes both single and double-quoted
   * strings.  This processing is designed entirely for the benefit of the
   * parsing of "#!"-lines (aka "shebang" lines == the first line of an
   * executable script).  Different operating systems parse that line in very
   * different ways, and this split-on-spaces processing is meant to provide
   * ways to specify arbitrary arguments on that line, no matter how the OS
   * parses it.
   *
   * Within a single-quoted string, the two characters "\'" are treated as
   * a literal "'" character to add to the string, and "\\" are treated as
   * a literal "\" character to add.  Other than that, all characters are
   * copied until the processing gets to a terminating "'".
   *
   * Within a double-quoted string, many more "\"-style escape sequences
   * are recognized, mostly copied from what is recognized in the `printf'
   * command.  Some OS's will not allow a literal blank character to be
   * included in the one argument that they recognize on a shebang-line,
   * so a few additional escape-sequences are defined to provide ways to
   * specify blanks.
   *
   * Within a double-quoted string "\_" is turned into a literal blank.
   * (Inside of a single-quoted string, the two characters are just copied)
   * Outside of a quoted string, "\_" is treated as both a blank, and the
   * end of the current argument.  So with a shelbang-line of:
   *    #!/usr/bin/env -SA=avalue\_perl
   * the -S value would be broken up into arguments "A=avalue" and "perl".
   *
   * Returns the new "arguments" to be used instead of the original CommandLine arguments
   */
  func splitSpaces(_ strx: String) throws(CmdErr) -> [String] {
    var res: [String] = []
    var str = Substring(strx)

    // Ignore leading space on the string
    str = str.drop { $0.isWhitespace }

    if str.isEmpty {
      return []
    }

    var in_dq = false
    var in_sq = false
    var curarg = Substring("")

  outer:
    while !str.isEmpty {
      let char = str.removeFirst()
      var found_sep = false

      switch char {
        case "\"":
          if in_sq {
            curarg.append(char)
          } else if in_dq {
            in_dq = false
          } else {
            in_dq = true
          }
        case "$":
          if in_sq {
            curarg.append(char)
          } else {
            try curarg.append(contentsOf: expandVars(&str))
          }
        case "'":
          if in_dq {
            curarg.append(char)
          } else if in_sq {
            in_sq = false
          } else {
            in_sq = true
          }
        case "\\":
          if in_sq {
            if let c = str.first, c == "'" || c == "\\" {
              str.removeFirst()
              curarg.append(c)
            } else {
              curarg.append(char)
            }
          } else {
            let c = str.removeFirst()
            switch c {
              case "\"", "#", "$", "'", "\\":
                curarg.append(c)
              case "_":
                if in_dq {
                  curarg.append(" ")
                } else {
                  found_sep = true
                  str.removeFirst()
                }
              case "c":
                if in_dq {
                  throw CmdErr(1, "Sequence '\\c' is not allowed in quoted strings")
                }
                break
              case "f":
                curarg.append("\u{000C}")
              case "n":
                curarg.append("\n")
              case "r":
                curarg.append("\r")
              case "t":
                curarg.append("\t")
              case "v":
                curarg.append("\u{000B}")
              default:
                if c.isWhitespace {
                  curarg.append(c)
                } else {
                  throw CmdErr(1, "Invalid sequence '\\\(c)' in -S")
                }
            }
          }
        default:
          if (in_dq || in_sq) && !curarg.isEmpty {
            curarg.append(char)
          } else if char.isWhitespace {
            found_sep = true
          } else if curarg.isEmpty && char == "#" {
            break outer
          } else {
            curarg.append(char)
          }
      }
      if found_sep {
        res.append(String(curarg))
        found_sep = false
        curarg = ""
        str = str.drop { $0.isWhitespace }
      }
    }

    if !curarg.isEmpty {
      res.append(String(curarg))
    }
    
    if in_dq || in_sq {
      let bq_src = in_dq ? "\"" : "'"
      throw CmdErr(1, "No terminating quote for string: \(bq_src)\(curarg)")
    }

    if env_verbosity > 1 {
      print("#env  split -S:\t'\(str)'")
      if !res.isEmpty {
        print("#env      into:\t'\(res[0])'")
      }
      for nn in res.dropFirst() {
        print("#env          &\t'\(nn)'")
      }
    }

    return res
  }



  /**
   * Routine to split expand any environment variables referenced in the string
   * that -S is processing.  For now it only supports the form ${VARNAME}.  It
   * explicitly does not support $VARNAME, and obviously can not handle special
   * shell-variables such as $?, $*, $1, etc.  It is called with *src_p pointing
   * at the initial '$', and if successful it will update *src_p, *dest_p, and
   * possibly *thisarg_p in the calling routine.
   */
  func expandVars(_ srcP : inout Substring) throws(CmdErr) -> String {
    if srcP.first == "{" { // ASCII value for '{'
      var vname = Substring("")
      let vb = srcP.dropFirst()
      if let k = vb.first, k.isLetter || k == "_" {
        vname.append(k)
        var vbb = vb.dropFirst()
        while let kk = vbb.first, kk.isLetter || kk.isNumber || kk == "_"  {
          vbb = vbb.dropFirst()
          vname.append(kk)
        }
        if vbb.first == "}" {
          // Env var name replacement happens here
          srcP = vbb.dropFirst()
          if let vvalue = Environment[String(vname)] {
            if env_verbosity > 2 {
              var se = FileDescriptor.standardError
              print("#env expanding ${\(vname)} into '\(vvalue)'", to: &se)
            }

            return vvalue
          } else {
            if env_verbosity > 2 {
              var se = FileDescriptor.standardError
              // FIXME: original throws error by using null instead of empty string
              print("#env replacing ${\(vname)} with empty string", to: &se)
            }
            // The environment variable is not set
            return ""
          }
        }
      }
    }
    throw CmdErr(1, "Only ${VARNAME} expansion is supported, error at: \(srcP)")
  }

}
