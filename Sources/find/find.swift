
// Generated by Robert M. Lefkowitz <r0ml@liberally.net> in 2024 using ChatGPT
// from a file containing the following notice:

/*
 * SPDX-License-Identifier: BSD-3-Clause
 *
 * Copyright (c) 1991, 1993, 1994
 *  The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Cimarron D. Taylor of the University of California, Berkeley.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

import CMigration

import Darwin

indirect enum P_un {
  case g_data(_ a : Darwin.gid_t)
  case i_data(_ a : Darwin.ino_t)
  case m_data(_ a : Darwin.mode_t)
  case fl_flags(_ a : UInt32, _ b : UInt32)
  case l_data(_ a : Darwin.nlink_t)
  case d_data(Int16)
  case o_data(Darwin.off_t)
  case t_data(Darwin.timespec)
  case u_data(Darwin.uid_t)
  case mt_data(Int16)
  
  // need the indirect for this one.
  case p_data([PLAN], [PLAN])
  case ex_data(ex)
  
  case a_data(String, String)
  case c_data(String)
  case re_data(Darwin.regex_t)
}


// This can't be a struct because need to append to e_argv
// during execution of -exec
class ex {
  var e_argv : [String] = []  /* argv array */
  var e_orig : [String] = []   /* original strings */
  var e_argmax = Int(Darwin._POSIX_ARG_MAX)
//  var e_len : [Int] = []    /* allocated length */
//  var e_pbnum : Int32 = 0    /* base num. of args. used */
//  var e_pbnum : Int32 = 0    /* base num. of args. used */
//  var e_ppos : Int32 = 0   /* number of arguments used */
//  var e_pnummax : Int32 = 0    /* max. number of arguments */
//  var e_pbsize : Int32 = 0    /* base num. of bytes of args */
//  var e_psizemax : Int32 = 0  /* max num. of bytes of args */
//  var e_next : PLAN? = nil /* next F_EXECPLUS in tree */
}


/*struct fl {
  var f_flags : UInt
  var f_notflags : UInt
}*/

/* node definition */
struct PLAN {
  //  struct _plandata *next;    /* next node */
  var flags : Int32      /* private flags */
  var option : OPTION
  var p_un : P_un?
  
  // was `palloc`
  init(_ option: OPTION) {
    self.option = option
    self.flags = option.flags
  }

  func execute(_ b : FTSEntry) -> Bool {
    return option.execute?(self, b) ?? false
  }
  
  var name : String { option.name }
  
  /*
   
   var _storage : Any
   
   var g_data : gid_t { get { _storage as! gid_t} set { _storage = newValue as gid_t }}
   var i_data : ino_t { get { _storage as! ino_t} set { _storage = newValue as ino_t }}
   var m_data : mode_t { get { _storage as! mode_t} set { _storage = newValue as mode_t }}
   var fl_flags : fl { get { _storage as! fl} set { _storage = newValue as fl }}
   var nlink : nlink_t { get { _storage as! nlink_t} set { _storage = newValue as nlink_t } }
   var d_data : Int16 { get { _storage as! Int16 } set { _storage = newValue as Int16 } }
   var o_data : off_t { get { _storage as! off_t} set { _storage = newValue as off_t } }
   var t_data : timespec { get { _storage as! timespec} set { _storage = newValue as timespec } }
   var u_data : uid_t { get { _storage as! uid_t} set { _storage = newValue as uid_t } }
   var mt_data : Int16 { get { _storage as! Int16} set { _storage = newValue as Int16 } }
   
   //  var p_data : (PLAN, PLAN) = { get { _storage as! (PLAN,PLAN) } set { _storage = newValue as (PLAN, PLAN) } }
   
   var a_data : (String,String) { get { _storage as! (String, String) } set { _storage = newValue as (String, String) } }
   var c_data : String { get { _storage as! String} set { _storage = newValue as String } }
   var re_data : regex_t { get { _storage as! regex_t} set { _storage = newValue as regex_t } }
   
   */
  
}
  
  
/*
  union {
    gid_t _g_data;    /* gid */
    ino_t _i_data;    /* inode */
    mode_t _m_data;    /* mode mask */
    struct {
      u_long _f_flags;
      u_long _f_notflags;
    } fl;
    
    
    nlink_t _l_data;    /* link count */
    short _d_data;      /* level depth (-1 to N) */
    off_t _o_data;      /* file size */
    struct timespec _t_data;  /* time value */
    uid_t _u_data;      /* uid */
    short _mt_data;      /* mount flags */
    struct _plandata *_p_data[2];  /* PLAN trees */
    struct _ex {
      char **_e_argv;    /* argv array */
      char **_e_orig;    /* original strings */
      int *_e_len;    /* allocated length */
      int _e_pbnum;    /* base num. of args. used */
      int _e_ppos;    /* number of arguments used */
      int _e_pnummax;    /* max. number of arguments */
      int _e_psize;    /* number of bytes of args. */
      int _e_pbsize;    /* base num. of bytes of args */
      int _e_psizemax;  /* max num. of bytes of args */
      struct _plandata *_e_next;/* next F_EXECPLUS in tree */
    } ex;
    char *_a_data[2];    /* array of char pointers */
    char *_c_data;      /* char pointer */
    regex_t *_re_data;    /* regex */
  } p_un;
}
*/





  /*
   * find_compare --
   *  tell fts_open() how to order the traversal of the hierarchy.
   *  This variant gives lexicographical order, i.e., alphabetical
   *  order within each directory.
   */
  
  func find_compare(s1: FTSEntry, s2: FTSEntry) -> ComparisonResult {

    let ss1 = s1.name!
    let ss2 = s2.name!

    //  let ss1 = String(cString: s1?.pointee.fts_name)
    //  let ss2 = String(cString: s2?.pointee.fts_name)
    
    if ss1 > ss2 { return .orderedDescending }
    else if ss1 < ss2 { return .orderedAscending }
    else { return .orderedSame }
  }
  /*
   func find_compare(_ s1 : FTSENT, _ s2 : FTSENT) -> Int {
   var b = s1.fts_name
   var c = s2.fts_name
   let a = String(cString: &b).compare(String(cString: &c))
   }
   */
  
extension find {
  /*
   * find_formplan --
   *  process the command line and create a "plan" corresponding to the
   *  command arguments.
   */
  func find_formplan(_ argv : inout ArraySlice<String>) -> [PLAN] {
    var plan = ArraySlice<PLAN>()
    var new: PLAN
    
    while !argv.isEmpty {
      plan.append(find_create(&argv))
    }
    
    if (isoutput == 0) {
      var argv1: ArraySlice<String> = []
      if let p = optionsx["-print"] {
        new = p.create(p, &argv1)
        plan.append(new)
      }
    }
    
    var planx = paren_squish(plan)
    planx = not_squish(planx)
    planx = or_squish(planx)
    return planx
  }
  
  /* add_path - helper function used to build a list of paths that were
   * specified on the command line that we are allowed to search.
   */
  func add_path(array: [String]?, newPath: String?) -> [String] {
    var array = array ?? []
    if let newPath = newPath {
      array.append(newPath)
    }
    return array
  }
  
  /*
   * find_execute --
   *  take a search plan and an array of search paths and executes the plan
   *  over all FTSENT's returned for the given search paths.
   */
  func find_execute(plan: [PLAN], paths: [String]) -> Int32 {
    var e: Int
    var myPaths: [String] = []
    var nonSearchableDirFound : Int32 = 0
    var statInfo = Darwin.stat()
    
    myPaths = add_path(array: nil, newPath: nil)
    for path in paths {
      let stat_ret = stat(path, &statInfo)
      let stat_errno = errno
      if unix2003_compat && getuid() != 0 && stat_ret == 0 && ((statInfo.st_mode & S_IFMT) == S_IFDIR) {
        if access(path, X_OK) == 0 {
          myPaths = add_path(array: myPaths, newPath: path)
        } else {
          if stat_errno != ENAMETOOLONG {
            warnx("\(path): Permission denied")
            nonSearchableDirFound = 1
          }
        }
      } else {
        myPaths = add_path(array: myPaths, newPath: path)
      }
    }
    if myPaths.isEmpty {
      return nonSearchableDirFound
    }
    
    guard let tree = try? FTSWalker(path: myPaths, options: ftsoptions, sort: options.issort != 0 ? find_compare : nil) else {
      err(1, "ftsopen")
      fatalError()
    }
    
    exitstatus = nonSearchableDirFound
    for var entryz in tree {

      if maxdepth != -1 && entryz.level >= maxdepth {
        entryz.setAction(FTSAction.SKIP)
      }
      
      switch entryz.info {
        case .D:
          if isdepth != 0 {
          continue
        }
        case .DP:
          if isdepth == 0 {
          continue
        }
        case .DNR, .NS:
          if (ignore_readdir_race != 0) && entryz.errno.code == Darwin.ENOENT && entryz.level > 0 {
          continue
        }
        fallthrough
        case .ERR:
        fflush(stdout)
          warnx("\(entryz.path): \(entryz.errno.localizedDescription)")
        exitstatus = 1
        continue
        case .W:
          if ftsoptions.contains(.WHITEOUT) {
          break
        }
        continue
      default:
        break
      }
      
      if (options.isxargs != 0) && entryz.path.contains(where: { " \t\n\\'\"".contains($0) }) {
        fflush(Darwin.stdout)
        warnx("\(entryz.path): illegal path")
        exitstatus = 1
        continue
      }
      
      if mindepth != -1 && entryz.level < mindepth {
        continue
      }
      
      for p in plan {
        let j = p.execute(entryz)
        if j == false {
          break
        }
      }
    }
    e = Int(errno)
    
    finish_execplus()
    
    if e != 0 && ((ignore_readdir_race == 0) || e != Darwin.ENOENT) {
      // FIXME: it's the errc
      //    errc(1, e, "fts_read")
      err(1, "fts_read")
      
    }
    return exitstatus
  }
}
