
// Generated by Robert M. Lefkowitz <r0ml@liberally.net> in 2024 using ChatGPT
// from a file containing the following notice:

/*
 * SPDX-License-Identifier: BSD-3-Clause
 *
 * Copyright (c) 1990, 1993
 *  The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Cimarron D. Taylor of the University of California, Berkeley.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

import Foundation
import CMigration

extension find {
  
  func COMPARE<T : Equatable & Comparable>(_ a: T, _ b: T, _ plan: PLAN) -> Bool {
    switch plan.flags & F_ELG_MASK {
    case F_EQUAL:
      return a == b
    case F_LESSTHAN:
      return a < b
    case F_GREATER:
      return a > b
    default:
      fatalError()
    }
  }
  
  
  /*
   func palloc(_ option: OPTION) -> PLAN {
   PLAN(execute: option.execute, flags: option.flags)
   }
   */
  
  /*
   * find_parsenum --
   *  Parse a string of the form [+-]# and return the value.
   */
  func find_parsenum(plan: inout PLAN, option: String, vp: String, endch: inout Character?) -> Int {
    var str: String
    
    str = vp
    switch str.first {
    case "+":
      str.removeFirst()
      plan.flags |= F_GREATER
    case "-":
      str.removeFirst()
      plan.flags |= F_LESSTHAN
    default:
      plan.flags |= F_EQUAL
    }
    
    
    let vv = str.prefixMatch(of: /[0-9]+/)
    if vv == nil || vv!.range.isEmpty {
      errx(1, "\(option): \(vp): illegal time value")
    }
    let value = Int(vv!.output)!
    str.removeSubrange(vv!.range)
    
    endch = str.first
    return value
  }
  
  /*
   * find_parsetime --
   *  Parse a string of the form [+-]([0-9]+[smhdw]?)+ and return the value.
   */
  func find_parsetime(plan: inout PLAN, option: String, vp: String) -> Int64 {
    
    var str = Substring(vp)
    switch str.first {
    case "+":
      str.removeFirst()
      plan.flags |= F_GREATER
    case "-":
      str.removeFirst()
      plan.flags |= F_LESSTHAN
    default:
      plan.flags |= F_EQUAL
    }
    
    var first = true
    var secs: Int64 = 0
    // var value: Int64 = 0
    if str.isEmpty {
      errx(1, "\(option): \(vp): illegal time value")
    }
    while !str.isEmpty {
      let vv = str.prefixMatch(of: /[0-9]+/)
      if vv == nil || vv!.range.isEmpty {
        errx(1, "\(option): \(vp): illegal time value")
      }
      let value = Int64(vv!.output)!
      str.removeSubrange(vv!.range)
      
      if str.isEmpty {
        if first {
          return value
        } else {
          errx(1, "\(option): \(vp): missing trailing unit")
        }
      }
      first = false
      
      let unit = str.first!
      switch unit {
      case "s":
        secs += value
      case "m":
        secs += value * 60
      case "h":
        secs += value * 3600
      case "d":
        secs += value * 86400
      case "w":
        secs += value * 604800
      default:
        errx(1, "\(option): \(vp): bad unit '\(unit)'")
      }
      str.removeFirst()
    }
    plan.flags |= F_EXACTTIME
    return secs
  }
  
  /*
   * nextarg --
   *  Check that another argument still exists, return a pointer to it,
   *  and increment the argument vector pointer.
   */
  func nextarg(option: OPTION, argvp: inout ArraySlice<String>) -> String {
    guard let arg = argvp.first else {
      fatalError("\(option.name): requires additional arguments")
    }
    argvp.removeFirst()
    return arg
  }
  
  
  /*extension PLAN {
   var t_data : timespec { get { p_un._t_data }
   set { p_un._t_data = newValue } }
   var c_data : String { get { String(cString: p_un._c_data) }
   set { newValue.withCString { p_un._c_data = UnsafeMutablePointer(mutating: $0) } }
   }
   var i_data : ino_t { get { p_un._i_data }
   set { p_un._i_data = newValue }
   }
   var g_data : gid_t { get { p_un._g_data }
   set { p_un._g_data = newValue }
   }
   var m_data : mode_t { get { p_un._m_data }
   set { p_un._m_data = newValue }
   }
   }
   */
  
  func f_Xmin(_ plan: PLAN, _ entry: MyFTSENT) -> Bool {
    if case let .t_data(td) = plan.p_un {
      if plan.flags & F_TIME_C != 0 {
        return COMPARE((now - entry.e.fts_statp.st_ctime + 60 - 1) / 60, td.tv_sec, plan)
      } else if plan.flags & F_TIME_A != 0 {
        return COMPARE((now - entry.e.fts_statp.st_atime + 60 - 1) / 60, td.tv_sec, plan)
      } else if plan.flags & F_TIME_B != 0 {
        return COMPARE((now - entry.e.fts_statp.st_birthtime + 60 - 1) / 60, td.tv_sec, plan)
      } else {
        return COMPARE((now - entry.e.fts_statp.st_mtime + 60 - 1) / 60, td.tv_sec, plan)
      }
    }
    fatalError("badly formed plan")
  }
  
  func c_Xmin(_ option: OPTION, _ argvp: inout ArraySlice<String>) -> PLAN {
    let nmins = nextarg(option: option, argvp: &argvp)
    var new = PLAN(option)
    var endch : Character?
    
    var td = timespec()
    td.tv_sec = find_parsenum(plan: &new, option: option.name, vp: nmins, endch: &endch)
    td.tv_nsec = 0
    new.p_un = .t_data(td)
    if (new.flags & F_ELG_MASK) == F_LESSTHAN {
      td.tv_sec += 1
      new.p_un = .t_data(td)
    }
    return new
  }
  
  func f_Xtime(plan: PLAN, entry: MyFTSENT) -> Bool {
    var xtime: time_t
    
    if plan.flags & F_TIME_A != 0 {
      xtime = entry.e.fts_statp.st_atime
    } else if plan.flags & F_TIME_B != 0 {
      xtime = entry.e.fts_statp.st_birthtime
    } else if plan.flags & F_TIME_C != 0 {
      xtime = entry.e.fts_statp.st_ctime
    } else {
      xtime = entry.e.fts_statp.st_mtime
    }
    
    if case let .t_data(td) = plan.p_un {
      if plan.flags & F_EXACTTIME != 0 {
        return COMPARE(now - xtime, td.tv_sec, plan)
      } else {
        return COMPARE((now - xtime + (unix2003_compat ? 0 : 86400 - 1)) / 86400, td.tv_sec, plan)
      }
    }
    fatalError("badly formed plan")
  }
  
  func c_Xtime(_ option: OPTION, _ argvp: inout ArraySlice<String>) -> PLAN {
    let value = nextarg(option: option, argvp: &argvp)
    var new = PLAN(option)
    var td = timespec()
    td.tv_sec = Int(find_parsetime(plan: &new, option: option.name, vp: value))
    td.tv_nsec = 0
    new.p_un = .t_data(td)
    if !(new.flags & F_EXACTTIME != 0) && !unix2003_compat {
      td.tv_sec += 1
      new.p_un = .t_data(td)
    }
    return new
  }
  
  func c_mXXdepth(_ option: OPTION, _ argvp: inout ArraySlice<String>) -> PLAN {
    let dstr = nextarg(option: option, argvp: &argvp)
    if dstr.first == "-" {
      fatalError("\(option.name): \(dstr): value must be positive")
    }
    
    var new = PLAN(option)
    var endch : Character?
    if option.flags & F_MAXDEPTH != 0 {
      maxdepth = Int32(find_parsenum(plan: &new, option: option.name, vp: dstr, endch: &endch))
    } else {
      mindepth = Int32(find_parsenum(plan: &new, option: option.name, vp: dstr, endch: &endch))
    }
    return new
  }
  
  
  func f_acl(_ plan: PLAN, _ entry: MyFTSENT) -> Bool {
    var ae: acl_entry_t?
    
    var match = false
    let facl = acl_get_link_np(entry.e.fts_accpath, ACL_TYPE_EXTENDED)
    if facl != nil {
      if acl_get_entry(facl, ACL_FIRST_ENTRY.rawValue, &ae) == 0 {
        match = true
      }
      acl_free(UnsafeMutableRawPointer(facl) )
    }
    return match
  }
  
  
  
  
  
  
  func c_acl(_ option: OPTION, _ argvp: inout ArraySlice<String>) -> PLAN {
    // FIXME: all the other apple oses
#if !os(macOS)
    ftsoptions &= ~FTS_NOSTAT
#endif
    return PLAN(option)
  }
  
#if os(macOS) || os(iOS) || os(visionOS) || os(tvOS) || os(watchOS)
  func f_xattr(_ plan: PLAN, _ entry: MyFTSENT) -> Bool {
    var xattr: ssize_t
    var match = false
    xattr = listxattr(entry.e.fts_accpath, nil, 0, XATTR_NOFOLLOW)
    if xattr > 0 {
      match = true
    }
    return match
  }
  
  func f_xattrname(_ plan: PLAN, _ entry: MyFTSENT) -> Bool {
    var xattr: ssize_t
    var match = false
    if case let .c_data(cd) = plan.p_un {
      xattr = getxattr(entry.e.fts_accpath, cd, nil, 0, 0, XATTR_NOFOLLOW)
      if xattr > 0 {
        match = true
      }
      return match
    }
    fatalError("badly formed plan")
  }
#endif
  
  func f_delete(_ plan: PLAN, _ entry: MyFTSENT) -> Bool {
    
    let accpath = String(cString: entry.e.fts_accpath)
    
    if accpath == "." || accpath == ".." {
      return true
    }
    
    if isdepth == 0 || (ftsoptions & FTS_NOSTAT) != 0 {
      errx(1, "-delete: insecure options got turned on")
    }
    
    if (ftsoptions & FTS_PHYSICAL) == 0 || (ftsoptions & FTS_LOGICAL) != 0 {
      errx(1, "-delete: forbidden when symlinks are followed")
    }
    
    if entry.e.fts_level > FTS_ROOTLEVEL {
      let accpath = String(cString: entry.e.fts_accpath)
      if accpath.contains("/") {
        errx(1, "-delete: \(accpath): relative path potentially not safe")
      }
    }
    
    // FIXME: hhn
    //    #if HAVE_STRUCT_STAT_ST_FLAGS
    if (entry.e.fts_statp.pointee.st_flags & UInt32(UF_APPEND|UF_IMMUTABLE)) != 0 &&
        (entry.e.fts_statp.pointee.st_flags & UInt32(SF_APPEND|SF_IMMUTABLE)) == 0 &&
        geteuid() == 0 {
      lchflags(entry.e.fts_accpath, entry.e.fts_statp.pointee.st_flags & ~UInt32(UF_APPEND|UF_IMMUTABLE))
    }
    //    #endif
    
    let fts_path = String(cString: entry.e.fts_path)
    
    if S_ISDIR(entry.e.fts_statp.pointee.st_mode) {
      if rmdir(entry.e.fts_accpath) < 0 && errno != ENOTEMPTY {
        warn("-delete: rmdir(\(fts_path))")
      }
    } else {
      if unlink(entry.e.fts_accpath) < 0 {
        warn("-delete: unlink(\(fts_path))")
      }
    }
    
    return true
  }
  
  func c_delete(_ option: OPTION, _ argvp: inout ArraySlice<String>) -> PLAN {
    ftsoptions &= ~FTS_NOSTAT
    isoutput = 1
    isdepth = 1
    
    if (ftsoptions & FTS_NOCHDIR) != 0 {
      errx( 1, "-delete: forbidden when the current directory cannot be opened")
    }
    
    return PLAN(option)
  }
  
  func f_always_true(_ plan: PLAN, _ entry: MyFTSENT) -> Bool {
    return true
  }
  
  func f_depth(_ plan: PLAN, _ entry: MyFTSENT) -> Bool {
    if case let .d_data(dd) = plan.p_un {
      if (plan.flags & F_DEPTH) != 0 {
        return COMPARE(entry.e.fts_level, dd, plan)
      } else {
        return true
      }
    }
    fatalError("badly formed plan")
    
  }
  
  func c_depth(_ option: OPTION, _ argvp: inout ArraySlice<String>) -> PLAN {
    var new = PLAN(option)
    //  let str = argvp.first
    
    if var str = argvp.first, (new.flags & F_DEPTH) == 0 {
      if str.hasPrefix("+") || str.hasPrefix( "-") {
        str.removeFirst()
      }
      if str.hasPrefix("+") || str.hasPrefix("-") {
        str.removeFirst()
      }
      if let x = str.first, x.isNumber {
        new.flags |= F_DEPTH
      }
    }
    
    if (new.flags & F_DEPTH) != 0 {
      let ndepth = nextarg(option: option, argvp: &argvp)
      var endch : Character?
      new.p_un = .d_data( Int16(find_parsenum(plan: &new, option: option.name, vp: ndepth, endch: &endch) ) )
    } else {
      isdepth = 1
    }
    
    return new
  }
  
  func f_empty(_ plan: PLAN, _ entry: MyFTSENT) -> Bool {
    if S_ISREG(entry.e.fts_statp?.pointee.st_mode ?? 0) &&
        entry.e.fts_statp?.pointee.st_size ?? 0 == 0 {
      return true
    }
    if S_ISDIR(entry.e.fts_statp.pointee.st_mode) {
      var empty: Bool
      
      // FIXME: maybe do it this way?
      /*      let accpath = String(cString: entry.fts_accpath)
       FileManager.default.contentsOfDirectory(atPath: accpath)
       */
      let dir = opendir(entry.e.fts_accpath)
      if dir == nil {
        return false
      }
      
      empty = true
      while let dp = readdir(dir) {
        let dn = withUnsafeBytes(of: dp.pointee.d_name) { p in
          String(cString: p.assumingMemoryBound(to: CChar.self).baseAddress!)
        }
        if dn != "." || dn != ".." {
          empty = false
          break
        }
      }
      closedir(dir)
      return empty
    }
    return false
  }
  
  func c_empty(_ option: OPTION, _ argvp: inout ArraySlice<String>) -> PLAN {
    ftsoptions &= ~FTS_NOSTAT
    return PLAN(option)
  }
  
  
  func f_exec(_ plan: PLAN, _ entry: MyFTSENT) -> Bool {
    
    if case let .ex_data(epee) = plan.p_un {
      
      let fts_path = String(cString: entry.e.fts_path)
      var file = fts_path
      if (plan.flags & F_EXECDIR) != 0 {
        if let rr = fts_path.lastIndex(of: "/") {
          file = String(fts_path[rr...].dropFirst())
          
          //          file = strrchr(entry.fts_path, "/")
          //          if file != nil {
          //            file = file?.advanced(by: 1)
        }
      }
      
      if (plan.flags & F_EXECPLUS) != 0 {
        epee.e_argv.append(file)
        
        // FIXME: if I have run out of available arguments...
        // don't return, but continue on to execute
        // if eee.e_ppos < eee.e_pnummax /* &&
//                                        eee.e_psize < eee.e_psizemax */ {
        if epee.e_argv.count < epee.e_argmax {
          return true
        }
//         }
      } else {
        epee.e_argv = epee.e_orig.map { brace_subst($0, file) }
        //            for cnt in 0..<(eee.e_argv.count) {
        //              if eee.e_len[cnt] != 0 {
        //                eee.e_argv[cnt] = brace_subst(eee.e_orig[cnt], fil)
        //              }
      }
      
      return do_exec(plan, entry)
    }
    fatalError("badly formed plan")
  }
  
  func do_exec(_ plan : PLAN, _ entry : MyFTSENT?) -> Bool {
    if case let .ex_data(epee) = plan.p_un {
      if (plan.flags & F_NEEDOK) != 0 && !queryuser(epee.e_argv) {
        return false
      }
      
      fflush(stdout)
      fflush(stderr)
      
      
      
      
      let p = Process()
      p.arguments = Array(epee.e_argv.dropFirst())
      p.executableURL = URL.init(filePath: searchPath(for: epee.e_argv.first!)!)
      
      // FIXME: change the current directory as needed
      
       if let entry, (plan.flags & F_EXECDIR) == 0 && (ftsoptions & FTS_NOCHDIR) == 0 {
       
         p.currentDirectoryURL = URL(filePath: String(cString: entry.e.fts_parent.pointee.fts_path))
       }
      
      
      try! p.run()
      p.waitUntilExit()
      let status = p.terminationStatus
      
      epee.e_argv = epee.e_orig
      
      if WIFEXITED(status) && (WEXITSTATUS(status) == 0) {
        return true
      }
      if (plan.flags & F_EXECPLUS) != 0 {
        exitstatus = 1
        return true
      }
      return false
    }
    fatalError("badly formed plan")
  }

  
  func c_exec(_ option: OPTION, _ argvp: inout ArraySlice<String>) -> PLAN {
    var new: PLAN
    
    if (option.flags & F_EXECDIR) != 0 && (ftsoptions & FTS_NOCHDIR) != 0 {
      errx(1, "-execdir: forbidden when the current directory cannot be opened")
    }
    
    isoutput = 1
    
    new = PLAN(option)
    
    var xarg = ArraySlice<String>()
    
    while true {
      if argvp.isEmpty {
        errx(1, "\(option.name): no terminating \";\" or \"+\"")
      }
      let ap = argvp.removeFirst()
      if ap == ";" {
        break
      }
      if ap == "+" && xarg.last == "{}" {
        new.flags |= F_EXECPLUS
        xarg.removeLast()
        break
      }
      xarg.append(ap)
    }
    
    
    
    if xarg.count == 0 {
      errx(1, "\(option.name): no command specified")
    }
    
    //    cnt = ap - argvp?.pointee ?? 0 + 1
//    let cnt = xarg.count
    
    let ee = ex()
    ee.e_argv = Array(xarg)
    ee.e_orig = Array(xarg)
    
    new.p_un = .ex_data(ee)

    if (new.flags & F_EXECPLUS) != 0 {
//      ee.e_ppos = cnt - 2
//      ee.e_pbnum = cnt - 2
      var argmax = sysconf(_SC_ARG_MAX)
      if argmax == -1 {
        warn("sysconf(_SC_ARG_MAX)")
        argmax = Int(_POSIX_ARG_MAX)
      }
      argmax -= 1024
      argmax -= argmax/16
      let x = ProcessInfo.processInfo.environment.reduce(0, {(s, kv) -> Int in s + kv.0.count + kv.1.count + 16 } )
      argmax -= x
      ee.e_argmax = argmax
      
//      ee.e_pnummax = (new.flags & F_EXECDIR) != 0 ? 1 : argmax / 16
//      argmax -= Int(ee.e_pnummax)
//      if argmax <= 0 {
//        errx(1, "no space for arguments")
//      }
      //     ee.e_psizemax = Int32(argmax)
//      ee.e_pbsize = 0
 //     cnt += Int(ee.e_pnummax + 1)
      
//      ee.e_next = lastexecplus
      lastexecplus.append(new)
    }
    
    return new
  }

  
  func finish_execplus() {
    for p in lastexecplus {
      // FIXME: this was execute(nil)
        let _ = do_exec(p, nil)
    }
  }
  
  // FIXME: ??
  // #if HAVE_STRUCT_STAT_ST_FLAGS
  func f_flags(_ plan: PLAN, _ entry: MyFTSENT) -> Bool {
    let flags: UInt32
    
    if case let .fl_flags(fl, nfl) = plan.p_un {
      flags = entry.e.fts_statp.pointee.st_flags
      if (plan.flags & F_ATLEAST) != 0 {
        return (flags | fl) == flags &&
        ((flags & nfl) == 0)
      } else if (plan.flags & F_ANY) != 0 {
        return ((flags & fl) != 0) ||
        (flags | nfl) != flags
      } else {
        return flags == fl &&
        ((fl & nfl) == 0)
      }
    }
    fatalError("badly formed plan")
    
  }
  
  func c_flags(_ option: OPTION, _ argvp: inout ArraySlice<String>) -> PLAN {
    var flags_str = nextarg(option: option, argvp: &argvp)
    ftsoptions &= ~FTS_NOSTAT
    
    var new = PLAN(option)
    
    if flags_str.hasPrefix("-") {
      new.flags |= F_ATLEAST
      flags_str.removeFirst()
    } else if flags_str.hasPrefix("+") {
      new.flags |= F_ANY
      flags_str.removeFirst()
    }
    
    var k = strdup(flags_str)
    var fl1 = 0
    var nfl1 = 0
    if strtofflags(&k, &fl1, &nfl1) == 1 {
      errx(1, "\(option.name): \(flags_str): illegal flags string")
    }
    
    new.p_un = .fl_flags( UInt32(fl1), UInt32(nfl1) )
    
    return new
  }
  // #endif
  
  
  
  
  
  
  /*
   * -follow functions --
   *
   *  Always true, causes symbolic links to be followed on a global
   *  basis.
   */
  func c_follow(_ option: OPTION, _ argvp: inout ArraySlice<String>) -> PLAN {
    ftsoptions &= ~FTS_PHYSICAL
    ftsoptions |= FTS_LOGICAL
    return PLAN(option)
  }
  
  
  // FIXME: aarg
  // #if HAVE_STRUCT_STATFS_F_FSTYPENAME
  /*
   * -fstype functions --
   *
   *  True if the file is of a certain type.
   */
  func f_fstype(_ plan: PLAN, _ entry: MyFTSENT) -> Bool {
    var sb = statfs()
    var val_flags : Int16 = 0
    var fstype : String = ""
    
    if ((plan.flags & F_MTMASK) == F_MTUNKNOWN) {
      return false
    }
    
    let accpath = String(cString: entry.e.fts_accpath)
    
    
    /* Only check when we cross mount point. */
    if (first || curdev != entry.e.fts_statp.pointee.st_dev) {
      curdev = entry.e.fts_statp.pointee.st_dev
      
      var p : String? = String(cString: entry.e.fts_accpath)
      var savep : String?
      /*
       * Statfs follows symlinks; find wants the link's filesystem,
       * not where it points.
       */
      if (entry.e.fts_info == FTS_SL ||
          entry.e.fts_info == FTS_SLNONE) {
        if let px = p!.lastIndex(of: "/") {
          let r = p!.startIndex...px
          p?.removeSubrange(r)
        }
        savep = p
        p = "."
      } else {
        p = nil
      }
      
      if ((statfs(entry.e.fts_accpath, &sb)) != 0) {
        if ((ignore_readdir_race == 0) || errno != ENOENT) {
          warn("statfs: \(accpath)")
          exitstatus = 1
        }
        return false
      }
      
      if let savep {
        p = savep
      }
      
      first = false
      /*
       * Further tests may need both of these values, so
       * always copy both of them.
       */
      val_flags = Int16(sb.f_flags)
      
      fstype = withUnsafeBytes(of: sb.f_fstypename) { p in
        String(cString: p.assumingMemoryBound(to: CChar.self).baseAddress!)
      }
    }
    switch (plan.flags & F_MTMASK) {
    case F_MTFLAG:
      if case let .mt_data(mt) = plan.p_un {
        return ((val_flags & mt) != 0)
      }
      fatalError("badly formed plan")
      
    case F_MTTYPE:
      if case let .c_data(ct) = plan.p_un {
        return fstype == ct
      }
      fatalError("badly formed plan")
      
    default:
      abort()
    }
  }
  
  func c_fstype(_ option: OPTION, _ argvp: inout ArraySlice<String>) -> PLAN {
    var fsname: String
    var new: PLAN
    
    fsname = nextarg(option: option, argvp: &argvp)
    ftsoptions &= ~FTS_NOSTAT
    
    new = PLAN(option)
    switch fsname {
    case "local":
      new.flags |= F_MTFLAG
      new.p_un = .mt_data(Int16(MNT_LOCAL))
      return new
    case "rdonly":
      new.flags |= F_MTFLAG
      new.p_un = .mt_data(Int16(MNT_RDONLY))
      return new
    default:
      break
    }
    
    new.flags |= F_MTTYPE
    new.p_un = .c_data(fsname)
    return new
  }
  // #endif
  
  /*
   * -group gname functions --
   *
   *  True if the file belongs to the group gname.  If gname is numeric and
   *  an equivalent of the getgrnam() function does not return a valid group
   *  name, gname is taken as a group ID.
   */
  func f_group(_ plan: PLAN, _ entry: MyFTSENT) -> Bool {
    if case let .g_data(gd) = plan.p_un {
      return COMPARE(entry.e.fts_statp.pointee.st_gid, gd, plan)
    }
    fatalError("badly formed plan")
    
  }
  
  func c_group(_ option: OPTION, _ argvp: inout ArraySlice<String>) -> PLAN {
    var gname: String
    var new: PLAN
    // var g: group
    var gid: gid_t
    
    gname = nextarg(option: option, argvp: &argvp)
    ftsoptions &= ~FTS_NOSTAT
    
    new = PLAN(option)
    let gx = getgrnam(gname)
    if (gx == nil) {
      let cp = gname
      if (gname.hasPrefix("-") || gname.hasPrefix("+") ) {
        gname.removeFirst()
      }
      gid = gid_t(atoi(gname))
      if (gid == 0 && !gname.hasPrefix("0") ) {
        errx(1, "\(option.name): \(gname): no such group")
      }
      var endch : Character?
      gid = gid_t(find_parsenum(plan: &new, option: option.name, vp: cp, endch: &endch))
    } else {
      gid = gx!.pointee.gr_gid
    }
    
    new.p_un = .g_data(gid)
    return new
  }
  
  /*
   * -ignore_readdir_race functions --
   *
   *  Always true. Ignore errors which occur if a file or a directory
   *  in a starting point gets deleted between reading the name and calling
   *  stat on it while find is traversing the starting point.
   */
  
  func c_ignore_readdir_race(_ option: OPTION, _ argvp: inout ArraySlice<String>) -> PLAN {
    if (option.name == "-ignore_readdir_race") {
      ignore_readdir_race = 1
    }
    else {
      ignore_readdir_race = 0
    }
    
    return PLAN(option)
  }
  
  /*
   * -inum n functions --
   *
   *  True if the file has inode # n.
   */
  func f_inum(_ plan: PLAN, _ entry: MyFTSENT) -> Bool {
    if case let .i_data(id) = plan.p_un {
      return COMPARE(entry.e.fts_statp.pointee.st_ino, id, plan)
    }
    fatalError("badly formed plan")
    
  }
  
  func c_inum(_ option: OPTION, _ argvp: inout ArraySlice<String>) -> PLAN {
    var inum_str: String
    var new: PLAN
    
    inum_str = nextarg(option: option, argvp: &argvp)
    ftsoptions &= ~FTS_NOSTAT
    
    new = PLAN(option)
    var endch : Character?
    new.p_un = .i_data(ino_t(find_parsenum(plan: &new, option: option.name, vp: inum_str, endch: &endch)))
    return new
  }
  
  /*
   * -samefile FN
   *
   *  True if the file has the same inode (eg hard link) FN
   */
  
  /* f_samefile is just f_inum */
  func c_samefile(_ option: OPTION, _ argvp: inout ArraySlice<String>) -> PLAN {
    var fn: String
    var new: PLAN
    var sb = stat()
    var error: Int
    
    fn = nextarg(option: option, argvp: &argvp)
    ftsoptions &= ~FTS_NOSTAT
    
    new = PLAN(option)
#if os(macOS) || os(iOS) || os(tvOS) || os(watchOS) || os(visionOS)
    /*
     * rdar://problem/77588562 - upstream started applying -H/-L/-P to non-path
     * operands, which seems to be incompatible with the specification and
     * causes failures in the conformance test suite.
     */
    error = Int(stat(fn, &sb))
#else
    if ((ftsoptions & FTS_PHYSICAL) != 0) {
      error = lstat(fn, &sb)
    }
    else {
      error = stat(fn, &sb)
    }
#endif
    if (error != 0) {
      err(1, fn)
    }
    new.p_un = .i_data(sb.st_ino)
    return new
  }
  
  /*
   * -links n functions --
   *
   *  True if the file has n links.
   */
  func f_links(_ plan: PLAN, _ entry: MyFTSENT) -> Bool {
    if case let .l_data(ld) = plan.p_un {
      return COMPARE(entry.e.fts_statp.pointee.st_nlink, ld, plan)
    }
    fatalError("badly formed plan")
  }
  
  func c_links(_ option: OPTION, _ argvp: inout ArraySlice<String>) -> PLAN {
    var nlinks: String
    var new: PLAN
    
    nlinks = nextarg(option: option, argvp: &argvp)
    ftsoptions &= ~FTS_NOSTAT
    
    new = PLAN(option)
    var endch : Character?
    new.p_un = .l_data( nlink_t(find_parsenum(plan: &new, option: option.name, vp: nlinks, endch: &endch)))
    return new
  }
  
  /*
   * -ls functions --
   *
   *  Always true - prints the current entry to stdout in "ls" format.
   */
  func f_ls(plan: PLAN, entry: MyFTSENT) -> Bool {
    self.printlong(name: String(cString: entry.e.fts_path), accpath: String(cString: entry.e.fts_accpath), sb: entry.e.fts_statp.pointee)
    return true
  }
  
  func c_ls(_ option: OPTION, _ argvp: inout ArraySlice<String>) -> PLAN {
    ftsoptions &= ~FTS_NOSTAT
    isoutput = 1
    
    return PLAN(option)
  }
  
  /*
   * -name functions --
   *
   *  True if the basename of the filename being examined
   *  matches pattern using Pattern Matching Notation S3.14
   */
  func f_name(_ plan: PLAN, _ entry: MyFTSENT) -> Bool {
    // var fn = [Int8](repeating: 0, count: PATH_MAX)
    var name: String?
    // var len: ssize_t
    
    if ((plan.flags & F_LINK) != 0) {
      /*
       * The below test both avoids obviously useless readlink()
       * calls and ensures that symlinks with existent target do
       * not match if symlinks are being followed.
       * Assumption: fts will stat all symlinks that are to be
       * followed and will return the stat information.
       */
      if (entry.e.fts_info != FTS_NSOK && entry.e.fts_info != FTS_SL &&
          entry.e.fts_info != FTS_SLNONE) {
        return false
      }
      
      name = withUnsafeTemporaryAllocation(byteCount: Int(PATH_MAX), alignment: 1) { p -> String? in
        let pp = p.assumingMemoryBound(to: CChar.self).baseAddress!
        let len = readlink(entry.e.fts_accpath, pp , Int(PATH_MAX) - 1)
        if (len == -1) {
          return nil
        } else {
          let k = Data(bytes: pp, count: len)
          return String(data: k, encoding: .ascii)
        }
      }
      if name == nil { return false }
    } else if (entry.e.fts_namelen == 0) {
      name = String(cString: basename(entry.e.fts_path))
    } else {
      name = entry.nam
    }
    if case let .c_data(cd) = plan.p_un {
      return (fnmatch(cd, name,
                      ((plan.flags & F_IGNCASE) != 0) ? FNM_CASEFOLD : 0) == 0)
    }
    fatalError("badly formed plan")
    
  }
  
  func c_name(_ option: OPTION, _ argvp: inout ArraySlice<String>) -> PLAN {
    var pattern: String
    var new: PLAN
    
    pattern = nextarg(option: option, argvp: &argvp)
    new = PLAN(option)
    new.p_un = .c_data(pattern)
    return new
  }
  
  /*
   * -newer file functions --
   *
   *  True if the current file has been modified more recently
   *  then the modification time of the file named by the pathname
   *  file.
   */
  func f_newer(_ plan: PLAN, _ entry: MyFTSENT) -> Bool {
    var ft: timespec
    
    if ((plan.flags & F_TIME_C) != 0) {
      ft = entry.e.fts_statp.st_ctim
    }
    /*
     * rdar://problem/77588562 - this segment is covered by
     * HAVE_STRUCT_STAT_ST_BIRTHTIME upstream, which is wrong.
     */
    else if ((plan.flags & F_TIME_A) != 0) {
      ft = entry.e.fts_statp.st_atim
    }
    // FIXME: ar
    // #if HAVE_STRUCT_STAT_ST_BIRTHTIME
    else if ((plan.flags & F_TIME_B) != 0) {
      ft = entry.e.fts_statp.st_birthtim
    }
    // #endif
    else {
      ft = entry.e.fts_statp.pointee.st_mtim
    }
    
    if case let .t_data(td) = plan.p_un {
      return (ft.tv_sec > td.tv_sec ||
              (ft.tv_sec == td.tv_sec &&
               ft.tv_nsec > td.tv_nsec))
    }
    fatalError("badly formed plan")
    
  }
  
  func c_newer(_ option: OPTION, _ argvp: inout ArraySlice<String>) -> PLAN {
    var fn_or_tspec: String
    var new: PLAN
    var sb = Darwin.stat()
    var error: Int32
    
    fn_or_tspec = nextarg(option: option, argvp: &argvp)
    ftsoptions &= ~FTS_NOSTAT
    
    new = PLAN(option)
    /* compare against what */
    
    
    
    if ((option.flags & F_TIME2_T) != 0) {
      var td = Darwin.timespec()
      fn_or_tspec.withCString { p in
        // FIXME: get_date not implemented (it's a yacc file)
        fatalError("get_date not implemented")
//        td.tv_sec = get_date(UnsafeMutablePointer(mutating: p) )
        new.p_un = .t_data(td)
      }
      if (td.tv_sec == time_t(-1)) {
        errx(1, "Can't parse date/time: \(fn_or_tspec)")
      }
      /* Use the seconds only in the comparison. */
      td.tv_nsec = 999999999
      new.p_un = .t_data(td)
    } else {
#if os(macOS) || os(iOS) || os(tvOS) || os(watchOS) || os(visionOS)
      /* rdar://problem/77588562 - see c_samefile() above. */
      // in order to comply with the test suite, this should
      // be lstat not stat
      error = lstat(fn_or_tspec, &sb)
#else
      if ((ftsoptions & Darwin.FTS_PHYSICAL) != 0) {
        error = lstat(fn_or_tspec, &sb)
      }
      else {
        error = stat(fn_or_tspec, &sb)
      }
#endif
      if (error != 0) {
        err(1, fn_or_tspec)
      }
      if ((option.flags & F_TIME2_C) != 0) {
        new.p_un  = .t_data(sb.st_ctim)
      }
      else if ((option.flags & F_TIME2_A) != 0) {
        new.p_un = .t_data(sb.st_atim)
      }
      // FIXME: harrumph
      // #if HAVE_STRUCT_STAT_ST_BIRTHTIME
      else if ((option.flags & F_TIME2_B) != 0) {
        new.p_un = .t_data(sb.st_birthtim)
      }
      // #endif
      else {
        new.p_un = .t_data(sb.st_mtim)
      }
    }
    return new
    
  }
  
  /*
   * -nogroup functions --
   *
   *  True if file belongs to a user ID for which the equivalent
   *  of the getgrnam() 9.2.1 [POSIX.1] function returns NULL.
   */
  func f_nogroup(plan: PLAN, entry: MyFTSENT) -> Bool {
    return Darwin.group_from_gid(entry.e.fts_statp.pointee.st_gid, 1) == nil
  }
  
  func c_nogroup(_ option: OPTION, _ argvp: inout ArraySlice<String>) -> PLAN {
    ftsoptions &= ~Darwin.FTS_NOSTAT
    
    return PLAN(option)
  }
  
  /*
   * -nouser functions --
   *
   *  True if file belongs to a user ID for which the equivalent
   *  of the getpwuid() 9.2.2 [POSIX.1] function returns NULL.
   */
  func f_nouser(plan: PLAN, entry: MyFTSENT) -> Bool {
    return user_from_uid(entry.e.fts_statp.pointee.st_uid, 1) == nil
  }
  
  func c_nouser(_ option: OPTION, _ argvp: inout ArraySlice<String>) -> PLAN {
    ftsoptions &= ~Darwin.FTS_NOSTAT
    
    return PLAN(option)
  }
  
  /*
   * -path functions --
   *
   *  True if the path of the filename being examined
   *  matches pattern using Pattern Matching Notation S3.14
   */
  func f_path(plan: PLAN, entry: MyFTSENT) -> Bool {
    if case let .c_data(cd) = plan.p_un {
      return (Darwin.fnmatch(cd, entry.e.fts_path,
                      ((plan.flags & F_IGNCASE) != 0) ? FNM_CASEFOLD : 0) == 0)
    }
    fatalError("badly formed plan")
    
  }
  
  /* c_path is the same as c_name */
  
  /*
   * -perm functions --
   *
   *  The mode argument is used to represent file mode bits.  If it starts
   *  with a leading digit, it's treated as an octal mode, otherwise as a
   *  symbolic mode.
   */
  func f_perm(_ plan: PLAN, _ entry: MyFTSENT) -> Bool {
    if case let .m_data(md) = plan.p_un {
      let mode = entry.e.fts_statp.pointee.st_mode &
      (Darwin.S_ISUID|Darwin.S_ISGID|Darwin.S_ISTXT|Darwin.S_IRWXU|Darwin.S_IRWXG|Darwin.S_IRWXO)
      if ((plan.flags & F_ATLEAST) != 0) {
        return (md | mode) == mode
      }
      else if ((plan.flags & F_ANY) != 0) {
        return ((mode & md) != 0)
      }
      else {
        return mode == md
      }
    }
    fatalError("badly formed plan")
    
    /* NOTREACHED */
  }
  
  
  
  
  
  
  
  
  
  func c_perm(_ option: OPTION, _ argvp: inout ArraySlice<String>) -> PLAN {
    var perm: String
    var new: PLAN
    var set: UnsafeMutablePointer<Darwin.mode_t>?
    
    perm = nextarg(option: option, argvp: &argvp)
    ftsoptions &= ~Darwin.FTS_NOSTAT
    
    new = PLAN(option)
    
    if perm.hasPrefix("-") {
      new.flags |= F_ATLEAST
      perm.removeFirst()
    } else if perm.hasPrefix("+") {
      set = Darwin.setmode((String(perm.dropFirst()))).assumingMemoryBound(to: Darwin.mode_t.self)
      if set != nil {
        new.flags |= F_ANY
        perm.removeFirst()
        free(set)
      }
    }
    
    set = Darwin.setmode(perm).assumingMemoryBound(to: Darwin.mode_t.self)
    if set == nil {
      errx(1, "\(option.name): \(perm): illegal mode string")
    }
    
    new.p_un = .m_data(getmode(set, 0))
    Darwin.free(set)
    return new
  }
  
  func f_print(_ plan: PLAN, _ entry: MyFTSENT) -> Bool {
    Darwin.puts(entry.e.fts_path)
    return true
  }
  
  func c_print(_ option: OPTION, _ argvp: inout ArraySlice<String>) -> PLAN {
    isoutput = 1
    
    return PLAN(option)
  }
  
  func f_print0(_ plan: PLAN, _ entry: MyFTSENT) -> Bool {
    Darwin.fputs(entry.e.fts_path, stdout)
    Darwin.fputc(0, stdout)
    return true
  }
  
  func f_prune(_ plan: PLAN, _ entry: MyFTSENT) -> Bool {
    // FIXME: will this work given that FTSENT is broken?
    var z = entry.e
    if fts_set(tree, &z, FTS_SKIP) != 0 {
      err(1, String(cString: entry.e.fts_path) )
    }
    return true
  }
  
  func f_regex(_ plan: PLAN, _ entry: MyFTSENT) -> Bool {
    var str: String
    var len: Int
    var pmatch = Darwin.regmatch_t()
    var errcode: Int32
    var matched = false
    
    if case var .re_data(pre) = plan.p_un {
      str = String(cString: entry.e.fts_path)
      len = str.count
      pmatch.rm_so = 0
      pmatch.rm_eo = regoff_t(len)
      
      errcode = Darwin.regexec(&pre, str, 1, &pmatch, REG_STARTEND)
      
      if errcode != 0 && errcode != Darwin.REG_NOMATCH {
        withUnsafeTemporaryAllocation(byteCount: Int(LINE_MAX), alignment: 1) { errbuf in
          Darwin.regerror(errcode, &pre, errbuf.baseAddress, errbuf.count)
          let rx = plan.flags & F_IGNCASE != 0 ? "-iregex" : "-regex"
          let errstr = String(cString: errbuf.assumingMemoryBound(to: CChar.self).baseAddress!)
          errx(1, "\(rx): \(errstr)")
        }
      }
      
      if errcode == 0 && pmatch.rm_so == 0 && pmatch.rm_eo == regoff_t(len) {
        matched = true
      }
      
      return matched
    }
    fatalError("badly formed plan")
    
    
  }
  
  func c_regex(_ option: OPTION, _ argvp: inout ArraySlice<String>) -> PLAN {
    var new: PLAN
    var pattern: String
    var pre = Darwin.regex_t()
    var errcode: Int32
    
    //    pre = malloc(MemoryLayout<regex_t>.size).assumingMemoryBound(to: regex_t.self)
    //    if pre == nil {
    //        err(1, nil)
    //    }
    
    pattern = nextarg(option: option, argvp: &argvp)
    
    errcode = regcomp(&pre, pattern, regexp_flags | (option.flags & F_IGNCASE != 0 ? REG_ICASE : 0))
    if errcode != 0 {
      withUnsafeTemporaryAllocation(byteCount: Int(LINE_MAX), alignment: 1) { errbuf in
        regerror(errcode, &pre, errbuf.baseAddress, errbuf.count)
        errx(1, "\(option.flags & F_IGNCASE != 0 ? "-iregex" : "-regex"): \(pattern): \(errbuf)" )
      }
    }
    
    new = PLAN(option)
    new.p_un = .re_data(pre)
    
    return new
  }
  
  func c_simple(_ option: OPTION, _ argvp: inout ArraySlice<String>) -> PLAN {
    return PLAN(option)
  }
  
  func f_size(plan: PLAN, entry: MyFTSENT) -> Bool {
    
    if case let .o_data(od) = plan.p_un {
      let size = divsize != 0 ? (entry.e.fts_statp.pointee.st_size + FIND_SIZE - 1) / FIND_SIZE : entry.e.fts_statp.pointee.st_size
      return COMPARE(size, od, plan)
    }
    fatalError("badly formed plan")
  }
  
  
  func c_size(_ option: OPTION, _ argvp: inout ArraySlice<String>) -> PLAN {
    var size_str: String
    var new: PLAN
    var endch: Character?
    var scale = off_t()
    
    size_str = nextarg(option: option, argvp: &argvp)
    ftsoptions &= ~FTS_NOSTAT
    
    new = PLAN(option)
    endch = "c"
    new.p_un = .o_data(off_t(find_parsenum(plan: &new, option: option.name, vp: size_str, endch: &endch)))
    if endch != "\0" {
      divsize = 0
      
      switch endch {
      case "c":
        scale = 0x1
      case "k":
        scale = 0x400
      case "M":
        scale = 0x100000
      case "G":
        scale = 0x40000000
      case "T":
        scale = 0x10000000000
      case "P":
        scale = 0x4000000000000
      default:
        errx(1, "\(option.name): \(size_str): illegal trailing character")
      }
      
      if case let .o_data(oo) = new.p_un {
        
        
        if oo > QUAD_MAX / scale {
          errx(1, "\(option.name): \(size_str): value too large")
        }
        new.p_un = .o_data(oo * scale)
      }
    }
    return new
  }
  
  func f_sparse(_ plan: PLAN, _ entry: MyFTSENT) -> Bool {
    let expected_blocks = (entry.e.fts_statp.pointee.st_size + 511) / 512
    return entry.e.fts_statp.pointee.st_blocks < expected_blocks
  }
  
  func c_sparse(_ option: OPTION, _ argvp: inout ArraySlice<String>) -> PLAN {
    ftsoptions &= ~FTS_NOSTAT
    
    return PLAN(option)
  }
  
  func f_type(_ plan: PLAN, _ entry: MyFTSENT) -> Bool {
    if case let .m_data(md) = plan.p_un {
      if md == Darwin.S_IFDIR {
        return entry.e.fts_info == Darwin.FTS_D || entry.e.fts_info == Darwin.FTS_DC || entry.e.fts_info == Darwin.FTS_DNR || entry.e.fts_info == Darwin.FTS_DOT || entry.e.fts_info == Darwin.FTS_DP
      } else {
        return (entry.e.fts_statp.pointee.st_mode & Darwin.S_IFMT) == md
      }
    }
    fatalError("badly formed plan")
    
  }
  
  func c_type(_ option: OPTION, _ argvp: inout ArraySlice<String>) -> PLAN {
    var typestring: String
    var new: PLAN
    var mask = Darwin.mode_t()
    
    typestring = nextarg(option: option, argvp: &argvp)
    if typestring != "d" {
      ftsoptions &= ~Darwin.FTS_NOSTAT
    }
    
    switch typestring {
    case "b":
        mask = Darwin.S_IFBLK
    case "c":
        mask = Darwin.S_IFCHR
    case "d":
        mask = Darwin.S_IFDIR
    case "f":
        mask = Darwin.S_IFREG
    case "l":
        mask = Darwin.S_IFLNK
    case "p":
        mask = Darwin.S_IFIFO
    case "s":
        mask = Darwin.S_IFSOCK
    default:
      errx(1, "\(option.name): \(typestring): unknown type")
    }
    
    new = PLAN(option)
    new.p_un = .m_data(mask)
    return new
  }
  
  func f_user(plan: PLAN, entry: MyFTSENT) -> Bool {
    if case let .u_data(ud) = plan.p_un {
      return COMPARE(entry.e.fts_statp.pointee.st_uid, ud, plan)
    }
    fatalError("badly formed plan")
    
  }
  
  func c_user(_ option: OPTION, _ argvp: inout ArraySlice<String>) -> PLAN {
    var username: String
    var new: PLAN
    var p: UnsafeMutablePointer<passwd>?
    var uid: uid_t
    
    username = nextarg(option: option, argvp: &argvp)
    ftsoptions &= ~Darwin.FTS_NOSTAT
    
    new = PLAN(option)
    p = getpwnam(username)
    if p == nil {
      let cp = username
      if username.hasPrefix("-") || username.hasPrefix("+") {
        username.removeFirst()
      }
      uid = uid_t(atoi(username))
      if uid == 0 && !username.hasPrefix("0") {
        errx(1, "\(option.name): \(username): no such user")
      }
      var endch: Character?
      uid = uid_t(find_parsenum(plan: &new, option: option.name, vp: cp, endch: &endch))
    } else {
      uid = p?.pointee.pw_uid ?? 0
    }
    
    new.p_un = .u_data(uid)
    return new
  }
  
  func c_xdev(_ option: OPTION, _ argvp: inout ArraySlice<String>) -> PLAN {
    ftsoptions |= Darwin.FTS_XDEV
    return PLAN(option)
  }
  
  func f_expr(_ plan: PLAN, _ entry: MyFTSENT) -> Bool {
    var state = false
    
    if case let .p_data(pp, _) = plan.p_un {
      for p in pp {
        state = p.execute(entry)
        if !state { break }
      }
      return state
    }
    fatalError("badly formed plan")
    
  }
  
  func f_openparen(_ plan: PLAN, _ entry: MyFTSENT) -> Bool {
    abort()
  }
  
  func f_closeparen(_ plan: PLAN, _ entry: MyFTSENT) -> Bool {
    abort()
  }
  
  
  // FIXME: took this out because needs to return nil?
  func c_and(_ option: OPTION, _ argvp : inout ArraySlice<String>) -> PLAN {
    return PLAN(OPTION("**and**", c_simple, nil, 0))
  }
  
  func f_not(_ plan: PLAN, _ entry: MyFTSENT) -> Bool {
    var state = false
    
    if case let .p_data(pp, _) = plan.p_un {
      for p in pp {
        state = p.execute(entry)
        if !state { break }
      }
      return !state
    }
    fatalError("badly formed plan")
  }
  
  func f_or(_ plan: PLAN, _ entry: MyFTSENT) -> Bool {
    var state = false
    
    if case let .p_data(pp, qq) = plan.p_un {
      for p in pp {
        state = p.execute(entry)
        if !state { break }
      }
      
      if state {
        return true
      }
      
      for q in qq {
        state = q.execute(entry)
        if !state { break }
      }
      return state
    }
    fatalError("badly formed plan")
  }
  
  func f_false(_ plan: PLAN, _ entry: MyFTSENT) -> Bool {
    return false
  }
  
  func f_quit(_ plan: PLAN, _ entry: MyFTSENT) -> Bool {
    finish_execplus()
    exit(exitstatus)
  }
}
