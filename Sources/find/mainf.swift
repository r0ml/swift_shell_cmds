
// Generated by Robert M. Lefkowitz <r0ml@liberally.net> in 2024 using ChatGPT
// from a file containing the following notice:

/*
 * SPDX-License-Identifier: BSD-3-Clause
 *
 * Copyright (c) 1990, 1993, 1994
 *  The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Cimarron D. Taylor of the University of California, Berkeley.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

import CMigration

/*
var now = time_t()
var dotfd : Int32 = 0
var ftsoptions : Int32 = 0
var ignore_readdir_race : Int32 = 0
var isdepth : Int32 = 0
var isoutput : Int32 = 0
var issort : Int32 = 0
var isxargs : Int32 = 0
var mindepth : Int32 = -1
var maxdepth : Int32 = -1
var regexp_flags = REG_BASIC
var exitstatus : Int32 = 0
*/

@main final class find : ShellCommand {
  var now = time_t()
  var exitstatus : Int32 = 0

  // FIXME: these should really be CommandOptions
  var ftsoptions : Int32 = 0
  var regexp_flags = Darwin.REG_BASIC
  var mindepth : Int32 = -1
  var maxdepth : Int32 = -1
  var isdepth : Int32 = 0
  var isoutput : Int32 = 0
  var ignore_readdir_race : Int32 = 0

  struct CommandOptions {
    var issort : Int32 = 0
    var isxargs : Int32 = 0
    var args : ArraySlice<String> = []
  }
  
  var unix2003_compat = true
  
  // from find.swift
  var tree: UnsafeMutablePointer<FTS>?      /* pointer to top of FTS hierarchy */
  
  // from function.swift
  let FIND_SIZE : Int64 = 512
  var divsize = 1
  var curdev = Darwin.dev_t()  /* need a guaranteed illegal dev value */
  var first = true
  var lastexecplus : [PLAN] = []


  // from option.swift
  var options : [String : OPTION] = [:]
  var p = [String]()

  required init() {
    options = initOptions()
  }
  
  func parseOptions() throws(CmdErr) -> CommandOptions {
    var opts = CommandOptions()
    var Hflag, Lflag : Bool

    // FIXME: setlocale seems to be missing in Swift 6.2
    // Darwin.setlocale(LC_ALL, "")
    
    Darwin.time(&now) /* initialize the time-of-day */
    
#if os(macOS) || os(iOS) || os(tvOS) || os(watchOS) || os(visionOS)
    unix2003_compat = true // COMPAT_MODE("bin/find", "unix2003")
#endif
    
    //    p = start = CommandLine.arguments
    Hflag = false
    Lflag = false
    
    var ftsoptions = Darwin.FTS_NOSTAT | Darwin.FTS_PHYSICAL
    
    let go = BSDGetopt("EHLPXdf:sx")
    while let (ch, optarg) = try go.getopt() {
      
      switch (ch) {
      case "E":
          regexp_flags |= Darwin.REG_EXTENDED
      case "H":
          Hflag = true
          Lflag = false
      case "L":
          Lflag = true
          Hflag = false
      case "P":
        Hflag = false
          Lflag = false
      case "X":
          opts.isxargs = 1
      case "d":
          isdepth = 1
      case "f":
        p.append( optarg )
      case "s":
          opts.issort = 1
      case "x":
          ftsoptions |= Darwin.FTS_XDEV
      case "?":
        fallthrough
      default:
        throw CmdErr(1)
      }
    }
    
    opts.args = ArraySlice(go.remaining)
    
    if (Hflag) {
      ftsoptions |= Darwin.FTS_COMFOLLOW
    }
    if (Lflag) {
      ftsoptions &= ~Darwin.FTS_PHYSICAL
      ftsoptions |= Darwin.FTS_LOGICAL
    }
    
    /*
     * Find first option to delimit the file list.  The first argument
     * that starts with a -, or is a ! or a ( must be interpreted as a
     * part of the find expression, according to POSIX .2.
     */
    
    var fl = opts.args
    
    while !fl.isEmpty {
      let arg = fl.first!
      if arg.hasPrefix("-") {
        break
      }
      if (arg.hasPrefix("!") || arg.hasPrefix("(") ) && arg.count == 1 {
        break
      }
      p.append(arg)
      fl.removeFirst()
    }
    
    if p.isEmpty {
      throw CmdErr(1)
    }
    
    opts.args = fl
    return opts
  }
    
  func runCommand(_ optsx : CommandOptions) throws(CmdErr) {
    var opts = optsx
    // ???
    let dotfd = open(".", O_RDONLY | O_CLOEXEC, 0)
    if dotfd < 0 {
      ftsoptions |= Darwin.FTS_NOCHDIR
    }
    
#if os(macOS) || os(iOS) || os(tvOS) || os(watchOS) || os(visionOS)
//    var gg = p.map { $0.withCString { strdup($0)} }
    
    let ch = 
//    gg.withUnsafeMutableBfufferPointer { pp in
    find_execute(plan: find_formplan( &opts.args, opts ), paths: p, options: opts)
//    }
    if ferror(stdout) != 0 || fflush(stdout) != 0 {
      err(1, "stdout")
    }
    if ch != 0 {
      throw CmdErr(Int(ch))
    }
#else
    exit(find_execute(find_formplan(CommandLine.arguments), start))
#endif
  }
  
  var usage = """
usage: find [-H | -L | -P] [-EXdsx] [-f path] path ... [expression]
       find [-H | -L | -P] [-EXdsx] -f path [path ...] [expression]
"""
}

