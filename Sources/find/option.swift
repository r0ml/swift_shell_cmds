
// Generated by Robert M. Lefkowitz <r0ml@liberally.net> in 2024 using ChatGPT
// from a file containing the following notice:

/*
 * SPDX-License-Identifier: BSD-3-Clause
 *
 * Copyright (c) 1990, 1993, 1994
 *  The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Cimarron D. Taylor of the University of California, Berkeley.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

typealias creat_f = (_ a : OPTION, _ b :inout ArraySlice<String>) -> PLAN
typealias exec_f = ( _ a : PLAN, _ b : MyFTSENT ) -> Bool

struct OPTION {
  var name : String  /* option name */
  var create : creat_f  /* create function */
  var execute : exec_f?  /* execute function */
  var flags : Int32
  
  init(_ a : String, _ b : @escaping creat_f, _ c: exec_f?, _ d : Int32) {
    name = a
    create = b
    execute = c
    flags = d
  }
}


/* function modifiers */
let F_NEEDOK   : Int32 = 0x00000001  /* -ok vs. -exec */
let F_EXECDIR  : Int32 = 0x00000002  /* -execdir vs. -exec */
let F_TIME_A   : Int32 = 0x00000004  /* one of -atime, -anewer, -newera* */
let F_TIME_C   : Int32 = 0x00000008  /* one of -ctime, -cnewer, -newerc* */
let  F_TIME2_A : Int32 =   0x00000010  /* one of -newer?a */
let  F_TIME2_C : Int32 =   0x00000020  /* one of -newer?c */
let  F_TIME2_T : Int32 =   0x00000040  /* one of -newer?t */
let F_MAXDEPTH : Int32 =   F_TIME_A  /* maxdepth vs. mindepth */
let F_DEPTH    : Int32 =  F_TIME_A  /* -depth n vs. -d */
/* command line function modifiers */
let F_EQUAL     : Int32 = 0x00000000  /* [acm]min [acm]time inum links size */
let F_LESSTHAN  : Int32 =  0x00000100
let F_GREATER   : Int32 = 0x00000200
let F_ELG_MASK  : Int32 = 0x00000300
let F_ATLEAST   : Int32 = 0x00000400  /* flags perm */
let F_ANY       : Int32 = 0x00000800  /* perm */
let F_MTMASK    : Int32 = 0x00003000
let F_MTFLAG    : Int32 = 0x00000000  /* fstype */
let F_MTTYPE    : Int32 = 0x00001000
let F_MTUNKNOWN : Int32 = 0x00002000
let F_IGNCASE   : Int32 = 0x00010000  /* iname ipath iregex */
let F_EXACTTIME : Int32 = F_IGNCASE  /* -[acm]time units syntax */
let F_EXECPLUS  : Int32 = 0x00020000  /* -exec ... {} + */


let F_TIME_B : Int32 = 0x00040000  /* one of -Btime, -Bnewer, -newerB* */
let F_TIME2_B : Int32 =  0x00080000  /* one of -newer?B */


let F_LINK  : Int32    = 0x00100000  /* lname or ilname */








// NB: the following table must be sorted lexically.
// Options listed with C++ comments are in gnu find, but not our find


extension find {
  func initOptions() -> [String : OPTION] {
    let _options : [OPTION] = [
      OPTION("!",  c_simple,  f_not,    0 ),
      OPTION("(",    c_simple,  f_openparen,  0 ),
      OPTION(")",    c_simple,  f_closeparen,  0 ),
      // FIXME:
      // #if HAVE_STRUCT_STAT_ST_BIRTHTIME
      OPTION( "-Bmin",  c_Xmin,    f_Xmin,    F_TIME_B ),
      OPTION( "-Bnewer",  c_newer,  f_newer,  F_TIME_B ),
      OPTION( "-Btime",  c_Xtime,  f_Xtime,  F_TIME_B ),
      // #endif
      
      // FIXME: took this out because of that nil
      //    OPTION( "-a",    c_and,    nil,    0 ),
      // FIXME: ??
      // #if defined(__APPLE__) || defined(ACL_TYPE_NFS4)
      OPTION( "-acl",  c_acl,    f_acl,    0 ),
      // #endif
      OPTION( "-amin",  c_Xmin,    f_Xmin,    F_TIME_A ),
      // FIXME: that nasty nil
      //   OPTION( "-and",  c_and,    nil,    0 ),
      OPTION( "-anewer",  c_newer,  f_newer,  F_TIME_A ),
      OPTION( "-atime",  c_Xtime,  f_Xtime,  F_TIME_A ),
      OPTION( "-cmin",  c_Xmin,    f_Xmin,    F_TIME_C ),
      OPTION( "-cnewer",  c_newer,  f_newer,  F_TIME_C ),
      OPTION( "-ctime",  c_Xtime,  f_Xtime,  F_TIME_C ),
      OPTION( "-d",    c_depth,  f_depth,  0 ),
      // -daystart
      OPTION( "-delete",  c_delete,  f_delete,  0 ),
      OPTION( "-depth",  c_depth,  f_depth,  0 ),
      OPTION( "-empty",  c_empty,  f_empty,  0 ),

      OPTION( "-exec",  c_exec,    f_exec,    0 ),
      OPTION( "-execdir",  c_exec,    f_exec,    F_EXECDIR ),

      OPTION( "-false",  c_simple,  f_false,  0 ),
      
      // FIXME: ??
      // #if HAVE_STRUCT_STAT_ST_FLAGS
      OPTION( "-flags",  c_flags,  f_flags,  0 ),
      // #endif
      // -fls
      OPTION( "-follow",  c_follow,  f_always_true,  0 ),
      // -fprint
      // -fprint0
      // -fprintf
      
      // FIXME: ??
      // #if HAVE_STRUCT_STATFS_F_FSTYPENAME
      OPTION( "-fstype",  c_fstype,  f_fstype,  0 ),
      // #endif
      OPTION( "-gid",  c_group,  f_group,  0 ),
      OPTION( "-group",  c_group,  f_group,  0 ),
      OPTION( "-ignore_readdir_race",c_ignore_readdir_race, f_always_true,0 ),
      OPTION( "-ilname",  c_name,    f_name,    F_LINK | F_IGNCASE ),
      OPTION( "-iname",  c_name,    f_name,    F_IGNCASE ),
      OPTION( "-inum",  c_inum,    f_inum,    0 ),
      OPTION( "-ipath",  c_name,    f_path,    F_IGNCASE ),
      OPTION( "-iregex",  c_regex,  f_regex,  F_IGNCASE ),
      OPTION( "-iwholename",c_name,    f_path,    F_IGNCASE ),
      OPTION( "-links",  c_links,  f_links,  0 ),
      OPTION( "-lname",  c_name,    f_name,    F_LINK ),
      OPTION( "-ls",  c_ls,    f_ls,    0 ),
      OPTION( "-maxdepth",  c_mXXdepth,  f_always_true,  F_MAXDEPTH ),
      OPTION( "-mindepth",  c_mXXdepth,  f_always_true,  0 ),
      OPTION( "-mmin",  c_Xmin,    f_Xmin,    0 ),
      OPTION( "-mnewer",  c_newer,  f_newer,  0 ),
      OPTION( "-mount",  c_xdev,    f_always_true,  0 ),
      OPTION( "-mtime",  c_Xtime,  f_Xtime,  0 ),
      OPTION( "-name",  c_name,    f_name,    0 ),
      OPTION( "-newer",  c_newer,  f_newer,  0 ),
      
      // FIXME: ??
      //  #if HAVE_STRUCT_STAT_ST_BIRTHTIME
      OPTION( "-newerBB",  c_newer,  f_newer,  F_TIME_B | F_TIME2_B ),
      OPTION( "-newerBa",  c_newer,  f_newer,  F_TIME_B | F_TIME2_A ),
      OPTION( "-newerBc",  c_newer,  f_newer,  F_TIME_B | F_TIME2_C ),
      OPTION( "-newerBm",  c_newer,  f_newer,  F_TIME_B ),
      OPTION( "-newerBt",  c_newer,  f_newer,  F_TIME_B | F_TIME2_T ),
      OPTION( "-neweraB",  c_newer,  f_newer,  F_TIME_A | F_TIME2_B ),
      // #endif
      OPTION( "-neweraa",  c_newer,  f_newer,  F_TIME_A | F_TIME2_A ),
      OPTION( "-newerac",  c_newer,  f_newer,  F_TIME_A | F_TIME2_C ),
      OPTION( "-neweram",  c_newer,  f_newer,  F_TIME_A ),
      OPTION( "-newerat",  c_newer,  f_newer,  F_TIME_A | F_TIME2_T ),
      
      // FIXME:
      // #if HAVE_STRUCT_STAT_ST_BIRTHTIME
      OPTION( "-newercB",  c_newer,  f_newer,  F_TIME_C | F_TIME2_B ),
      // #endif
      OPTION( "-newerca",  c_newer,  f_newer,  F_TIME_C | F_TIME2_A ),
      OPTION( "-newercc",  c_newer,  f_newer,  F_TIME_C | F_TIME2_C ),
      OPTION( "-newercm",  c_newer,  f_newer,  F_TIME_C ),
      OPTION( "-newerct",  c_newer,  f_newer,  F_TIME_C | F_TIME2_T ),
      // FIXME:
      // #if HAVE_STRUCT_STAT_ST_BIRTHTIME
      OPTION( "-newermB",  c_newer,  f_newer,  F_TIME2_B ),
      // #endif
      OPTION( "-newerma",  c_newer,  f_newer,  F_TIME2_A ),
      OPTION( "-newermc",  c_newer,  f_newer,  F_TIME2_C ),
      OPTION( "-newermm",  c_newer,  f_newer,  0 ),
      OPTION( "-newermt",  c_newer,  f_newer,  F_TIME2_T ),
      OPTION( "-nogroup",  c_nogroup,  f_nogroup,  0 ),
      OPTION( "-noignore_readdir_race",c_ignore_readdir_race, f_always_true,0 ),
      OPTION( "-noleaf",  c_simple,  f_always_true,  0 ),
      OPTION( "-not",  c_simple,  f_not,    0 ),
      OPTION( "-nouser",  c_nouser,  f_nouser,  0 ),
      OPTION( "-o",    c_simple,  f_or,    0 ),
      
      OPTION( "-ok",  c_exec,    f_exec,    F_NEEDOK ),
      OPTION( "-okdir",  c_exec,    f_exec,    F_NEEDOK | F_EXECDIR ),
      
      OPTION( "-or",  c_simple,  f_or,    0 ),
      OPTION( "-path",   c_name,    f_path,    0 ),
      OPTION( "-perm",  c_perm,    f_perm,    0 ),
      OPTION( "-print",  c_print,  f_print,  0 ),
      OPTION( "-print0",  c_print,  f_print0,  0 ),
      // -printf
      OPTION( "-prune",  c_simple,  f_prune,  0 ),
      OPTION( "-quit",  c_simple,  f_quit,    0 ),
      OPTION( "-regex",  c_regex,  f_regex,  0 ),
      OPTION( "-samefile",  c_samefile,  f_inum,    0 ),
      OPTION( "-size",  c_size,    f_size,    0 ),
      OPTION( "-sparse",  c_sparse,  f_sparse,  0 ),
      OPTION( "-true",  c_simple,  f_always_true,  0 ),
      OPTION( "-type",  c_type,    f_type,    0 ),
      OPTION( "-uid",  c_user,    f_user,    0 ),
      OPTION( "-user",  c_user,    f_user,    0 ),
      OPTION( "-wholename",  c_name,    f_path,    0 ),
      
      // FIXME:
      //  #if os(macOS) || os(iOS) || os(tvOS) || os(watchOS) || os(visionOS)
      OPTION( "-xattr",  c_simple,  f_xattr,  0 ),
      OPTION("-xattrname",  c_name,    f_xattrname,  0 ),
      //  #endif  /* __APPLE__ */
      OPTION( "-xdev",  c_xdev,    f_always_true,  0 )
      // -xtype
    ]
    
    var res = [String:OPTION]()
    for a in _options {
      res[a.name] = a
    }
    return res
  }
  
  
  // find_create --
  // create a node corresponding to a command line argument.
  //
  // TODO:
  // add create/process function pointers to node, so we can skip
  // this switch stuff.
  func find_create(_ argv: inout ArraySlice<String>) -> PLAN {
    
    guard let p = options[argv.first!] else {
      fatalError("\(argv.first ?? ""): unknown primary or operator")
    }
    argv.removeFirst()
    
    let newPlan = p.create(p, &argv)
    return newPlan
  }
}
