
// Generated by Robert M. Lefkowitz <r0ml@liberally.net> in 2024 using ChatGPT
// from a file containing the following notice:

/*
 * SPDX-License-Identifier: BSD-3-Clause
 *
 * Copyright (c) 1989, 1993
 *  The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

import CMigration

let MB_CUR_MAX = 1

extension hexdump {
  func conv_c(pr: inout PR, p: UnsafeRawPointer, bufsize: Int) {
    var str: String?
    
    if sub_conv_c(&pr, p, bufsize, &str) {
      
      //    strpr:
      pr.fmt.replaceSubrange(pr.cchar...pr.cchar, with: "s")
      
      str!.withCString {
        let _ = withVaList([$0]) {
          vprintf(pr.fmt, $0)
        }
      }
      
//      Swift.print(String(format: pr.fmt, str!), terminator: "")
    }
  }
  
  func sub_conv_c(_ pr: inout PR, _ p: UnsafeRawPointer, _ bufsizex: Int, _ str: inout String?) -> Bool {
    
//    var buf = [Character](repeating: "\0", count: 10)
    var bufsize = bufsizex
    
    if pr.mbleft > 0 {
      str = "**"
      pr.mbleft -= 1
      return true
    }
    
    let pp = p.assumingMemoryBound(to: Int8.self).pointee
    switch pp {
    case 0:
      str = "\\0"
      return true
    case 7:
      str = "\\a"
      return true
    case 8:
      str = "\\b"
      return true
    case 12:
      str = "\\f"
      return true
    case 10:
      str = "\\n"
      return true
    case 13:
      str = "\\r"
      return true
    case 9:
      str = "\\t"
      return true
    case 11:
      str = "\\v"
      return true
    default:
      break
    }
    
    var converr = false
    
    var wc: wchar_t = 0
    //  var clen: Int = 0, oclen: Int = 0
    //  var pad: Int = 0, width: Int = 0
    var clen = 0
//    var op: UnsafeMutablePointer<UInt8>? = nil
    
    
    converr = false
    // FIXME: zapped this -- only for wide chars (which is not supported?)
    
    if false && odmode && MB_CUR_MAX > 1 {
      /*
      var oclen = 0
      
      retry: while true {
        clen = mbrtowc(&wc, p, bufsize, &pr.mbstate)
        if clen == 0 {
          clen = 1
          break
        } else if clen == -1 || (clen == -2 && p == peekbuf) {
          memset(&pr.mbstate, 0, MemoryLayout.size(ofValue: pr.mbstate))
          if p == peekbuf {
            oclen = 0
            p = op
          }
          wc = wchar_t(p.pointee)
          clen = 1
          converr = true
          break
        } else if clen == -2 {
          oclen = bufsize
          op = p
          bufsize = peek(p: &peekbuf, MB_CUR_MAX)
          continue retry
        }
      }
      clen += oclen
       */
    } else {
      wc = wchar_t(pp)
      clen = 1
    }
    
    if !converr && iswprint(wc) != 0 {
      if !odmode {
        pr.fmt.replaceSubrange(pr.cchar...pr.cchar, with: "c")
        Swift.print(cFormat(pr.fmt, UInt8(wc) ), terminator: "")
      } else {
        pr.fmt.replaceSubrange(pr.cchar...pr.cchar, with: "C")
        assert(pr.fmt == "%3C")
        let width = Int(wcwidth(wc))
        assert(width >= 0)
        let pad = max(3 - width, 0)
        Swift.print("".withCString { cFormat("%*s%C", pad, $0, wc) } , terminator: "")
        pr.mbleft = clen - 1
      }
      return false
    } else {
      str = cFormat("%03o", pp)
      return true
    }
  }
  
  func conv_u(pr: inout PR, bp p: UInt8) {
    let list = ["nul", "soh", "stx", "etx", "eot", "enq", "ack", "bel",
                "bs",  "ht",  "lf",  "vt",  "ff",  "cr",  "so",  "si",
                "dle", "dc1", "dc2", "dc3", "dc4", "nak", "syn", "etb",
                "can",  "em", "sub", "esc",  "fs",  "gs",  "rs",  "us"]
    
    if p <= 0x1f {
      pr.fmt.replaceSubrange(pr.cchar...pr.cchar, with: "s")
      if odmode && p == 0x0a {
        Swift.print(cFormat(pr.fmt, "nl"), terminator: "")
      } else {
        Swift.print(cFormat(pr.fmt, list[Int(p)]), terminator: "")
      }
    } else if p == 0x7f {
      pr.fmt.replaceSubrange(pr.cchar...pr.cchar, with: "s")
      Swift.print(cFormat(pr.fmt, "del"), terminator: "")
    } else if odmode && p == 0x20 {
      pr.fmt.replaceSubrange(pr.cchar...pr.cchar, with: "s")
      Swift.print(cFormat(pr.fmt, " sp"), terminator: "")
    } else if isprint(Int32(p)) != 0 {
      pr.fmt.replaceSubrange(pr.cchar...pr.cchar, with: "c")
      Swift.print(cFormat(pr.fmt, p), terminator: "")
    } else {
      pr.fmt.replaceSubrange(pr.cchar...pr.cchar, with: "x")
      Swift.print(cFormat(pr.fmt, Int(p)), terminator: "")
    }
  }
}
