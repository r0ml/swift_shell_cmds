
// Generated by Robert M. Lefkowitz <r0ml@liberally.net> in 2024 using ChatGPT
// from a file containing the following notice:

/*
 * SPDX-License-Identifier: BSD-3-Clause
 *
 * Copyright (c) 1989, 1993
 *  The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

import CMigration
import SystemPackage

import Darwin

    extension hexdump {

    
        
      func display(_ opts : inout CommandOptions) throws(CmdErr) {
            //    var fs: FS?
            //    var fu: FU?
            //    var pr: PR?
            //    var cnt: Int
            //    var bp: u_char?
            //    var saveaddress: off_t
            //    var savech: u_char, savebp: u_char?
            
            //    var savech = 0
            while var bp = try get(&opts) {
                let savebp = bp
                let saveaddress = address
                for fs in fsArray {
                    //      for (fs = fshead, savebp = bp, saveaddress = address; fs != nil;
                    //           fs = fs?.nextfs, bp = savebp, address = saveaddress) {
                    for fu in fs.fuArray {
                        if (fu.flags == .F_IGNORE) {
                            break
                        }
                        for cnt in stride(from: fu.reps, through: 1, by: -1) { //}   (cnt = fu.reps; cnt > 0; cnt -= 1) {
                            //            for (pr = fu?.nextpr; pr != nil; address += pr?.bcnt,
                            //                 bp += pr?.bcnt, pr = pr?.nextpr) {
                            for var pr in fu.prArray {
                                if (eaddress != 0 && address >= eaddress &&
                                    !(pr.flags == .F_TEXT || pr.flags == .F_BPAD) ) {
                                    bpad(pr: &pr)
                                }
                                
                                
                                var fmt = pr.fmt!
                                if (cnt == 1 && pr.nospace) {
                                    fmt = String( pr.fmt.dropLast() )
                                }
                                print(fmt: fmt, pr: &pr, bp: bp)
                                //              if (cnt == 1 && pr.nospace != nil) {
                                //                pr.nospace = savech
                                //              }
                                
                                address += Int64(pr.bcnt)
                                bp = String(bp.dropFirst(pr.bcnt))
                            }
                        }
                    }
                    bp = savebp
                    address = saveaddress
                }
            }
            if (endfu != nil) {
                if (eaddress == 0) {
                    if (address == 0) {
                        return
                    }
                    eaddress = address
                }
                for pr in endfu?.prArray ?? [] {
                    switch(pr.flags) {
                    case .F_ADDRESS:
                        let _  = withVaList([quad_t(eaddress)]) { vprintf(pr.fmt, $0) }
                    case .F_TEXT:
                        Swift.print(pr.fmt!, terminator: "")
                    default:
                        break
                    }
                }
            }
        }
        
        func print(fmt: String, pr: inout PR, bp: UnsafeRawPointer) {
            //    var ldbl: long double
            //    var f8: Double
            //    var f4: Float
            //    var s2: Int16
            //    var s8: Int8
            //    var s4: Int32
            // var u2: UInt16
            //    var u4: UInt32
            //    var u8: UInt64
            // var blocksize: Int64 = 0        /* data block size */
            
            switch(pr.flags) {
            case .F_ADDRESS:
                let _ = withVaList([address as quad_t]) { vprintf(fmt, $0) }
            case .F_BPAD:
                "".withCString {
                    let _ = withVaList([$0]) { vprintf(fmt, $0 ) }
                }
            case .F_C:
                conv_c(pr: &pr, p: bp, bufsize: Int(eaddress != 0 ? eaddress - address :
                                                        Int64(blocksize) - address % Int64(blocksize)))
            case .F_CHAR:
                let _ = withVaList([bp.assumingMemoryBound(to: CChar.self).pointee]) { vprintf(fmt, $0) }
            case .F_DBL:
                switch(pr.bcnt) {
                case 4:
                    var f4 : Float = 0
                    bcopy(bp, &f4, MemoryLayout.size(ofValue: f4))
                    let _ = withVaList([f4]) { vprintf(fmt, $0) }
                case 8:
                    var f8 : Double = 0
                    bcopy(bp, &f8, MemoryLayout.size(ofValue: f8))
                    let _ = withVaList([f8]) { vprintf(fmt, $0) }
                default:
                    // FIXME: there is no such thing as long double
                    /*        if (pr.bcnt == sizeof(long double)) {
                     bcopy(bp, &ldbl, MemoryLayout.size(ofValue: ldbl))
                     let _ = withVaList([ldbl]) { vprintf(fmt, $0) }
                     }
                     */
                    break
                }
            case .F_INT:
                switch(pr.bcnt) {
                case 1:
                    let b = bp.assumingMemoryBound(to: Int8.self).pointee
                    let _ = withVaList([quad_t(b)]) { vprintf(fmt, $0) }
                case 2:
                    var s2 : Int16 = 0
                    bcopy(bp, &s2, MemoryLayout.size(ofValue: s2))
                    let _ = withVaList([quad_t(s2)]) { vprintf(fmt, $0) }
                case 4:
                    var s4 : Int32 = 0
                    bcopy(bp, &s4, MemoryLayout.size(ofValue: s4))
                    let _ = withVaList([quad_t(s4)]) { vprintf(fmt, $0) }
                case 8:
                    var s8 : Int64 = 0
                    bcopy(bp, &s8, MemoryLayout.size(ofValue: s8))
                    let _ = withVaList([s8]) { vprintf(fmt, $0) }
                default:
                    fatalError("F_INT bcnt value not possible")
                }
            case .F_P:
                let r = bp.assumingMemoryBound(to: CUnsignedChar.self).pointee
                let rx : CUnsignedChar = (isprint(Int32(r) ) != 0 && isascii(Int32(r)) != 0) ? r : Character(".").asciiValue!
                let _ = withVaList([rx]) { vprintf(fmt, $0) }
            case .F_STR:
                let _ = withVaList( [bp.assumingMemoryBound(to: CChar.self)]) { vprintf(fmt, $0) }
            case .F_TEXT:
                Swift.print(fmt, terminator: "")
            case .F_U:
                conv_u(pr: &pr, bp: bp.assumingMemoryBound(to: CUnsignedChar.self).pointee)
            case .F_UINT:
                switch(pr.bcnt) {
                case 1:
                    let u1 = bp.assumingMemoryBound(to: UInt8.self).pointee
                    let _ = withVaList([u_quad_t(u1)]) { vprintf(fmt, $0) }
                case 2:
                    var u2 : UInt16 = 0
                    bcopy(bp, &u2, MemoryLayout.size(ofValue: u2))
                    let _ = withVaList([u_quad_t(u2)]) { vprintf(fmt, $0) }
                case 4:
                    var u4 : UInt32 = 0
                    bcopy(bp, &u4, MemoryLayout.size(ofValue: u4))
                    let _ = withVaList([u_quad_t(u4)]) { vprintf(fmt, $0 ) }
                case 8:
                    var u8 : UInt64 = 0
                    bcopy(bp, &u8, MemoryLayout.size(ofValue: u8))
                    let _ = withVaList([u8]) { vprintf(fmt, $0) }
                default:
                    fatalError("printing unsigned integer of unknown size not possible")
                }
            default:
                fatalError("print unknown type not possible")
            }
        }
        
        /*
         * Remove all conversion flags; '-' is the only one valid
         * with %s, and it's not useful here.
         */
        func bpad(pr: inout PR) {
            let bspec = " -0+#"
            
            pr.flags = .F_BPAD
            pr.fmt.replaceSubrange(pr.cchar...pr.cchar, with: "s")
            pr.fmt = String(pr.fmt.prefix(through: pr.cchar))
            var p1 = Substring(pr.fmt)
            var p3 = p1.prefix { $0 != "%" }
            p3.append("%")
            
            p1 = p1.dropFirst(p3.count)
            p1 = p1.trimmingPrefix { bspec.contains($0) }
            p3.append(contentsOf: p1)
            pr.fmt = String(p3)
        }
        
      func get(_ opts : inout CommandOptions) throws(CmdErr) -> String? {
            var n: Int
            //    var need: Int, nread: Int
            var valid_save = false
            //    var tmpp: u_char?
            
            
            if curp == nil {
                curp = calloc(1, blocksize)
                savp = calloc(1, blocksize)
            } else {
                swap(&curp, &savp)
                //      tmpp = curp
                //      curp = savp
                //      savp = tmpp
                address += off_t(blocksize)
                valid_save = true
            }
            var need = blocksize
            var nread = 0
            while true {
              let nn = try next(&opts)
                if (length == 0) || (ateof && !nn) {
                    if odmode && address < skip {
                        errx(1, "cannot skip past end of input")
                    }
                    if need == blocksize {
                        return nil
                    }
                  if (need == 0) && opts.vflag != .ALL && valid_save && bcmp(curp, savp, nread) == 0 {
                      if opts.vflag != .DUP {
                            Swift.print("*")
                        }
                        return nil
                    }
                    bzero(curp!.advanced(by: nread), need)
                    eaddress = address + Int64(nread)
                  let k = curp!.bindMemory(to: UInt8.self, capacity: nread)
                  let j = UnsafeBufferPointer(start:k, count: nread)
                  return String(decoding: j, as: Unicode.ASCII.self)
                }
                n = fread(curp!.advanced(by: nread), 1 /* was sizeof(u_char) */,
                          length == -1 ? need : min(length, need), stdin)
                if n == 0 {
                    if (ferror(stdin) != 0) {
                        warn(lastFile ?? "(none)")
                    }
                    ateof = true
                    continue
                }
                ateof = false
                if length != -1 {
                    length -= n
                }
                need -= n
                if need == 0 {
                  if opts.vflag == .ALL || opts.vflag == .FIRST || !valid_save || bcmp(curp, savp, blocksize) != 0 {
                    if opts.vflag == .DUP || opts.vflag == .FIRST {
                      opts.vflag = .WAIT
                        }
                    let k = curp!.bindMemory(to: UInt8.self, capacity: blocksize)
                    let j = UnsafeBufferPointer(start:k, count: blocksize)
                    return String(decoding: j, as: Unicode.ASCII.self)
                    }
                  if opts.vflag == .WAIT {
                        Swift.print("*")
                    }
                  opts.vflag = .DUP
                    address += Int64(blocksize)
                    need = blocksize
                    nread = 0
                } else {
                    nread += n
                }
            }
        }
        
        
        // FIXME: Only used for multibyte mode
        /*
         func peek(buf: inout UnsafePointer<u_char>, nbytes: size_t) -> size_t {
         var n: size_t, nread: size_t
         var c: Int
         
         if length != -1 && nbytes > (unsigned int)length {
         nbytes = length
         }
         nread = 0
         while nread < nbytes && (c = getchar()) != EOF {
         buf++ = c
         nread++
         }
         n = nread
         while n-- > 0 {
         c = *--buf
         ungetc(c, stdin)
         }
         return nread
         }
         */
        
        // start reading the next file (argument)
        // if no arguments, read from stdin
        // skip arguments for files which can't be read
      func next(_ opts: inout CommandOptions) throws(CmdErr) -> Bool {
            var statok = false
            
            while true {
              if let aa = opts.args.first {
                    didStdin = true
                    if ((freopen(aa, "r", stdin)) == nil) {
                        throw CmdErr(1, aa)
                      opts.args = opts.args.dropFirst()
                        continue
                    }
                    statok = true
                } else {
                    if didStdin {
                        return false
                    }
                    didStdin = true
                    statok = false
                }
                
                if (skip != 0) {
                  let lf = statok ? opts.args.first! : "stdin"
                    lastFile = lf
                    doskip(fname: lf, statok: statok)
                }
              opts.args = opts.args.dropFirst()
                if (skip == 0) {
                    return true
                }
            }
        }
        
        func doskip(fname: String, statok: Bool) {
            var type: Int = 0
            var sb = stat()
            
            if statok {
                if (fstat(fileno(stdin), &sb) != 0) {
                    err(1, fname)
                }
                //      if S_ISREG(sb.st_mode) && skip > sb.st_size {
                if (sb.st_mode & S_IFMT) == S_IFREG && skip > sb.st_size {
                    address += sb.st_size
                    skip -= sb.st_size
                    return
                }
            }
            if !statok ||
                //        S_ISFIFO(sb.st_mode) ||
                (sb.st_mode & S_IFMT == S_IFIFO) ||
                (sb.st_mode & S_IFMT == S_IFSOCK) {
                noseek()
                return
            }
            
            let FIODTYPE = _IOR("f", 122, CInt.self)
            
            if (sb.st_mode & S_IFMT) == S_IFCHR ||
                (sb.st_mode & S_IFMT) == S_IFBLK {
                if (ioctl(fileno(stdin), UInt(FIODTYPE), &type) != 0) {
                    err(1, fname)
                }
                if ((Int32(type) & D_TAPE) != 0) {
                    noseek()
                    return
                }
            }
            if (fseeko(stdin, skip, SEEK_SET) != 0) {
                noseek()
                return
            }
            address += skip
            skip = 0
        }
        
        func noseek() {
            var nc : off_t = 0
            for count in 0..<skip {
                if getchar() == EOF {
                    nc = count
                    break
                }
            }
            address += nc
            skip -= nc
        }
        
    }
    
    func _IOR<T>(_ g : Character, _ n : UInt32, _ t : T.Type) -> UInt32 {
        return _IOC(IOC_OUT, UInt32(g.asciiValue!), n,  MemoryLayout<T>.size)
    }
    
    func _IOC(_ ino : UInt32, _ group : UInt32, _ num : UInt32, _ len : Int) -> UInt32 {
        return (ino | ((UInt32(len) & UInt32(IOCPARM_MASK)) << 16) | ((group) << 8) | (num))
    }

