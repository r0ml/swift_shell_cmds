
// Generated by Robert M. Lefkowitz <r0ml@liberally.net> in 2024 using ChatGPT
// from a file containing the following notice:

/*
 * SPDX-License-Identifier: BSD-3-Clause
 *
 * Copyright (c) 1989, 1993
 *  The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

import CMigration

/*
struct prOptions : OptionSet {
  let rawValue: UInt8

  static let F_ADDRESS = prOptions(rawValue: 0x001)
  static let F_BPAD = prOptions(rawValue: 0x002)
  static let F_C = prOptions(rawValue: 0x004)
  static let F_CHAR = prOptions(rawValue: 0x008)
  static let F_DBL = prOptions(rawValue: 0x010)
  static let F_INT = prOptions(rawValue: 0x020)
  static let F_P = prOptions(rawValue: 0x040)
  static let F_STR = prOptions(rawValue: 0x080)
  static let F_U = prOptions(rawValue: 0x100)
  static let F_UINT = prOptions(rawValue: 0x200)
  static let F_TEXT = prOptions(rawValue: 0x400)

}
*/

enum prOptions  {
  case F_UNSET
  case F_ADDRESS
  case F_BPAD
  case F_C
  case F_CHAR
  case F_DBL
  case F_INT
  case F_P
  case F_STR
  case F_U
  case F_UINT
  case F_TEXT
}

class PR {
//    var nextpr: UnsafeMutablePointer<PR>?
  var flags: prOptions = .F_UNSET
    var bcnt: Int = 0
  var cchar: String.Index!
    var fmt: String!
  var nospace: Bool = false
    var mbleft: Int = 0
    var mbstate: mbstate_t?
}

struct fuOptions : OptionSet {
  let rawValue : UInt8
  
  static let F_IGNORE = fuOptions(rawValue: 0x01)
  static let F_SETREP = fuOptions(rawValue: 0x02)
  
  static let all : fuOptions = [.F_IGNORE, .F_SETREP]
}

// format unit
class FU {
//    var nextfu: UnsafeMutablePointer<FU>?
//    var nextpr: UnsafeMutablePointer<PR>?
  var prArray : [PR] = []
    var flags: fuOptions = []
    var reps: Int = 0
    var bcnt: Int = 0
    var fmt: String
  
  init(fmt: String) {
    self.fmt = fmt
  }
}

// Format specification
class FS {
//    var nextfs: UnsafeMutablePointer<FS>?
  var fmt : String // for debugging
  // format Units
  var fuArray : [FU] = []
  var bcnt: Int = 0
  
  // Added this for debugging -- retains the format string used
  // to create this format specification
  init(fmt: String) {
    self.fmt = fmt
  }
}

// #if SWIFTMAIN
@main
//  #endif

final class hexdump : ShellCommand {
    
    var odmode: Bool = false
    var endfu: FU? // format at end-of-data

    // from display.swift
    enum _vflag {
        case ALL
        case DUP
        case FIRST
        case WAIT
    }
    

    var address: off_t = 0
    var eaddress: off_t = 0
    // var _argv: [String]
    

// ==================
    
    
//  var exitval: Int32 = 0        /* final exit value */

  // options
  var skip : off_t = 0
  
  struct CommandOptions {
    var vflag : _vflag = .FIRST
    var args :  Array<String>.SubSequence = []
  }
  
  // Format specifications
  var fsArray: [FS] = []        /* head of format strings */

  var blocksize = 0

  var needpad = false

  var didStdin = false
  
  var lastFile : String?
 
  var length : Int = -1 // from -n option
  
  // For get() -- originally declared as static variables in the function
  var ateof = true
  var curp: UnsafeMutableRawPointer?
  var savp: UnsafeMutableRawPointer?
  

  
  func parseOptions() throws(CmdErr) -> CommandOptions {
    //    var p: String?
    var opts = CommandOptions()
    
    _ = setlocale(LC_ALL, "")
    
    let av = CommandLine.arguments[0]
    if let p = av.lastIndex(of: "o"), av[p...] != "od" {
      do {
        try newsyntax(&opts)
      } catch let e as CmdErr {
        throw e
      } catch(let e) {
        err(1, String(describing: e))
      }
    } else {
      try oldsyntax(&opts)
    }
    
    /* figure out the data block size */
    for t in fsArray {
      t.bcnt = size(fs: t)
      if blocksize < t.bcnt {
        blocksize = t.bcnt
      }
    }
    /* rewrite the rules, do syntax checking */
    for t in fsArray {
      rewrite(fs: t)
    }
    return opts
  }
  
  func runCommand(_ optsx : CommandOptions) throws(CmdErr) {
    /*
     * Cache NLS data, for strerror, for err(3), before entering capability
     * mode.
     */
    
    var opts = optsx
    
#if !os(macOS)
    caph_cache_catpages()
    if caph_limit_stdio() < 0 {
      err(1, "capsicum")
    }
#endif
    
    try display(&opts)
#if os(macOS)
    if ferror(stdout) != 0 || fflush(stdout) != 0 {
      throw CmdErr(1, "stdout")
    }
#endif
  }
  
  var newUsage = """
usage: hexdump [-bcCdovx] [-e fmt] [-f fmt_file] [-n length]
              [-s skip] [file ...]
      hd      [-bcdovx]  [-e fmt] [-f fmt_file] [-n length]
              [-s skip] [file ...]
"""

  var odusage = """
usage: od [-aBbcDdeFfHhIiLlOosvXx] [-A base] [-j skip] [-N length] [-t type]
          [[+]offset[.][Bb]] [file ...]"
"""

  var usage : String { get { isNewSyntax ? newUsage : odusage }}

  var isNewSyntax : Bool { get {
    let av = CommandLine.arguments[0]
    return !av.hasSuffix("od")
  }}
}
