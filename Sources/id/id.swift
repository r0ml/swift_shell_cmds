
// Generated by Robert M. Lefkowitz <r0ml@liberally.net> in 2024 using ChatGPT
// from a file containing the following notice:

/*
 * SPDX-License-Identifier: BSD-3-Clause
 *
 * Copyright (c) 1991, 1993
 *  The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

import Foundation
import CMigration

extension UnsafeMutablePointer<passwd> {
  var name : String {
    String(cString: self.pointee.pw_name)
  }
}

extension passwd {
  var name : String {
    String(cString: self.pw_name)
  }
}

extension UnsafeMutablePointer<group> {
  var name : String {
    String(cString: self.pointee.gr_name)
  }
}
// #if os(macOS)
// SPI for 5235093
// int32_t getgrouplist_2(const char *, gid_t, gid_t **);
// #endif


@main final class idCommand : ShellCommand {

  #if os(macOS)
  var optstring = "AFPGagnpru"
  #else
  var optstring = "APGMacgnpru"
  #endif
  
  var isgroups = false
  var iswhoami = false

  struct CommandOptions {
    var flagCount = 0
    
    var args = [String]()
    
#if os(macOS)
    var Gflag = false
    var Pflag = false
    var gflag = false
    var nflag = false
    var pflag = false
    var rflag = false
    var uflag = false
    var Aflag = false
    var Fflag = false
    var id = id_t(0)
    
    let __APPLE__ = true
#else
    var Gflag = 0
    var Mflag = 0
    var Pflag = 0
    var gflag = 0
    var nflag = 0
    var pflag = 0
    var rflag = 0
    var uflag = 0
    var Aflag = 0
    var cflag = 0
    
//    var id = id_t(0)
    var error : Int = 0
    let __APPLE__ = false
#endif
  }
  
  func parseOptions() throws(CmdErr) -> CommandOptions {
    //    let argc = CommandLine.argc
    //    let argv = CommandLine.unsafeArgv
    var opts = CommandOptions()
    
    var myname = CommandLine.arguments[0]
    if let mm = myname.lastIndex(of: "/") {
      myname = String(myname.suffix(from: mm).dropFirst())
    }
    if myname == "groups" {
      isgroups = true
      opts.Gflag = false
      opts.nflag = false
    }
    else if myname == "whoami" {
      iswhoami = true
      opts.uflag = false
      opts.nflag = false
    }
    
    let go = BSDGetopt((isgroups || iswhoami) ? "" : optstring )
    while let (ch, _) = try go.getopt() {
      switch(ch) {
#if USE_BSM_AUDIT
      case "A":
          opts.Aflag = true
#endif
#if os(macOS)
      case "F":
          opts.Fflag = true
#endif
      case "G":
          opts.Gflag = true
#if !os(macOS)
      case "M":
          opts.Mflag = true
#endif
      case "P":
          opts.Pflag = true
      case "a":
        break
#if !os(macOS)
      case "c":
          opts.cflag = true
#endif
      case "g":
          opts.gflag = true
      case "n":
          opts.nflag = true
      case "p":
          opts.pflag = true
      case "r":
          opts.rflag = true
      case "u":
          opts.uflag = true
      case "?":
        fallthrough
      default:
        throw CmdErr(1)
      }
    }
    opts.args = go.remaining
    
    if iswhoami && opts.args.count > 0 {
      throw CmdErr(1)
    }
    
#if os(macOS)
    if opts.Aflag && opts.args.count > 0 {
      throw CmdErr(1)
    }
#else
    if ((cflag != 0 || Aflag != 0 || Mflag != 0) && args.count > 0) {
      usage()
    }
#endif
    
#if os(macOS)
    opts.flagCount = [opts.Aflag, opts.Fflag, opts.Gflag, opts.Pflag, opts.gflag, opts.pflag, opts.uflag].count { $0 }
#else
    flagCount = [Aflag, Gflag, Mflag, Pflag, gflag, pflag, uflag].count { $0 }
#endif
    switch(opts.flagCount) {
    case 1:
      break;
    case 0:
        if (!opts.nflag) && (!opts.rflag) {
        break;
      }
      /* FALLTHROUGH */
    default:
#if DEBUG
      break
#else
      throw CmdErr(1)
#endif
    }
    return opts
  }

  
  func runCommand(_ opts: CommandOptions) throws(CmdErr) {
    let pw = opts.args.isEmpty ? nil : who(opts.args.first!)
    
#if !os(macOS)
    if (opts.Mflag != 0 && pw != nil) {
      throw CmdErr(1)
    }
#endif

  
  forGoto(pw, opts)
    
#if os(macOS)
    if (ferror(stdout) != 0 || fflush(stdout) != 0) {
      err(1, "stdout");
    }
#endif
    exit(0);
  }
  
  func forGoto(_ pwx : passwd?, _ opts : CommandOptions) {
    var pw = pwx
#if USE_BSM_AUDIT
    if opts.Aflag {
      auditid();
#if !DEBUG
      return
#endif
    }
#endif
    
#if os(macOS)
    if opts.Fflag {
      fullname(pw);
#if !DEBUG
      return
#endif
    }
#else
    if opts.cflag {
      error = getloginclass(loginclass, sizeof(loginclass));
      if (error != 0) {
        err(1, "loginclass");
      }
      print(loginclass);
#if !DEBUG
      return
#endif
    }
#endif
    
    if opts.gflag {
      let id = pw != nil ? pw!.pw_gid : (opts.rflag ? getgid() : getegid())
      if opts.nflag {
        let gr = getgrgid(id)
        if let gr {
          print(gr.pointee.gr_name ?? "")
        } else {
          print(id)
        }
      }
      else {
        print(id)
      }
#if !DEBUG
      return
#endif
    }
    
    if opts.uflag {
      let id = pw != nil ? pw!.pw_uid : opts.rflag ? getuid() : geteuid();
      if opts.nflag {
        if let pwx = getpwuid(id) {
          pw = pwx.pointee
          print(pw!.name)
        } else {
          print(id)
        }
      }
      else {
        print(id)
      }
#if !DEBUG
      return
#endif
    }
    
    if opts.Gflag {
      group(pw, opts.nflag )
#if !DEBUG
      return
#endif
    }
    
#if !os(macOS)
    if opts.Mflag {
      maclabel();
#if !DEBUG
      return
#endif
    }
#endif
    
    if opts.Pflag {
      pline(pw)
#if !DEBUG
      return
#endif
    }
    
    if opts.pflag {
      pretty(pw);
#if !DEBUG
      return
#endif
    }
    
    
    if opts.flagCount == 0 {
      if let pw {
        id_print(pw, true, 0, 0);
      }
      else {
        let id = getuid();
        pw = getpwuid(id).pointee
        id_print(pw, false, 1, 1);
      }
    }
  }
  
  func pretty(_ pwx : passwd?) {
    var pw = pwx
    
    if let pw {
      print("uid\t\(pw.name)")
      print("groups\t", terminator: "")
      group(pw, true);
    } else {
      guard let loginx = getlogin() else {
        err(1, "getlogin");
        fatalError("already exited")
      }
      let ridu = getuid()
      pw = getpwuid(ridu).pointee
      let login = String(cString: loginx)
      if pw == nil || login != pw!.name {
        print("login\t\(login)");
      }
      if let pw {
        print("uid\t\(pw.name)");
      } else {
        print("uid\t\(ridu)");
      }
      
      let eidu = geteuid()
      if eidu != ridu {
        if let pw = getpwuid(eidu) {
          print("euid\t\(pw.name)");
        }
        else {
          print("euid\t\(eidu)");
        }
      }
      let rid = getgid()
      let eid = getegid()
      if rid != eid {
        if let gr = getgrgid(rid) {
          print("rgid\t\(gr.name)")
        }
        else {
          print("rgid\t\(rid)")
        }
      }
      print("groups\t", terminator: "");
      group(nil, true);
    }
  }
  
  func id_print(_ pwx : passwd?, _ use_ggl : Bool, _ p_euid : Int, _ p_egid : Int)
  {
    var ugg = use_ggl
    var gid, egid : gid_t
    var uid, euid : uid_t
    var pw = pwx
    
#if os(macOS)
    
    if (pw == nil) {
      pw = getpwuid(getuid()).pointee
    }
    
    ugg = true
#endif
    if (pw != nil) {
      uid = pw!.pw_uid
      gid = pw!.pw_gid
    }
    else {
      uid = getuid();
      gid = getgid();
    }
    
#if !os(macOS)
    let ngroups_max = sysconf(_SC_NGROUPS_MAX) + 1;
    //      if ((groups = malloc(sizeof(gid_t) * ngroups_max)) == NULL) {
    //        err(1, "malloc");
    //      }
#endif
    
    var groups : [gid_t]?
    if (ugg && pw != nil) {
#if os(macOS)
      // FIXME: was getgrouplist_2
      // 5235093
      //        ngroups = getgrouplist_2(pw.pw_name, gid, &groups);
      let ngroups_max = sysconf(_SC_NGROUPS_MAX) + 1;
      groups = withUnsafeTemporaryAllocation(of: gid_t.self, capacity: ngroups_max) { p in
        
        var ngroups = Int32(ngroups_max)
        getgrouplist(pw!.name, Int32(pw!.pw_gid), p.baseAddress!, &ngroups)
        
        var res = Array(repeating: gid_t(), count: Int(ngroups))
        for i in 0..<res.count {
          res[i]=p[i]
        }
        return res
      }
      
      
      
      
      
#else
      ngroups = ngroups_max;
      getgrouplist(pw.pointee.pw_name, gid, groups, &ngroups);
#endif
    }
    else {
#if os(macOS)
      let ngroups_max = sysconf(_SC_NGROUPS_MAX) + 1;
      //        if ((groups = malloc(sizeof(gid_t) * ngroups_max)) == NULL) {
      //          err(1, "malloc");
      //        }
#endif
      
      
      
      
      // ngroups = getgroups(Int32(ngroups_max), groups);
      
      groups = withUnsafeTemporaryAllocation(of: gid_t.self, capacity: ngroups_max) { p in
        let ngroups = getgroups(Int32(ngroups_max), p.baseAddress!)
        
        var res = Array(repeating: gid_t(), count: Int(ngroups))
        for i in 0..<res.count {
          res[i]=p[i]
        }
        return res
      }
      
      
      
      
      
      
    }
    
#if os(macOS)
    guard let groups else {
      warn("failed to retrieve group list");
      fatalError("failed to retrieve group list");
    }
#endif
    if let pw {
      print("uid=\(uid)(\(pw.name))", terminator: "");
    } else {
      print("uid=\(getuid())", terminator: "")
    }
    print(" gid=\(gid)", terminator: "");
    if let gr = getgrgid(gid) {
      print("(\(String(cString: gr.pointee.gr_name)))", terminator: "");
    }
    if p_euid != 0 {
      euid = geteuid()
      if euid != uid {
        print(" euid=\(euid)", terminator: "")
        if let pw = getpwuid(euid) {
          print("(\(pw.name))", terminator: "");
        }
      }
    }
    if p_egid != 0 {
      egid = getegid()
      if egid != gid {
        print(" egid=\(egid)", terminator: "")
        if let gr = getgrgid(egid) {
          print("(\(String(cString: gr.pointee.gr_name)))", terminator: "")
        }
      }
    }
    var lastgid : gid_t? = nil
    var first = true
    for gid in groups {
      if (lastgid == gid) {
        first = false
        continue;
      }
      if first {
        print(" groups=\(gid)", terminator: "");
      }
      else {
        print(",\(gid)", terminator: "");
      }
      first = false
      if let gr = getgrgid(gid) {
        print("(\(gr.name))", terminator: "");
      }
      lastgid = gid
      
    }
    print("");
  }
  
#if USE_BSM_AUDIT
  func auditid() {
#if os(macOS)
    var ainfo_addr = auditinfo_addr_t()
    /* Keeps the diff looking somewhat sane, always 1 for Apple. */
    var extended = 1;
#else
    var auditinfo = auditinfo_t()
    var ainfo_addr = auditinfo_addr_t()
    var extended, ret : Int32
#endif
    
#if os(macOS)
    if (getaudit_addr(&ainfo_addr, Int32(MemoryLayout.size(ofValue:ainfo_addr))) < 0) {
      err(1, "getaudit_addr");
    }
#else
    extended = 0;
    ret = getaudit(&auditinfo);
    if (ret < 0 && errno == E2BIG) {
      if (getaudit_addr(&ainfo_addr, sizeof(ainfo_addr)) < 0) {
        err(1, "getaudit_addr");
      }
      extended = 1;
    } else if (ret < 0) {
      err(1, "getaudit");
    }
#endif
    if (extended != 0) {
      print(String(format: """
auid=%d
mask.success=0x%08x
mask.failure=0x%08x
asid=%d
termid_addr.port=0x%08jx
termid_addr.addr[0]=0x%08x
termid_addr.addr[1]=0x%08x
termid_addr.addr[2]=0x%08x
termid_addr.addr[3]=0x%08x
""",
                   ainfo_addr.ai_auid, ainfo_addr.ai_mask.am_success,
                   ainfo_addr.ai_mask.am_failure, ainfo_addr.ai_asid,
                   uintmax_t(ainfo_addr.ai_termid.at_port),
                   ainfo_addr.ai_termid.at_addr.0,
                   ainfo_addr.ai_termid.at_addr.1,
                   ainfo_addr.ai_termid.at_addr.2,
                   ainfo_addr.ai_termid.at_addr.3))
#if os(macOS)
      print(String(format: "flags=0x%llx", ainfo_addr.ai_flags))
#endif
    } else {
#if !os(macOS)
      print(String(format: """
auid=%d
mask.success=0x%08x
mask.failure=0x%08x
asid=%d
termid.port=0x%08jx
termid.machine=0x%08x
""", auditinfo.ai_auid, auditinfo.ai_mask.am_success,
                   auditinfo.ai_mask.am_failure,
                   auditinfo.ai_asid, auditinfo.ai_termid.port,
                   auditinfo.ai_termid.machine))
#endif
    }
  }
#endif
  
#if os(macOS)
  func fullname(_ pwx : passwd?) {
    var pw = pwx
    if pw == nil {
      pw = getpwuid(getuid()).pointee
      if pw == nil {
        err(1, "getpwuid");
      }
      
      print(String(cString: pw!.pw_gecos))
    }
  }
#endif
  
  func group(_ pwx : passwd?, _ nflag : Bool) {
    var groups : [gid_t]?
    var pw = pwx
    
#if os(macOS)
    if pw == nil {
      pw = getpwuid(getuid()).pointee
    }
#else
    ngroups_max = sysconf(_SC_NGROUPS_MAX) + 1;
    if ((groups = malloc(sizeof(gid_t) * (ngroups_max))) == NULL) {
      err(1, "malloc");
    }
#endif
    
    if let pw {
#if os(macOS)
      // 5235093
      let ngroups_max = sysconf(_SC_NGROUPS_MAX) + 1;
      
      groups = withUnsafeTemporaryAllocation(of: gid_t.self, capacity: ngroups_max) { p in
        // FIXME: was getgrouplist_2
        //          let ngroups = getgrouplist_2(pw.pw_name, pw.pw_gid, p)
        var ngroups = Int32(ngroups_max)
        getgrouplist(pw.name, Int32(pw.pw_gid), p.baseAddress!, &ngroups)
        
        var res = Array(repeating: gid_t(), count: Int(ngroups))
        for i in 0..<res.count {
          res[i]=p[i]
        }
        return res
      }
#else
      var ngroups = ngroups_max;
      getgrouplist(pw.pw_name, pw.pw_gid, groups, &ngroups);
#endif
    } else {
#if os(macOS)
      let ngroups_max = sysconf(_SC_NGROUPS_MAX) + 1;
      //        if ((groups = malloc(sizeof(gid_t) * (ngroups_max))) == NULL)
      //            err(1, "malloc");
#endif
      groups = withUnsafeTemporaryAllocation(of: gid_t.self, capacity: ngroups_max) { p in
        let ngroups = getgroups(Int32(ngroups_max), p.baseAddress!);
        
        var res = Array(repeating: gid_t(), count: Int(ngroups))
        for i in 0..<res.count {
          res[i]=p[i]
        }
        return res
        
      }
    }
    var lastid : gid_t? = nil
    var first = true
    for id in groups! {
      if lastid == id {
        continue;
      }
      if nflag {
        if let gr = getgrgid(id) {
          print("\(first ? "" : " ")\(String(cString: gr.pointee.gr_name))", terminator: "");
        }
        else {
          print("\(first ? "" : " ")\(id)", terminator: "")
        }
      } else {
        print("\(first ? "" : " ")\(id)", terminator: "")
      }
      lastid = id
      first = false
    }
    print("");
  }
  
#if !os(macOS)
  func maclabel() {
    var string : String
    var label : mac_t
    var error : Int32
    
    error = mac_prepare_process_label(&label);
    if (error == -1) {
      errx(1, "mac_prepare_type: %s", strerror(errno));
    }
    
    error = mac_get_proc(label);
    if (error == -1) {
      errx(1, "mac_get_proc: %s", strerror(errno));
    }
    error = mac_to_text(label, &string);
    if (error == -1) {
      errx(1, "mac_to_text: %s", strerror(errno));
    }
    print(string);
    mac_free(label);
    free(string);
  }
#endif /* __APPLE__ */
  
  func who(_ u : String) -> passwd {
    
    
    /*
     * Translate user argument into a pw pointer.  First, try to
     * get it as specified.  If that fails, try it as a number.
     */
    
    if let pw = getpwnam(u) {
      return pw.pointee
    }
    if let id = uid_t(u) {
      if let pw = getpwuid(id) {
        return pw.pointee
      }
    }
    errx(1, "\(u): no such user")
    /* NOTREACHED */
    fatalError("\(u): no such user")
  }
  
  func pline(_ pwx : passwd?) {
    var pw = pwx
    if pw == nil {
      pw = getpwuid(getuid())?.pointee
      if pw == nil {
        err(1, "getpwuid");
      }
    }
    if let pw {
      print("\(pw.name):\(String(cString: pw.pw_passwd)):\(pw.pw_uid):\(pw.pw_gid):\( String(cString:pw.pw_class)):\(pw.pw_change):\(pw.pw_expire):\(String(cString: pw.pw_gecos)):\(String(cString: pw.pw_dir)):\(String(cString: pw.pw_shell))")
    }
  }
  
  var usage : String { get {
    if (isgroups) {
      return "usage: groups [user]"
    }
    else if (iswhoami) {
      return "usage: whoami"
    } else {
      //        print("%s\n%s%s\n%s\n%s\n%s\n%s\n%s\n%s\n",
      var a = "usage: id [user]"
#if USE_BSM_AUDIT
      a.append("       id -A")
#endif
      
#if os(macOS)
      a.append("       id -F [user]")
#endif
      a.append("       id -G [-n] [user]")
      
#if !os(macOS)
      a.append("       id -M")
#endif
      a.append("       id -P [user]")
      
#if !os(macOS)
      a.append("       id -c")
#endif
      a.append("""
id -g [-nr] [user]
id -p [user]
       id -u [-nr] [user]
"""
      )
      return a
    }
  }
    
  }
}
