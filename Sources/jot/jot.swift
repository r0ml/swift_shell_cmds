
// Generated by Robert M. Lefkowitz <r0ml@liberally.net> in 2024 using ChatGPT
// from a file containing the following notice:

/*
 * SPDX-License-Identifier: BSD-3-Clause
 *
 * Copyright (c) 1993
 *  The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

import Foundation
import shared

/* Defaults */
let BEGIN_DEF : Double = 1
let ENDER_DEF : Double = 100
let REPS_DEF : Int = 100
let STEP_DEF : Double = 1

/* Flags of options that have been set */
let HAVE_STEP = 1
let HAVE_ENDER = 2
let HAVE_BEGIN = 4
let HAVE_REPS = 8

@main final class jot : ShellCommand {
  func is_default(_ s : String) -> Bool {
    return s.isEmpty || s == "-"
  }

  var boring : Bool = false
  var prec = -1
  var longdata : Bool = false
  var intdata : Bool = false
  var chardata : Bool = false
  var nosign : Bool = false
  var sepstring = "\n"
  
  var format : String = ""
  
  var args : [String] = []
  
  // =================================
  
    var haveFormat = false
    var infinity = false
    var nofinalnl = false
    var randomize = false
    var useRandom = false
    var ch: Int = 0
    var mask = 0
    var n = 0
  var begin : Double = Double(BEGIN_DEF)
    var divisor: Double = 0.0
  var ender : Double = Double(ENDER_DEF)
  var s : Double = Double(STEP_DEF)
    var x: Double = 0.0
    var y: Double = 0.0
    var i: Int64 = 0
    var reps = REPS_DEF
    

  func parseOptions() throws(CmdErr) {
    //    let argc = CommandLine.argc
    //    let argv = CommandLine.unsafeArgv
    
    //    while case let option = getopt(Int32(argc), &argv, "b:cnp:rs:w:"), option != -1 {
    
    let optstr = "b:cnp:rs:w:"
    let go = BSDGetopt(optstr)
    while let (ch, optarg) = try go.getopt() {
      switch ch {
        
      case "b":
        boring = true
        fallthrough
      case "w":
        format = optarg
        haveFormat = true
      case "c":
        chardata = true
      case "n":
        nofinalnl = true
      case "p":
        prec = Int(atoi(optarg))
        if prec < 0 {
          errx(1, "bad precision value")
        }
        haveFormat = true
      case "r":
        randomize = true
      case "s":
        sepstring = optarg
      default:
        throw CmdErr(1)
      }
    }
    
    args = go.remaining
    
    switch args.count {
    case 4:
      if !is_default(args[3]) {
        let z = withUnsafeMutablePointer(to: &self.s) {
          let r = withVaList([$0]) {
            vsscanf(args[3], "%lf", $0)
          }
          return r
        }
        if z == 0 {
          errx(1, "bad s value: \(args[3])")
        }
        mask |= HAVE_STEP
        if randomize {
          useRandom = true
        }
      }
      fallthrough
    case 3:
      if !is_default(args[2]) {
        let z = withUnsafeMutablePointer(to: &self.ender) {
          let r = withVaList([$0]) {
            vsscanf(args[2], "%lf", $0)
          }
          return r
        }
        if z == 0 {
          ender = Double(String(args[2].last!.asciiValue!))!
        }
        mask |= HAVE_ENDER
        if prec < 0 {
          n = getprec(args[2])
        }
      }
      fallthrough
    case 2:
      if !is_default(args[1]) {
        let z = withUnsafeMutablePointer(to: &self.begin) {
          let r = withVaList([$0]) {
            vsscanf(args[1], "%lf", $0)
          }
          return r
        }
        if z == 0 {
          begin = Double(String(args[1].last!.asciiValue!))!
        }
        mask |= HAVE_BEGIN
        if prec < 0 {
          prec = getprec(args[1])
        }
        if n > prec {
          prec = n
        }
      }
      fallthrough
    case 1:
      if !is_default(args[0]) {
        let z = withUnsafeMutablePointer(to: &self.reps) {
          let r = withVaList([$0]) {
            vsscanf(args[0], "%ld", $0)
          }
          return r
        }
        if z == 0 {
          errx(1, "bad reps value: \(args[0])")
        }
        mask |= HAVE_REPS
      }
    case 0:
      throw CmdErr(1)
    default:
      errx(1, "too many arguments.  What do you mean by \(args[4])?")
    }
    getformat()
    
    if prec == -1 {
      prec = 0
    }
  }
  
  func runCommand() throws(CmdErr) {
    
    while mask != 0 {
      switch mask {
      case HAVE_STEP, HAVE_ENDER, HAVE_ENDER | HAVE_STEP, HAVE_BEGIN, HAVE_BEGIN | HAVE_STEP:
        reps = REPS_DEF
        mask |= HAVE_REPS
      case HAVE_BEGIN | HAVE_ENDER:
        s = ender > begin ? 1 : -1
        mask |= HAVE_STEP
      case HAVE_BEGIN | HAVE_ENDER | HAVE_STEP:
        if randomize {
          reps = REPS_DEF
        } else if s == 0.0 {
          reps = 0
        } else {
          reps = Int((ender - begin + s) / s)
        }
        if reps <= 0 {
          errx(1, "impossible stepsize")
        }
        mask = 0
      case HAVE_REPS, HAVE_REPS | HAVE_STEP:
        begin = BEGIN_DEF
        mask |= HAVE_BEGIN
      case HAVE_REPS | HAVE_ENDER:
        s = STEP_DEF
        mask = HAVE_REPS | HAVE_ENDER | HAVE_STEP
      case HAVE_REPS | HAVE_ENDER | HAVE_STEP:
        if randomize {
          begin = BEGIN_DEF
        } else if reps == 0 {
          errx(1, "must specify begin if reps == 0")
        }
        begin = ender - Double(reps) * s + s
        mask = 0
      case HAVE_REPS | HAVE_BEGIN:
        s = STEP_DEF
        mask = HAVE_REPS | HAVE_BEGIN | HAVE_STEP
      case HAVE_REPS | HAVE_BEGIN | HAVE_STEP:
        if randomize {
          ender = ENDER_DEF
        } else {
          ender = begin + Double(reps) * s - s
        }
        mask = 0
      case HAVE_REPS | HAVE_BEGIN | HAVE_ENDER:
        if !randomize {
          if reps == 0 {
            errx(1, "infinite sequences cannot be bounded")
          } else if reps == 1 {
            s = 0.0
          } else {
            s = (ender - begin) / Double(reps - 1)
          }
        }
        mask = 0
      case HAVE_REPS | HAVE_BEGIN | HAVE_ENDER | HAVE_STEP:
        if !randomize && s != 0.0 {
          let t = Int((ender - begin + s) / s)
          if t <= 0 {
            errx(1, "impossible stepsize")
          }
          if t < reps {
            reps = t
          }
        }
        mask = 0
      default:
        errx(1, "bad mask")
      }
    }
    if reps == 0 {
      infinity = true
    }
    if randomize {
      if useRandom {
        srandom(UInt32(s))
        divisor = Double(INT32_MAX) + 1
      } else {
        divisor = Double(UINT32_MAX) + 1
      }
      
      if !haveFormat && prec == 0 && begin >= 0 && begin < divisor && ender >= 0 && ender < divisor {
        if begin <= ender {
          ender += 1
        } else {
          begin += 1
        }
        nosign = true
        intdata = true
        format = chardata ? "%c" : "%u"
      }
      x = ender - begin
      for i in 1...reps {
        if useRandom {
          // FIXME: can i get random in swift?
          //         y = Double(random()) / divisor
          y = Double(arc4random()) / divisor
        } else {
          y = Double(arc4random()) / divisor
        }
        if (putdata(y * x + begin, ((reps - i) == 0)) != 0) {
          errx(1, "range error in conversion")
        }
      }
    } else {
      x = begin
      for i in 1...reps {
        if (putdata(x, ((reps - i) == 0)) != 0) {
          errx(1, "range error in conversion")
        }
        x += s
      }
    }
    if !nofinalnl {
      print("")
    }
    exit(0)
  }
    
    func putdata(_ x: Double, _ last: Bool) -> Int {
      if boring {
        print(format, terminator: "")
      } else if longdata && nosign {
        if x <= Double(UInt.max) && x >= 0 {
          print(String(format: format, UInt(x)), terminator: "")
        } else {
          return 1
        }
      } else if longdata {
        if x <= Double(Int.max) && x >= Double(Int.min) {
          let _ = withVaList([Int(x)]) {
            vprintf(format, $0)
          }
//          print(String(format: format, Int(x)), terminator: "")
        } else {
          return 1
        }
      } else if chardata || (intdata && !nosign) {
        if x <= Double(Int32.max) && x >= Double(Int32.min) {
            let _ = withVaList([Int(x)]) {
              vprintf(format, $0)
            }
//          } else {
//            print(String(format: format, Int(x)), terminator: "")
//          }
        } else {
          return 1
        }
      } else if intdata {
        if x <= Double(UInt32.max) && x >= 0 {
          print(String(format: format, UInt(x)), terminator: "")
        } else {
          return 1
        }
      } else {
        print(String(format: format, x), terminator: "")
      }
      if !last {
        print(sepstring, terminator: "")
      }
      
      return 0
    }
  
  var usage = "usage: jot [-cnr] [-b word] [-w word] [-s string] [-p precision] [reps [begin [end [s]]]]"
  
  func getprec(_ str: String) -> Int {
    guard let decimalPointIndex = str.firstIndex(of: ".") else {
      return 0
    }
    let decimalPart = str[decimalPointIndex...]
    return decimalPart.count-1
  }
  
  func getformat() {
//    var xformat = Substring(format)
    var dot = 0, hash = 0, space = 0, sign = 0, numbers = 0
//    let sz = MemoryLayout.size(ofValue: format) - strlen(format) - 1
    
    if boring { return }
    
    let j = /(^(?:[^%]|%%)*)%(.*$)/
    let pp = try! j.firstMatch(in: format)
    
      if pp == nil {
        if !chardata {
        format.append("%.\(prec)f")
        } else {
          format.append("%c")
          intdata = true
        }
      } else if pp!.2.isEmpty {
        format.append("%") // cannot end in single %
      } else {
        let p2 = pp!.output.2 // the only reason for p2 is for error reporting
        var p = p2
        while let pf = p.first, let pfa = pf.asciiValue, (isalpha(Int32(pfa)) == 0) {
          if (isdigit(Int32(pfa)) != 0) {
            numbers += 1
            p.removeFirst()
          } else if (pf == "#" && ((numbers | dot | sign | space | hash) == 0)) ||
                      (pf == " " && ((numbers | dot | space) == 0)) ||
                      ((pf == "+" || pf == "-") && ((numbers | dot | sign) == 0)) ||
                      (pf == "." && ((dot) == 0)) {
            p.removeFirst()
          } else {
            break
          }
        }
        if p.first == "l" {
          longdata = true
          if p.dropFirst().first == "l" {
            if p.count != 2 {
              p.removeFirst()
            }
            errx(1, "illegal or unsupported format '%\(p2.dropLast(p.count))'")
          }
        }
        switch p.first {
        case "o", "u", "x", "X":
          intdata = true
          nosign = true
        case "d", "i":
          intdata = true
        case "D":
          if !longdata {
            intdata = true
            break
          }
        case "O", "U":
          if !longdata {
            intdata = true
            nosign = true
            break
          }
        case "c":
          if !(intdata || longdata) {
            chardata = true
            break
          }
        case "h", "n", "p", "q", "s", "L", "$", "*":
          break
        case "f", "e", "g", "E", "G":
          if !longdata {
            break
          }
        default:
          p.removeFirst()
          errx(1, "illegal or unsupported format '$\(p2.dropLast(p.count))'")
        }
        
        p.removeFirst()
        while let np = p.first {
          p.removeFirst()
          if np == "%" && !p.isEmpty && p.first != "%" {
            errx(1, "too many conversions")
          } else if np == "%" && p.first == "%" {
            p.removeFirst()
          } else if np == "%" && p.first == nil {
            format.append("%")
            break
          }
        }
      }
    }
}
