
// Generated by Robert M. Lefkowitz <r0ml@liberally.net> in 2024 using ChatGPT
// from a file containing the following notice:

/*
 * SPDX-License-Identifier: BSD-3-Clause
 *
 * Copyright (c) 1993
 *  The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

import CMigration

import Darwin

/* Defaults */
let BEGIN_DEF : Double = 1
let ENDER_DEF : Double = 100
let REPS_DEF : Int = 100
let STEP_DEF : Double = 1

/* Flags of options that have been set */
let HAVE_STEP = 1
let HAVE_ENDER = 2
let HAVE_BEGIN = 4
let HAVE_REPS = 8

@main final class jot : ShellCommand {
  func is_default(_ s : String) -> Bool {
    return s.isEmpty || s == "-"
  }

  struct CommandOptions {
    var boring : Bool = false
    var prec = -1
    var longdata : Bool = false
    var intdata : Bool = false
    var chardata : Bool = false
    var nosign : Bool = false
    var sepstring = "\n"
    
    var format : String = ""
    
    var args : [String] = []
    
    // =================================
    
    var haveFormat = false
    var infinity = false
    var nofinalnl = false
    var randomize = false
    var useRandom = false
    var mask = 0
  }

  var options : CommandOptions!

    var ch: Int = 0
    var n = 0
  var begin : Double = Double(BEGIN_DEF)
    var divisor: Double = 0.0
  var ender : Double = Double(ENDER_DEF)
  var s : Double = Double(STEP_DEF)
    var x: Double = 0.0
    var y: Double = 0.0
    var i: Int64 = 0
    var reps = REPS_DEF
    

  func parseOptions() throws(CmdErr) -> CommandOptions {
    //    let argc = CommandLine.argc
    //    let argv = CommandLine.unsafeArgv
    
    //    while case let option = getopt(Int32(argc), &argv, "b:cnp:rs:w:"), option != -1 {
    var opts = CommandOptions()
    
    let optstr = "b:cnp:rs:w:"
    let go = BSDGetopt(optstr)
    while let (ch, optarg) = try go.getopt() {
      switch ch {
        
      case "b":
          opts.boring = true
        fallthrough
      case "w":
          opts.format = optarg
          opts.haveFormat = true
      case "c":
          opts.chardata = true
      case "n":
          opts.nofinalnl = true
      case "p":
          guard let op = UInt(optarg) else {
          errx(1, "bad precision value")
        }
          opts.prec = Int(op)
          opts.haveFormat = true
      case "r":
          opts.randomize = true
      case "s":
          opts.sepstring = optarg
      default:
        throw CmdErr(1)
      }
    }
    
    opts.args = go.remaining
    
    switch opts.args.count {
    case 4:
        if !is_default(opts.args[3]) {
        let z = withUnsafeMutablePointer(to: &self.s) {
          let r = withVaList([$0]) {
            vsscanf(opts.args[3], "%lf", $0)
          }
          return r
        }
        if z == 0 {
          errx(1, "bad s value: \(opts.args[3])")
        }
          opts.mask |= HAVE_STEP
          if opts.randomize {
            opts.useRandom = true
        }
      }
      fallthrough
    case 3:
        if !is_default(opts.args[2]) {
        let z = withUnsafeMutablePointer(to: &self.ender) {
          let r = withVaList([$0]) {
            vsscanf(opts.args[2], "%lf", $0)
          }
          return r
        }
        if z == 0 {
          ender = Double(String(opts.args[2].last!.asciiValue!))!
        }
          opts.mask |= HAVE_ENDER
        if opts.prec < 0 {
          n = getprec(opts.args[2])
        }
      }
      fallthrough
    case 2:
        if !is_default(opts.args[1]) {
        let z = withUnsafeMutablePointer(to: &self.begin) {
          let r = withVaList([$0]) {
            vsscanf(opts.args[1], "%lf", $0)
          }
          return r
        }
        if z == 0 {
          begin = Double(String(opts.args[1].last!.asciiValue!))!
        }
          opts.mask |= HAVE_BEGIN
        if opts.prec < 0 {
          opts.prec = getprec(opts.args[1])
        }
        if n > opts.prec {
          opts.prec = n
        }
      }
      fallthrough
    case 1:
        if !is_default(opts.args[0]) {
        let z = withUnsafeMutablePointer(to: &self.reps) {
          let r = withVaList([$0]) {
            vsscanf(opts.args[0], "%ld", $0)
          }
          return r
        }
        if z == 0 {
          errx(1, "bad reps value: \(opts.args[0])")
        }
          opts.mask |= HAVE_REPS
      }
    case 0:
      throw CmdErr(1)
    default:
        errx(1, "too many arguments.  What do you mean by \(opts.args[4])?")
    }
    getformat(&opts)
    
    if opts.prec == -1 {
      opts.prec = 0
    }
    return opts
  }
  
  func runCommand() throws(CmdErr) {
    var opts = options!

    while opts.mask != 0 {
      switch opts.mask {
      case HAVE_STEP, HAVE_ENDER, HAVE_ENDER | HAVE_STEP, HAVE_BEGIN, HAVE_BEGIN | HAVE_STEP:
        reps = REPS_DEF
          opts.mask |= HAVE_REPS
      case HAVE_BEGIN | HAVE_ENDER:
        s = ender > begin ? 1 : -1
          opts.mask |= HAVE_STEP
      case HAVE_BEGIN | HAVE_ENDER | HAVE_STEP:
          if opts.randomize {
          reps = REPS_DEF
        } else if s == 0.0 {
          reps = 0
        } else {
          reps = Int((ender - begin + s) / s)
        }
        if reps <= 0 {
          errx(1, "impossible stepsize")
        }
          opts.mask = 0
      case HAVE_REPS, HAVE_REPS | HAVE_STEP:
        begin = BEGIN_DEF
          opts.mask |= HAVE_BEGIN
      case HAVE_REPS | HAVE_ENDER:
        s = STEP_DEF
          opts.mask = HAVE_REPS | HAVE_ENDER | HAVE_STEP
      case HAVE_REPS | HAVE_ENDER | HAVE_STEP:
          if opts.randomize {
          begin = BEGIN_DEF
        } else if reps == 0 {
          errx(1, "must specify begin if reps == 0")
        }
        begin = ender - Double(reps) * s + s
          opts.mask = 0
      case HAVE_REPS | HAVE_BEGIN:
        s = STEP_DEF
          opts.mask = HAVE_REPS | HAVE_BEGIN | HAVE_STEP
      case HAVE_REPS | HAVE_BEGIN | HAVE_STEP:
          if opts.randomize {
          ender = ENDER_DEF
        } else {
          ender = begin + Double(reps) * s - s
        }
          opts.mask = 0
      case HAVE_REPS | HAVE_BEGIN | HAVE_ENDER:
          if !opts.randomize {
          if reps == 0 {
            errx(1, "infinite sequences cannot be bounded")
          } else if reps == 1 {
            s = 0.0
          } else {
            s = (ender - begin) / Double(reps - 1)
          }
        }
          opts.mask = 0
      case HAVE_REPS | HAVE_BEGIN | HAVE_ENDER | HAVE_STEP:
          if !opts.randomize && s != 0.0 {
          let t = Int((ender - begin + s) / s)
          if t <= 0 {
            errx(1, "impossible stepsize")
          }
          if t < reps {
            reps = t
          }
        }
          opts.mask = 0
      default:
        errx(1, "bad mask")
      }
    }
    if reps == 0 {
      opts.infinity = true
    }
    if opts.randomize {
      if opts.useRandom {
        srandom(UInt32(s))
        divisor = Double(Int32.max) + 1
      } else {
        divisor = Double(UInt32.max) + 1
      }
      
      if !opts.haveFormat && opts.prec == 0 && begin >= 0 && begin < divisor && ender >= 0 && ender < divisor {
        if begin <= ender {
          ender += 1
        } else {
          begin += 1
        }
        opts.nosign = true
        opts.intdata = true
        opts.format = opts.chardata ? "%c" : "%u"
      }
      x = ender - begin
      for i in 1...reps {
        if opts.useRandom {
          // FIXME: can i get random in swift?
          //         y = Double(random()) / divisor
          y = Double(arc4random()) / divisor
        } else {
          y = Double(arc4random()) / divisor
        }
        if (putdata(y * x + begin, ((reps - i) == 0)) != 0) {
          errx(1, "range error in conversion")
        }
      }
    } else {
      x = begin
      for i in 1...reps {
        if (putdata(x, ((reps - i) == 0)) != 0) {
          errx(1, "range error in conversion")
        }
        x += s
      }
    }
    if !opts.nofinalnl {
      print("")
    }
  }
    
  func putdata(_ x: Double, _ last: Bool) -> Int {
    if options.boring {
        print(options.format, terminator: "")
      } else if options.longdata && options.nosign {
        if x <= Double(UInt.max) && x >= 0 {
          print(cFormat(options.format, UInt(x)), terminator: "")
        } else {
          return 1
        }
      } else if options.longdata {
        if x <= Double(Int.max) && x >= Double(Int.min) {
          let _ = withVaList([Int(x)]) {
            vprintf(options.format, $0)
          }
//          print(String(format: format, Int(x)), terminator: "")
        } else {
          return 1
        }
      } else if options.chardata || (options.intdata && !options.nosign) {
        if x <= Double(Int32.max) && x >= Double(Int32.min) {
            let _ = withVaList([Int(x)]) {
              vprintf(options.format, $0)
            }
//          } else {
//            print(String(format: format, Int(x)), terminator: "")
//          }
        } else {
          return 1
        }
      } else if options.intdata {
        if x <= Double(UInt32.max) && x >= 0 {
          print(cFormat(options.format, UInt(x)), terminator: "")
        } else {
          return 1
        }
      } else {
        print(cFormat(options.format, x), terminator: "")
      }
      if !last {
        print(options.sepstring, terminator: "")
      }
      
      return 0
    }
  
  var usage = "usage: jot [-cnr] [-b word] [-w word] [-s string] [-p precision] [reps [begin [end [s]]]]"
  
  func getprec(_ str: String) -> Int {
    guard let decimalPointIndex = str.firstIndex(of: ".") else {
      return 0
    }
    let decimalPart = str[decimalPointIndex...]
    return decimalPart.count-1
  }
  
  func getformat(_ opts : inout CommandOptions) {
//    var xformat = Substring(format)
    var dot = 0, hash = 0, space = 0, sign = 0, numbers = 0
//    let sz = MemoryLayout.size(ofValue: format) - strlen(format) - 1
    
    if opts.boring { return }
    
    let j = /(^(?:[^%]|%%)*)%(.*$)/
    let pp = try! j.firstMatch(in: opts.format)
    
      if pp == nil {
        if !opts.chardata {
          opts.format.append("%.\(opts.prec)f")
        } else {
          opts.format.append("%c")
          opts.intdata = true
        }
      } else if pp!.2.isEmpty {
        opts.format.append("%") // cannot end in single %
      } else {
        let p2 = pp!.output.2 // the only reason for p2 is for error reporting
        var p = p2
        while let pf = p.first, let pfa = pf.asciiValue, (isalpha(Int32(pfa)) == 0) {
          if (isdigit(Int32(pfa)) != 0) {
            numbers += 1
            p.removeFirst()
          } else if (pf == "#" && ((numbers | dot | sign | space | hash) == 0)) ||
                      (pf == " " && ((numbers | dot | space) == 0)) ||
                      ((pf == "+" || pf == "-") && ((numbers | dot | sign) == 0)) ||
                      (pf == "." && ((dot) == 0)) {
            p.removeFirst()
          } else {
            break
          }
        }
        if p.first == "l" {
          opts.longdata = true
          if p.dropFirst().first == "l" {
            if p.count != 2 {
              p.removeFirst()
            }
            errx(1, "illegal or unsupported format '%\(p2.dropLast(p.count))'")
          }
        }
        switch p.first {
        case "o", "u", "x", "X":
            opts.intdata = true
            opts.nosign = true
        case "d", "i":
            opts.intdata = true
        case "D":
            if !opts.longdata {
            opts.intdata = true
            break
          }
        case "O", "U":
            if !opts.longdata {
              opts.intdata = true
              opts.nosign = true
            break
          }
        case "c":
            if !(opts.intdata || opts.longdata) {
              opts.chardata = true
            break
          }
        case "h", "n", "p", "q", "s", "L", "$", "*":
          break
        case "f", "e", "g", "E", "G":
            if !opts.longdata {
            break
          }
        default:
          p.removeFirst()
          errx(1, "illegal or unsupported format '$\(p2.dropLast(p.count))'")
        }
        
        p.removeFirst()
        while let np = p.first {
          p.removeFirst()
          if np == "%" && !p.isEmpty && p.first != "%" {
            errx(1, "too many conversions")
          } else if np == "%" && p.first == "%" {
            p.removeFirst()
          } else if np == "%" && p.first == nil {
            opts.format.append("%")
            break
          }
        }
      }
    }
}
