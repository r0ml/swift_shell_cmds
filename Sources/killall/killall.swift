
// Generated by Robert M. Lefkowitz <r0ml@liberally.net> in 2024 using ChatGPT
// from a file containing the following notice:

/*
 * SPDX-License-Identifier: BSD-2-Clause-FreeBSD
 *
 * Copyright (c) 2000 Peter Wemm <peter@FreeBSD.org>
 * Copyright (c) 2000 Paul Saab <ps@FreeBSD.org>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

import Foundation
import shared

@main final class killall : ShellCommand {
  
  var signames : [String] = []
  let OPTIONS = "c:dej:Ilmqst:u:vz"

//  var procs: [kinfo_proc]
  var sb = stat()
  var pw: UnsafeMutablePointer<passwd>?
  var rgx = regex_t()
  var pmatch = regmatch_t()
  var buf : String = ""
//  var first: CChar
  var user: String?
  var tty: String?
  var cmd: String?
  var qflag = 0
  var vflag = 0
  var sflag = 0
  var dflag = 0
  var eflag = 0
  var jflag = 0
  var Iflag = 0
  var mflag = 0
  var zflag = 0
  var uid: uid_t = 0
  var tdev: dev_t = 0
//  var mypid: pid_t
  var thiscmd: String?
//  var thispid: pid_t
//  var thistdev: dev_t
  var sig = SIGTERM
  var errors = 0
  var jid: Int = 0
  var mib = [Int32](repeating: 0, count: 4)
//  var miblen: u_int
//  var size: size_t
//  var matched: Int
  var killed = 0
  var args = [String]()
  
  var justPrint = false
  

  required init() {
    signames = swiftify_signames()
  }
  
  // copied from kill
  func swiftify_signames() -> [String] {
    return withUnsafePointer(to: sys_signame) { p in
      let j = MemoryLayout.size(ofValue: sys_signame)
      let k = j / MemoryLayout<UnsafePointer<CChar>>.size
      let ss = p.withMemoryRebound(to: UnsafePointer<CChar>.self, capacity: k) { pp in
        var kk = [String]()
        for i in 0..<k {
          kk.append(String(cString: pp[i]))
        }
        return kk
      }
      return ss
    }
  }
  
  var usage : String { get {
#if os(macOS) || os(iOS) || os(tvOS) || os(watchOS) || os(visionOS)
    let a = "usage: killall [-delmsqvz] [-help] [-I]"
#else
    let a = "usage: killall [-delmsqvz] [-help] [-I] [-j jail]"
#endif
    return a + """

               [-u user] [-t tty] [-c cmd] [-SIGNAL] [cmd]...
At least one option or argument to specify processes must be given."
"""
  } }
  
  func printsig(_ fpx: FileHandle) {
    var output = ""
    var fp = fpx
    
    var ind = 0
    for p in signames.dropFirst() {
      output += p
      ind += p.count
      if ind > 75 {
        output += "\n"
        ind = 0
      } else {
        output += " "
        ind += 1
      }
    }
    print(output, to: &fp)
  }
  
  func nosig(_ name: String) {
    warnx("unknown signal \(name); valid signals:")
    printsig(FileHandle.standardError)
    exit(1)
  }
  
  func kludge_signal_arg(_ argr : String) throws(CmdErr) -> Int32? {
    var sig: Int = -1
    var arg = Substring(argr)
    
    guard let ch = arg.first else { return nil }
    if ch.isLetter {
      if arg == "help" {
        throw CmdErr(1)
      }
      if arg.uppercased().hasPrefix("SIG") {
        arg  = arg.dropFirst(3)
      }
      let sig = signames.dropFirst().firstIndex(of: argr)
      if sig == nil {
        nosig(argr)
      }
    } else if ch.isNumber {
      if let x = Int(arg) {
        sig = x
      } else {
        errx(1, "illegal signal number: \(argr)")
      }
      if sig < 0 || sig >= NSIG {
        nosig(String(argr) )
      }
    } else {
      nosig(String(argr) )
    }
    
    // FIXME: the original implementation finds the last
    // argument with a signal instead of the first
    return Int32(sig)
  }
  

    
  
    func parseOptions() throws(CmdErr) {
      setlocale(LC_ALL, "")
      
      if CommandLine.arguments.count < 2 {
        throw CmdErr(1)
      }
      let go = BSDGetopt(OPTIONS)
      while let (ch, optarg) = try go.getopt() {
        switch ch {
        case "c":
          cmd = optarg
        case "d":
          dflag += 1
        case "e":
          eflag += 1
        case "I":
          Iflag += 1
#if !os(macOS)
        case "j":
          jflag += 1
          if let x = Int(String(cString: optarg)) {
            jid = x
          } else {
            errx(1, "illegal jid: \(String(cString: optarg))")
          }
          if jail_attach(jid) == -1 {
            err(1, "jail_attach(\(jid)")
          }
#endif
        case "l":
          printsig(FileHandle.standardOutput)
          justPrint = true
          return
        case "m":
          mflag += 1
        case "q":
          qflag += 1
        case "s":
          sflag += 1
        case "t":
          tty = optarg
        case "u":
          user = optarg
        case "v":
          vflag += 1
        case "z":
          zflag += 1
        default:
          if let s = try kludge_signal_arg(optarg) {
            sig = s
          } else {
            throw CmdErr(1)
          }
        }
      }
      
      args = go.remaining
      
#if os(macOS)
      if user == nil && tty == nil && cmd == nil && CommandLine.arguments.count == 0 {
        throw CmdErr(1)
      }
#else
      if user == nil && tty == nil && cmd == nil && !jflag && CommandLine.arguments.count == 0 {
        throw CmdErr(1)
      }
#endif
    }
    
    
    func runCommand() throws(CmdErr) {
      if justPrint { return }
      
      if let tty {
        if tty.hasPrefix("/dev/") {
          buf = tty
        } else if strncmp(tty, "tty", 3) == 0 {
          buf = "/dev/\(tty)"
        } else {
          buf = "/dev/tty\(tty)"
        }
        if stat(buf, &sb) < 0 {
          err(1, "stat(\(buf)")
        }
        if !S_ISCHR(sb.st_mode) {
          errx(1, "\(buf): not a character device")
        }
        tdev = sb.st_rdev
        if dflag != 0 {
          print("ttydev:0x\(String(format: "%x", tdev))")
        }
      }
      if let user {
        if let x = uid_t(user) {
          uid = x
        } else {
          pw = getpwnam(user)
          if pw == nil {
            errx(1, "user \(user) does not exist")
          }
          uid = pw!.pointee.pw_uid
          if dflag != 0 {
            print("uid:\(uid)")
          }
        }
      } else {
        uid = getuid()
        if uid != 0 {
          pw = getpwuid(uid)
          if let pw = pw {
            user = String(cString: pw.pointee.pw_name)
          }
          if dflag != 0 {
            print("uid:\(uid)", uid)
          }
        }
      }
      var size : size_t = 0

      mib[0] = CTL_KERN
      mib[1] = KERN_PROC
      
      var miblen : UInt32
      
    if user != nil {
        mib[2] = eflag != 0 ? KERN_PROC_UID : KERN_PROC_RUID
        mib[3] = Int32(uid)
        miblen = 4
    } else if tty != nil {
        mib[2] = KERN_PROC_TTY
        mib[3] = tdev
        miblen = 4
      } else {
#if os(macOS)
        mib[2] = KERN_PROC_ALL
#else
        mib[2] = KERN_PROC_PROC
#endif
        mib[3] = 0
        miblen = 3
      }
      
      var st : Int32 = -1
      
      var procs: [kinfo_proc]
      
      repeat {
        st = sysctl(&mib, miblen, nil, &size, nil, 0)
        if st == -1 {
          err(1, "could not sysctl(KERN_PROC)")
        }
        if size == 0 {
          errx(1, "could not get size from sysctl(KERN_PROC)")
        }
        size += size / 10
        //      newprocs = realloc(procs, size)
        //      if newprocs == nil {
        //        free(procs)
        //        err(1, "could not reallocate memory")
        //      }
        procs = withUnsafeTemporaryAllocation(byteCount: size, alignment: 16) { p in
          st = sysctl(&mib, miblen, p.baseAddress!, &size, nil, 0)
          var procs = Array(repeating: kinfo_proc(), count: size / MemoryLayout<kinfo_proc>.stride)
          for i in 0..<procs.count {
            procs[i]=p.bindMemory(to: kinfo_proc.self)[i]
          }
          return procs
        }
      } while st == -1 && errno == ENOMEM
      if st == -1 {
        err(1, "could not sysctl(KERN_PROC)")
      }
      if size % MemoryLayout<kinfo_proc>.size != 0 {
        var f = FileHandle.standardError
        print("proc size mismatch (\(size) total, \(MemoryLayout<kinfo_proc>.size) chunks)", to: &f)
        print("userland out of sync with kernel", to: &f)
        exit(1)
      }
      let nprocs = size / MemoryLayout<kinfo_proc>.size
      if dflag != 0 {
        print("nprocs \(nprocs)")
      }
      let mypid = getpid()
      
      for i in 0..<nprocs {
#if os(macOS)
        if procs[i].kp_proc.p_stat == SZOMB && zflag == 0 {
          continue
        }
        let thispid = procs[i].kp_proc.p_pid
        
        var mib = [Int32](repeating: 0, count: 3)
        var argmax: UInt = 0
        var syssize: size_t
        
        mib[0] = CTL_KERN
        mib[1] = KERN_ARGMAX
        
        syssize = MemoryLayout<Int>.size
        if sysctl(&mib, 2, &argmax, &syssize, nil, 0) == -1 {
          continue
        }
        
        // argmax += MemoryLayout<Int>.size
        
        //      procargs = malloc(argmax)
        //      if procargs == nil {
        //          continue
        //      }
        
        mib[0] = CTL_KERN
        mib[1] = KERN_PROCARGS2
        mib[2] = thispid
        
        syssize = size_t(argmax)
        thiscmd = withUnsafeTemporaryAllocation(byteCount: syssize, alignment: 16) {p in
          if sysctl(&mib, 3, p.baseAddress!, &syssize, nil, 0) != -1 {
            let procargs = Data(bytes: p.baseAddress!.advanced(by: 4), count: syssize-4)
            
            let fi = procargs.firstIndex(where: {$0==0}) ?? procargs.count
            let pa = procargs[0..<fi]
            
            var thiscmd = String(data: pa, encoding: .ascii)!
            if let j = thiscmd.lastIndex(where: { $0 == "/" }) {
              thiscmd = String(thiscmd[j...].dropFirst())
            }
            return thiscmd
            
          }
          return nil
        }
         let thistdev = procs[i].kp_eproc.e_tdev
#else
        if procs![i].ki_stat == SZOMB && zflag == 0 {
          continue
        }
        thispid = procs![i].ki_pid
        thiscmd = strdup(procs![i].ki_comm)
        let thistdev = procs![i].ki_tdev
#endif
        if thispid == mypid {
          continue
        }
        
        var matched = true
        if let tty = tty {
          if thistdev != tdev {
            matched = false
          }
        }
        if let cmd = cmd {
          if mflag != 0 {
            if regcomp(&rgx, cmd, REG_EXTENDED|REG_NOSUB) != 0 {
              mflag = 0
              warnx("\(cmd): illegal regexp")
            }
          }
          if mflag != 0 {
            pmatch.rm_so = 0
            pmatch.rm_eo = regoff_t(thiscmd!.count)
            if regexec(&rgx, thiscmd, 0, &pmatch, REG_STARTEND) != 0 {
              matched = false
            }
            regfree(&rgx)
          } else {
            // FIXME: what is this?
            if strncmp(thiscmd, cmd, Int(MAXCOMLEN)) != 0 {
              matched = false
            }
          }
        }
        if matched == false {
          continue
        }
        if CommandLine.arguments.count > 0 {
          matched = false
        }
        for j in CommandLine.arguments {
          if mflag != 0 {
            if regcomp(&rgx, j, REG_EXTENDED|REG_NOSUB) != 0 {
              mflag = 0
              warnx("\(j): illegal regexp")
            }
          }
          if mflag != 0 {
            pmatch.rm_so = 0
            pmatch.rm_eo = regoff_t(thiscmd!.count)
            if regexec(&rgx, thiscmd, 0, &pmatch, REG_STARTEND) == 0 {
              matched = true
            }
            regfree(&rgx)
          } else {
            if thiscmd == j {
              matched = true
            }
          }
          if matched {
            break
          }
        }
        if matched && Iflag != 0 {
#if os(macOS)
          print("Send signal \(sig) to \(thiscmd!) (pid \(thispid))? ", terminator: "")
#else
          printf("Send signal %d to %s (pid %d uid %d)? ", sig, thiscmd, thispid, thisuid)
#endif
          fflush(stdout)
          var ch = getchar()
          let first = CChar(ch)
          while ch != 10 && ch != EOF {
            ch = getchar()
          }
          if first != Character("y").asciiValue! && first != Character("Y").asciiValue! {
            matched = false
          }
        }
        if matched == false {
          continue
        }
        if dflag != 0 {
#if os(macOS)
          print("sig:\(sig), cmd:\(thiscmd!), pid:\(thispid), dev:0x\(String(format:"%0x",thistdev))")
#else
          printf("sig:%d, cmd:%s, pid:%d, dev:0x%jx uid:%d\n", sig, thiscmd, thispid, thistdev, thisuid)
#endif
        }
        
        if vflag != 0 || sflag != 0 {
          print("kill -\(signames[Int(sig)]) \(thispid)")
        }
        
        killed += 1
        if dflag == 0 && sflag == 0 {
          if kill(thispid, sig) < 0 {
            warn("warning: kill -\(signames[Int(sig)]) \(thispid)")
            errors = 1
          }
        }
      }
      if killed == 0 {
        if qflag == 0 {
          var se = FileHandle.standardError
          let j = getuid() != 0 ? "belonging to you " : ""
          print("No matching processes \(j)were found", to: &se )
        }
        errors = 1
      }
      if errors != 0 { throw CmdErr(errors) }
    }
  }
