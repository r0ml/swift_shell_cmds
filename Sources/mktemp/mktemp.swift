
// Generated by Robert M. Lefkowitz <r0ml@liberally.net> in 2024 using ChatGPT
// from a file containing the following notice:

/*
 * SPDX-License-Identifier: BSD-2-Clause-FreeBSD
 *
 * Copyright (c) 1994, 1995, 1996, 1998 Peter Wemm <peter@netplex.com.au>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

import Foundation

// Swift doesn't have a direct equivalent to C's getopt_long function, so the command line argument parsing will need to be done manually. Also, Swift doesn't have a direct equivalent to C's mkdtemp and mkstemp functions, so we'll need to use the FileManager class to create temporary directories and files. Here's a rough translation of the C code to Swift:

import Foundation
import shared

@main final class mktemp : ShellCommand {
  let long_opts: [shared.option] = [
    option("directory", .no_argument),
    option("tmpdir", .required_argument),
    option("quiet", .no_argument),
    option("dry-run", .required_argument),
  ]
  
  
  var dflag = false
  var qflag = false
  var tflag = false
  var uflag = false
  var prefix = "mktemp"
  var tmpdir: String?
  var prefer_tmpdir = true
  
  var args : [String] = []
  
  var ret : Int32 = 0
  
  func parseOptions() throws(CmdErr) {
    //    let argc = CommandLine.argc
    //    let argv = CommandLine.unsafeArgv
    
    let go = BSDGetopt_long("dp:qt:u", long_opts)
    while let (ch, optarg) = try go.getopt_long() {
      
      
      //      let c = getopt_long(argc, argv, "dp:qt:u", long_opts, nil)
      
      switch ch {
        
      case "d", "directory":
        dflag = true
      case "p", "tmpdir":
        tmpdir = optarg
        if tmpdir == nil || tmpdir!.isEmpty {
          tmpdir = ProcessInfo.processInfo.environment["TMPDIR"]
        }
        prefer_tmpdir = false
      case "q", "quiet":
        qflag = true
      case "t":
        prefix = optarg
        tflag = true
      case "u", "dry-run":
        uflag = true
      default:
        throw CmdErr(1)
      }
    }
    
    args = go.remaining
  }
  
  
  func runCommand() throws(CmdErr) {
    var name : String?
    
    if !tflag && args.count < 1 {
      tflag = true
      prefix = "tmp"
      prefer_tmpdir = false
    }
    
    if tflag {
      let envtmp = ProcessInfo.processInfo.environment["TMPDIR"]
      if prefer_tmpdir || tmpdir == nil {
        tmpdir = envtmp
      }
      if tmpdir == nil {
        tmpdir = "/tmp"
      }
      
      if tmpdir != nil && !tmpdir!.isEmpty && tmpdir!.last! == "/" {
        name = "\(tmpdir!)\(prefix).XXXXXXXXXX"
      } else {
        name = "\(tmpdir!)/\(prefix).XXXXXXXXXX"
      }
    }
    
    /* generate all requested files */
    while name != nil || !args.isEmpty {
      if name == nil {
        if (!tflag && tmpdir != nil) {
          name = "\(tmpdir!)/\(args.first!)"
        } else {
          name = args.first
        }
        if (name == nil) {
          err(1, "");
        }
        args.removeFirst()
      }
      
      name!.withCString {
        let k = UnsafeMutablePointer(mutating: $0)
        if (dflag) {
          if mkdtemp(k) == nil {
            ret = 1
            if (!qflag) {
              warn("mkdtemp failed on \(name!)")
            }
          } else {
            print(name!)
            if uflag {
              rmdir(name)
            }
          }
        } else {
          let fd = mkstemp(k)
          if (fd < 0) {
 /*           let ee = errno
            let ef = strerror(ee)
            let g = String(cString: ef!)
   */
            ret = 1
            if (!qflag) {
              warn("mkstemp failed on \(name!)")
            }
          } else {
            close(fd)
            if uflag {
              unlink($0)
            }
            print(name!)
          }
        }
      }
      name = nil;
    }
    if ret != 0 {
      throw CmdErr(Int(ret))
    }
  }
  
  var usage = """
usage: mktemp [-d] [-p tmpdir] [-q] [-t prefix] [-u] template ..."
       mktemp [-d] [-p tmpdir] [-q] [-u] -t prefix")
"""
}
