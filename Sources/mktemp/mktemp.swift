
// Generated by Robert M. Lefkowitz <r0ml@liberally.net> in 2024 using ChatGPT
// from a file containing the following notice:

/*
 * SPDX-License-Identifier: BSD-2-Clause-FreeBSD
 *
 * Copyright (c) 1994, 1995, 1996, 1998 Peter Wemm <peter@netplex.com.au>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

// Swift doesn't have a direct equivalent to C's getopt_long function, so the command line argument parsing will need to be done manually. Also, Swift doesn't have a direct equivalent to C's mkdtemp and mkstemp functions, so we'll need to use the FileManager class to create temporary directories and files. Here's a rough translation of the C code to Swift:

import CMigration

import Darwin

@main final class mktemp : ShellCommand {
  let long_opts: [CMigration.option] = [
    option("directory", .no_argument),
    option("tmpdir", .required_argument),
    option("quiet", .no_argument),
    option("dry-run", .required_argument),
  ]
  
  
  struct CommandOptions {
    var dflag = false
    var qflag = false
    var tflag = false
    var uflag = false
    var prefix = "mktemp"
    var tmpdir: String?
    var prefer_tmpdir = true
    
    var args : [String] = []
  }
  
  var ret : Int32 = 0
  
  func parseOptions() throws(CmdErr) -> CommandOptions {
    //    let argc = CommandLine.argc
    //    let argv = CommandLine.unsafeArgv
    
    var opts = CommandOptions()
    
    let go = BSDGetopt_long("dp:qt:u", long_opts)
    while let (ch, optarg) = try go.getopt_long() {
      
      
      //      let c = getopt_long(argc, argv, "dp:qt:u", long_opts, nil)
      
      switch ch {
        
      case "d", "directory":
          opts.dflag = true
      case "p", "tmpdir":
          opts.tmpdir = optarg
          if opts.tmpdir == nil || opts.tmpdir!.isEmpty {
            opts.tmpdir = getenv("TMPDIR")
        }
          opts.prefer_tmpdir = false
      case "q", "quiet":
          opts.qflag = true
      case "t":
          opts.prefix = optarg
          opts.tflag = true
      case "u", "dry-run":
          opts.uflag = true
      default:
        throw CmdErr(1)
      }
    }
    
    opts.args = go.remaining
    return opts
  }
  
  
  func runCommand(_ optsx : CommandOptions) throws(CmdErr) {
    var opts = optsx
    
    var name : String?
    
    if !opts.tflag && opts.args.count < 1 {
      opts.tflag = true
      opts.prefix = "tmp"
      opts.prefer_tmpdir = false
    }
    
    if opts.tflag {
      let envtmp = getenv("TMPDIR")
      if opts.prefer_tmpdir || opts.tmpdir == nil {
        opts.tmpdir = envtmp
      }
      if opts.tmpdir == nil {
        opts.tmpdir = "/tmp"
      }
      
      if opts.tmpdir != nil && !opts.tmpdir!.isEmpty && opts.tmpdir!.last! == "/" {
        name = "\(opts.tmpdir!)\(opts.prefix).XXXXXXXXXX"
      } else {
        name = "\(opts.tmpdir!)/\(opts.prefix).XXXXXXXXXX"
      }
    }
    
    /* generate all requested files */
    while name != nil || !opts.args.isEmpty {
      if name == nil {
        if (!opts.tflag && opts.tmpdir != nil) {
          name = "\(opts.tmpdir!)/\(opts.args.first!)"
        } else {
          name = opts.args.first
        }
        if (name == nil) {
          err(1, "");
        }
        opts.args.removeFirst()
      }
      
      name!.withCString {
        let k = UnsafeMutablePointer(mutating: $0)
        if (opts.dflag) {
          if mkdtemp(k) == nil {
            ret = 1
            if (!opts.qflag) {
              warn("mkdtemp failed on \(name!)")
            }
          } else {
            print(name!)
            if opts.uflag {
              rmdir(name)
            }
          }
        } else {
          let fd = mkstemp(k)
          if (fd < 0) {
 /*           let ee = errno
            let ef = strerror(ee)
            let g = String(cString: ef!)
   */
            ret = 1
            if (!opts.qflag) {
              warn("mkstemp failed on \(name!)")
            }
          } else {
            close(fd)
            if opts.uflag {
              unlink($0)
            }
            print(name!)
          }
        }
      }
      name = nil;
    }
    if ret != 0 {
      throw CmdErr(Int(ret))
    }
  }
  
  var usage = """
usage: mktemp [-d] [-p tmpdir] [-q] [-t prefix] [-u] template ..."
       mktemp [-d] [-p tmpdir] [-q] [-u] -t prefix")
"""
}
