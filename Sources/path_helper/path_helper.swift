
// Generated by Robert M. Lefkowitz <r0ml@liberally.net> in 2024 using ChatGPT
// from a file containing the following notice:

/*
 * Copyright (c) 2008 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */

import CMigration

@main final class path_helper : ShellCommand {
  enum Style {
    case csh
    case sh
  }
  
  struct CommandOptions {
    var style: Style = .sh
    
    var args = [String]()
  }
  
  var usage = "usage: path_helper [-c | -s]"

  func append_path_segment(path: inout String?, segment: String?) {
    guard path != nil, let segment else {
      return
    }
    
    let pathlen = path!.count
    let seglen = segment.count
    
    if seglen == 0 {
      return
    }
    
    var match = path!.firstRange(of: segment)
    while let range = match {
      if (path!.startIndex == range.lowerBound || path![path!.index(before: range.lowerBound)] == ":") &&
          ( path!.index(range.lowerBound, offsetBy: seglen) == path!.endIndex ||
            (path![path!.index(range.lowerBound, offsetBy: seglen)] == ":" )
)
      {
        return
      }
      
      // FIXME: this is a Kludge to find multiple segments
      match = (path![path!.startIndex..<range.lowerBound]
      + String(repeating: " ", count: path![range.lowerBound..<range.upperBound].count)
      +         path![range.upperBound...])
      .firstRange(of: segment)
    }
    
    //    let size = pathlen + seglen + 2
    
    if pathlen > 0 {
      path!.append(":")
    }
    path!.append(segment)
    return
  }
  
  func read_segment(line: String) -> String {
    var segment = ""
    
    for c in line {
      if c == "\"" || c == "\'" || c == "$" {
        segment.append("\\")
        segment.append(c)
      } else if c == "\n" {
        break
      } else {
        segment.append(c)
      }
    }
    return segment
  }
  
  // Construct a path variable, starting with the contents
  // of the given environment variable, adding the contents
  // of the default file and files in the path directory.
  func construct_path(_ env_var: String, _ defaults_path: String, _ dir_path: String) -> String? {
    
    var result : String? = ""
    var dirpathv: [String?] = [defaults_path, dir_path]
    
    if let root = getenv("PATH_HELPER_ROOT") {
      dirpathv[0] = root + defaults_path
      dirpathv[1] = root + dir_path
    }
    
    var ddv = dirpathv.map { strdup($0) }
    ddv.append(UnsafeMutablePointer<CChar>(bitPattern: 0))
    
    let fts = ddv.withUnsafeBufferPointer { p in
      fts_open(p.baseAddress, FTS_PHYSICAL | FTS_XDEV, find_compare)
    }
    if fts == nil {
      perror(dir_path)
      return nil
    }
    
    while let ent = fts_read(fts) {
      // only interested in regular files, one level deep
      if ent.pointee.fts_info != FTS_F {
        if ent.pointee.fts_level >= 1 {
          fts_set(fts, ent, FTS_SKIP)
        }
        continue
      }
      
      let f = fopen(ent.pointee.fts_accpath, "r")
      if f == nil {
        warn(String(cString: ent.pointee.fts_accpath) )
        continue
      }
      
      while true {
        var len: Int = 0
        if let line = fgetln(f, &len) {
          let segment = read_segment(line: String(cString: line) )
          append_path_segment(path: &result, segment: segment)
        } else {
          break
        }
        
      }
      
      fclose(f)
    }
    fts_close(fts)
    
    
    // merge in any existing custom PATH elements
    if let str = getenv(env_var) {
      let strx = str.split(separator: ":")
      for ss in strx {
        append_path_segment(path: &result, segment: String(ss) )
      }
    }
    return result
  }
  
  func parseOptions() throws(CmdErr) -> CommandOptions {
    
    var opts = CommandOptions()
    
    // default to csh style, if $SHELL ends with "csh".
    if let shell = getenv("SHELL") {
      if shell.contains(/csh/) {
        opts.style = .csh
      }
    }
    
    let go = BSDGetopt("cs")
    
    while let (ch, _) = try go.getopt() {
      switch ch {
      case "c":
          opts.style = .csh
      case "s":
          opts.style = .sh
      default:
        throw CmdErr(1)
      }
    }
    
    opts.args = go.remaining
    if opts.args.count > 0 {
      throw CmdErr(1)
    }
    return opts
  }
  
  func runCommand(_ opts : CommandOptions) throws(CmdErr) {
    let path = construct_path("PATH", "/etc/paths", "/etc/paths.d")
    var manpath: String?
    
    // only adjust manpath if already set
    let doManpath = getenv("MANPATH") != nil
    if doManpath {
      manpath = construct_path("MANPATH", "/etc/manpaths", "/etc/manpaths.d")
    }
    
    if opts.style == .csh {
      print("setenv PATH \"\(path!)\";")
      if doManpath {
        print("setenv MANPATH \"\(manpath ?? "")\";")
      }
    } else {
      print("PATH=\"\(path!)\"; export PATH;")
      if doManpath {
        print("MANPATH=\"\(manpath ?? ""):\"; export MANPATH;")
      }
    }
  }
}

// Sort FTS results in lexicographical order.
// from `find`
func find_compare(s1: UnsafeMutablePointer<UnsafePointer<FTSENT>?>?, s2: UnsafeMutablePointer<UnsafePointer<FTSENT>?>?) -> Int32 {
  // fts_name is defined as a char[1] -- but this is a lie.  It is really a string
  // to work around this, I need to get the pointer to fts_name as a (char *)

  let offset = MemoryLayout.offset(of: \FTSENT.fts_name)!

  let f1 = s1!.pointee!
  let f2 = UnsafeRawPointer(f1).assumingMemoryBound(to: CChar.self).advanced(by: offset)
  var ss1 = String(cString: f2)

//  print(mm)
  
/*  let ss1 = withUnsafePointer(to: s1!.pointee!.pointee.fts_name) { p in
    p.withMemoryRebound(to: CChar.self, capacity: Int(s1!.pointee!.pointee.fts_pathlen)) { pp in
      String(cString: pp)
    }
  }
  
  let ss2 = withUnsafePointer(to: s2!.pointee!.pointee.fts_name) { p in
    String(cString: p)
  }
*/
  
  let f3 = s2!.pointee!
  let f4 = UnsafeRawPointer(f3).assumingMemoryBound(to: CChar.self).advanced(by: offset)
  var ss2 = String(cString: f4)
  
  
  if let n1 = ss1.prefixMatch(of: /\d+/),
     let n2 = ss2.prefixMatch(of: /\d+/) {
    let e1 = Int(n1.output)!
    let e2 = Int(n2.output)!
    if e1 > e2 { return 1 }
    if e2 > e1 { return -1 }
    ss1 = String(ss1.dropFirst(n1.output.count))
    ss2 = String(ss2.dropFirst(n2.output.count))
  }
  
  //  let ss1 = String(cString: s1?.pointee.fts_name)
  //  let ss2 = String(cString: s2?.pointee.fts_name)
  
  if ss1 > ss2 { return -1 }
  else if ss1 < ss2 { return 1 }
  else { return 0 }
//  switch cc {
//  case .orderedSame: return 0
//  case .orderedAscending: return -1
//  case .orderedDescending: return 1
//  }
  
}


/*


func find_compare(_ s1: UnsafeMutablePointer<UnsafePointer<FTSENT>?>?, _ s2: UnsafeMutablePointer<UnsafePointer<FTSENT>?>?) -> Int32 {
    var e1: UnsafeMutablePointer<CChar>?
    var e2: UnsafeMutablePointer<CChar>?

    // check for numerical prefixes
  let s1s = s1!.pointee!.pointee.fts_name
  let s2s = s2!.pointee!.pointee.fts_name
  let n1 = withUnsafePointer(to: s1s) {
    strtol($0, &e1, 10)
  }
    
  let n2 = withUnsafePointer(to: s2s) {
    strtol($0, &e2, 10)
  }
  
    if e1 > s1s && e2 > s2s {
        // order by numerical prefix
        if n1 > n2 {
            return 1
        }
        if n2 > n1 {
            return -1
        }
        // if equal, order by remainder
        return strcoll(e1, e2)
    }
    return strcoll(s1.pointee.fts_name, s2.pointee.fts_name)
}

*/
