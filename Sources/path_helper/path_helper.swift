// Generated by Robert M. Lefkowitz <r0ml@liberally.net> in 2024 using ChatGPT
// from a file containing the following notice:

/*
 * Copyright (c) 2008 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */

import CMigration

@main final class path_helper : ShellCommand {
  enum Style {
    case csh
    case sh
  }
  
  struct CommandOptions {
    var style: Style = .sh
    
    var args = [String]()
  }

  var options : CommandOptions!

  var usage = "usage: path_helper [-c | -s]"

  func append_path_segment(path: inout String?, segment: String?) {
    guard path != nil, let segment else {
      return
    }
    
    let pathlen = path!.count
    let seglen = segment.count
    
    if seglen == 0 {
      return
    }
    
    var match = path!.firstRange(of: segment)
    while let range = match {
      if (path!.startIndex == range.lowerBound || path![path!.index(before: range.lowerBound)] == ":") &&
          ( path!.index(range.lowerBound, offsetBy: seglen) == path!.endIndex ||
            (path![path!.index(range.lowerBound, offsetBy: seglen)] == ":" )
)
      {
        return
      }
      
      // FIXME: this is a Kludge to find multiple segments
      match = (path![path!.startIndex..<range.lowerBound]
      + String(repeating: " ", count: path![range.lowerBound..<range.upperBound].count)
      +         path![range.upperBound...])
      .firstRange(of: segment)
    }
    
    //    let size = pathlen + seglen + 2
    
    if pathlen > 0 {
      path!.append(":")
    }
    path!.append(segment)
    return
  }
  
  func read_segment(line: String) -> String {
    var segment = ""
    
    for c in line {
      if c == "\"" || c == "\'" || c == "$" {
        segment.append("\\")
        segment.append(c)
      } else if c == "\n" {
        break
      } else {
        segment.append(c)
      }
    }
    return segment
  }
  
  // Construct a path variable, starting with the contents
  // of the given environment variable, adding the contents
  // of the default file and files in the path directory.
  func construct_path(_ env_var: String, _ defaults_path: String, _ dir_path: String) async throws(CmdErr) -> String? {

    var result : String? = ""
    var dirpathv: [String] = [defaults_path, dir_path]
    
    if let root = Environment["PATH_HELPER_ROOT"] {
      dirpathv[0] = root + defaults_path
      dirpathv[1] = root + dir_path
    }

    do {
      let fo = try FTSWalker(path: dirpathv, options: [.PHYSICAL, .XDEV], sort: find_compare)
      for var ent in fo {

        // only interested in regular files, one level deep
        if ent.info != FTSInfo.F {
          if ent.level >= 1 {
            ent.setAction(FTSAction.SKIP)
          }
        } else {
          do {
          let f = try FileDescriptor.open(ent.accpath, .readOnly)
            for try await line in f.bytes.lines {
                let segment = read_segment(line: line )
                append_path_segment(path: &result, segment: segment)
              }
            try? f.close()
          } catch(let e) {
            warn(ent.accpath)
            continue
          }

        }
      }

    } catch(let e) {
      throw CmdErr(1, "\(e)")
    }



    // merge in any existing custom PATH elements
    if let str = Environment[env_var] {
      let strx = str.split(separator: ":")
      for ss in strx {
        append_path_segment(path: &result, segment: String(ss) )
      }
    }
    return result
  }



  func parseOptions() throws(CmdErr) -> CommandOptions {
    
    var opts = CommandOptions()
    
    // default to csh style, if $SHELL ends with "csh".
    if let shell = Environment["SHELL"] {
      if shell.contains(/csh/) {
        opts.style = .csh
      }
    }
    
    let go = BSDGetopt("cs")
    
    while let (ch, _) = try go.getopt() {
      switch ch {
      case "c":
          opts.style = .csh
      case "s":
          opts.style = .sh
      default:
        throw CmdErr(1)
      }
    }
    
    opts.args = go.remaining
    if opts.args.count > 0 {
      throw CmdErr(1)
    }
    return opts
  }
  
  func runCommand() async throws(CmdErr) {

    let path = try await construct_path("PATH", "/etc/paths", "/etc/paths.d")
    var manpath: String?
    
    // only adjust manpath if already set
    let doManpath = Environment["MANPATH"] != nil
    if doManpath {
      manpath = try await construct_path("MANPATH", "/etc/manpaths", "/etc/manpaths.d")
    }
    
    if options.style == .csh {
      print("setenv PATH \"\(path!)\";")
      if doManpath {
        print("setenv MANPATH \"\(manpath ?? "")\";")
      }
    } else {
      print("PATH=\"\(path!)\"; export PATH;")
      if doManpath {
        print("MANPATH=\"\(manpath ?? ""):\"; export MANPATH;")
      }
    }
  }
}

/*
// Sort FTS results in lexicographical order.
// from `find`
func find_compare(_ s1: UnsafeMutablePointer<UnsafePointer<FTSENT>?>?, _ s2: UnsafeMutablePointer<UnsafePointer<FTSENT>?>?) -> Int32 {
  // fts_name is defined as a char[1] -- but this is a lie.  It is really a string
  // to work around this, I need to get the pointer to fts_name as a (char *)

  let offset = MemoryLayout.offset(of: \FTSENT.fts_name)!

  let f1 = s1!.pointee!
  let f2 = UnsafeRawPointer(f1).assumingMemoryBound(to: CChar.self).advanced(by: offset)
  var ss1 = String(cString: f2)

//  print(mm)
  
/*  let ss1 = withUnsafePointer(to: s1!.pointee!.pointee.fts_name) { p in
    p.withMemoryRebound(to: CChar.self, capacity: Int(s1!.pointee!.pointee.fts_pathlen)) { pp in
      String(cString: pp)
    }
  }
  
  let ss2 = withUnsafePointer(to: s2!.pointee!.pointee.fts_name) { p in
    String(cString: p)
  }
*/
  
  let f3 = s2!.pointee!
  let f4 = UnsafeRawPointer(f3).assumingMemoryBound(to: CChar.self).advanced(by: offset)
  var ss2 = String(cString: f4)
  
  
  if let n1 = ss1.prefixMatch(of: /\d+/),
     let n2 = ss2.prefixMatch(of: /\d+/) {
    let e1 = Int(n1.output)!
    let e2 = Int(n2.output)!
    if e1 > e2 { return 1 }
    if e2 > e1 { return -1 }
    ss1 = String(ss1.dropFirst(n1.output.count))
    ss2 = String(ss2.dropFirst(n2.output.count))
  }
  
  //  let ss1 = String(cString: s1?.pointee.fts_name)
  //  let ss2 = String(cString: s2?.pointee.fts_name)
  
  if ss1 > ss2 { return 1 }
  else if ss1 < ss2 { return -1 }
  else { return 0 }
//  switch cc {
//  case .orderedSame: return 0
//  case .orderedAscending: return -1
//  case .orderedDescending: return 1
//  }
  
}
*/


@Sendable func find_compare(_ a : FTSEntry, _ b : FTSEntry) -> ComparisonResult {
  var ss1 = a.name!
  var ss2 = b.name!

  if let n1 = ss1.prefixMatch(of: /\d+/),
     let n2 = ss2.prefixMatch(of: /\d+/) {
    let e1 = Int(n1.output)!
    let e2 = Int(n2.output)!
    if e1 > e2 {
//      os_log("path_helper descending \(e1) > \(e2)")
      return .orderedDescending }
    if e2 > e1 {
//      os_log("path_helper ascending \(e2) > \(e1)")
      return .orderedAscending }
    ss1 = String(ss1.dropFirst(n1.output.count))
    ss2 = String(ss2.dropFirst(n2.output.count))
  }

  //  let ss1 = String(cString: s1?.pointee.fts_name)
  //  let ss2 = String(cString: s2?.pointee.fts_name)

  if ss1 > ss2 {
//    os_log("path_helper descending \(ss1) > \(ss2)")
    return .orderedDescending }
  else if ss1 < ss2 {
//    os_log("path_helper ascending \(ss1) < \(ss2)")
    return .orderedAscending }
  else { return .orderedSame }
}



