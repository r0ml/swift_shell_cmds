
// Generated by Robert M. Lefkowitz <r0ml@liberally.net> in 2024 using ChatGPT
// from a file containing the following notice:

/*
 * SPDX-License-Identifier: BSD-3-Clause
 *
 * Copyright 2018 Staysail Systems, Inc. <info@staysail.tech>
 * Copyright 2014 Garrett D'Amore <garrett@damore.org>
 * Copyright 2010 Nexenta Systems, Inc.  All rights reserved.
 * Copyright (c) 1989, 1993
 *  The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

import CMigration
import CoreFoundation

#if SHELL
@_cdecl("printfcmd") public func printfcmd(_ argc : Int32, _ argv : UnsafeMutablePointer<UnsafeMutablePointer<CChar>?>) -> Int32 {
  var ss : [String] = []
  for i in 0..<Int(argc) {
    let p = String.init(utf8String: argv[i]!)!
    ss.append(p)
  }
  return printf().main(ArraySlice(ss) )
}
#endif

#if !SHELL
@main
#endif
class printf : ShellCommand {
  
  struct CommandOptions {
    var args : ArraySlice<String> = []
  }

//  var encoding : String.Encoding

  //  var myargv : ArraySlice<String> = []
//  var myargc : Int
  
  required init() {
#if !SHELL
setlocale(LC_ALL, "")
#endif

//    let d = getenv("LC_ALL") ?? getenv("LANG") ?? "en_US.UTF8"
//    let e = d.split(separator: ".").last ?? "UTF8"
//    let a = CFStringConvertIANACharSetNameToEncoding( e as CFString)
//    let b = CFStringConvertEncodingToNSStringEncoding(a)
//    encoding = String.Encoding(rawValue: b)
  }
  

  func parseOptions() throws(CmdErr) -> CommandOptions {
    var opts = CommandOptions()
    
    // FIXME: need to handle this case
    /*
     #if SHELL
     nextopt("")
     argc = Int32(argptr - argvx)
     argv = argptr
     
     #else
     */
    let go = BSDGetopt("")
    while let (ch, _) = try go.getopt() {
      switch ch {
      case "?":
        fallthrough
      default:
        throw CmdErr(1)
      }
    }
    //    #endif
    
    opts.args = ArraySlice(go.remaining)
    
    if opts.args.count < 1 {
      throw CmdErr(1)
    }
    
    return opts
  }
  
  func runCommand(_ optsx : CommandOptions) throws(CmdErr) {
    var opts = optsx
    let (_, format) = escape(opts.args.removeFirst(), 1) // backslash interpretation
    
    
//    var rval : Int = 0

    while true {
      var maxargv = opts.args
//      myargv = opts.args
//      myargc = args.count
      
      // Restart at the beginning of the format string.
      var fmt = Substring(format)
      var end = false
      var start = String(fmt)

      while !fmt.isEmpty {
        
        if fmt.first == "%" {
          print(start.prefix(start.count-fmt.count), terminator: "")
          if fmt.dropFirst().first == "%" {
            // %% prints a %
            print("%", terminator: "")
            fmt = fmt.dropFirst(2)
          } else {
            let fmtx = try printf_doformat(String(fmt), &opts)
            if let fmtx, fmtx != end_fmt {
              fmt = Substring(fmtx)
            }
            end = false
          }
          start = String(fmt)
//          fmt.removeFirst()
        } else {
          fmt.removeFirst()
        }
        if opts.args.count < maxargv.count {
          maxargv = opts.args
        }
      }
      opts.args = maxargv
      
      if end {
        throw CmdErr(1, "missing format character")
      }
      print(start, terminator: "")
      if opts.args.isEmpty { return }
      end = true
    }
  }
    
  let end_fmt = "end"
  
  
  
  
  /// implement the formatting following a %
  func printf_doformat(_ fmt: String /* , _ rval: inout Int */, _ opts : inout CommandOptions) throws(CmdErr) -> String? {
    
    
    
    let skip1 = "#'-+ 0"
    var fieldwidth: Int = 0
    var haveprec: Bool = false
    var havewidth: Bool = false
    var mod_ldbl: Bool = false
    var precision: Int = 0
    var fargv: ArraySlice<String>?
    
/*    let PF = { (_ f: String, _ _func: CVarArg) // _ havewidth: Bool, _ haveprec: Bool, _ fieldwidth: Int, _ precision: Int) in
      in
      if havewidth {
        if haveprec {
          print(String(format: f, fieldwidth, precision, _func), terminator: "")
        } else {
          print(String(format: f, fieldwidth, _func), terminator: "")
        }
      } else if haveprec {
        print(String(format: f, precision, _func), terminator: "")
      } else {
        
        let _ = _func.withCString { s in
          withVaList([s]) { p in
            vprintf(f, p)
          }
        }
        
//        print(String(format: f, _func), terminator: "")
      }
    }
  */
    
    func PF(_ f : String, _ _func: CVarArg) {
      if havewidth {
        if haveprec {
          print(cFormat(f, fieldwidth, precision, _func), terminator: "")
        } else {
          print(cFormat(f, fieldwidth, _func), terminator: "")
        }
      } else if haveprec {
        print(cFormat(f, precision, _func), terminator: "")
      } else {
        
        switch _func {
/*        case is String:
        let _ = (_func as! String).withCString { s in
          withVaList([s]) { p in
            vprintf(f, p)
          }
        }
 */
        default:
          let _ = withVaList([_func]) { p in
              vprintf(f, p)
            }
          }

//        print(String(format: f, _func), terminator: "")
      }

    }
    
    
    
    var start = "%"
    
    // drop the leading %
    var fmt = fmt.dropFirst()
    
    let l = fmt.prefix(while: { "0123456789".contains($0) }).count
    if l > 0 && fmt.dropFirst(l).first == "$" {
      let idx = Int(String(fmt.prefix(l)))!
      opts.args = opts.args.dropFirst(idx - 1)
      
      // FIXME: doesnt make sense to me
      //      if args > maxargv {
      //        maxargv = args
      //      }
      
      fmt = fmt.dropFirst(l + 1)
      fargv = opts.args
      
    } else {
      fargv = nil
    }
    
    while !fmt.isEmpty && skip1.contains(fmt.first!) {
      let c = fmt.removeFirst()
      start.append(c)
    }
    
    if fmt.hasPrefix("*") {
      fmt = fmt.dropFirst()
      let l = fmt.prefix(while: { "0123456789".contains($0) }).count
      if l > 0 && fmt.dropFirst(l).first == "$" {
        let idx = Int(String(fmt.prefix(l)))!
        if fargv == nil {
          throw CmdErr(1, "incomplete use of n$")
        }

        opts.args = opts.args.dropFirst(idx - 1)

        fmt = fmt.dropFirst(l + 1)
      } else if fargv != nil {
        throw CmdErr(1,"incomplete use of n$")
      }
      
      fieldwidth = try getint(&opts)
      
      // FIXME: this still makes no sense
      /*
       if args > maxargv {
       maxargv = args
       }
       */
      
      havewidth = true
      
      start.append("*")
    } else {
      havewidth = false
      
      while let c = fmt.first, "0123456789".contains(c) {
        start.append(c)
        fmt = fmt.dropFirst()
      }
    }
    
    if fmt.first == "." {
      fmt = fmt.dropFirst()
      start.append(".")
      
      if fmt.first == "*" {
        fmt = fmt.dropFirst()
        let l = fmt.prefix(while: { "0123456789".contains($0) }).count
        if l > 0 && fmt.dropFirst(l).first == "$" {
          let idx = Int(String(fmt.prefix(l)))!
          if fargv == nil {
            throw CmdErr(1, "incomplete use of n$")
          }
          
          opts.args = opts.args.dropFirst(idx - 1)

          fmt = fmt.dropFirst(l + 1)
        } else if fargv != nil {
          throw CmdErr(1, "incomplete use of n$")
        }
        
        precision = try getint(&opts)
        
        // FIXME: still making no sense
        //        if args > maxargv {
        //          maxargv = args
        //        }
        haveprec = true
        start.append("*")
      } else {
        haveprec = false
        
        while let c = fmt.first, "0123456789".contains(c) {
          start.append(c)
          fmt = fmt.dropFirst()
        }
      }
    } else {
      haveprec = false
    }
    if fmt.isEmpty {
      warnx("missing format character")
      return nil
    }
    if let c = fmt.first { start.append(c) }
    
    if fmt.first == "L" {
      mod_ldbl = true
      fmt = fmt.dropFirst()
      if let c = fmt.first, !"aAeEfFgG".contains(c) {
        warnx("bad modifier L for \(c)")
        return nil
      }
    } else {
      mod_ldbl = false
    }
    
    if fargv != nil {
      opts.args = fargv ?? []
    }
    
    let convch = fmt.removeFirst()

    switch convch {
    case "b":
      
      start = String(start.dropLast())
      start.append("s")
      let (getout, p) = escape(getstr(&opts), 0)
      // FIXME: does this mean isEmpty?
      if p.count == 1 && p.first == "\0" {
        print(p.first!, terminator: "")
      } else {
        p.withCString { PF(String(start), $0 ) }
      }
      
      if getout != 0 {
        return end_fmt
      }
    case "c":
      let p = getchr(&opts)
      if p != 0 {
        PF(String(start), p )
      }
    case "s":
      let p = getstr(&opts)
        p.withCString { PF(String(start), $0) }
    case "d", "i", "o", "u", "x", "X":
      var f: String?
//      var val: Int = 0
      let signedconv: Bool
      
      signedconv = (convch == "d" || convch == "i")
      f = mknum(String(start), convch)
      if f == nil {
        return nil
      }
      if signedconv {
        let v = try getnum(&opts)
        PF(f!, v)
      } else {
        let v = try getunum(&opts)
        PF(f!, v)
      }
    case "e", "E", "f", "F", "g", "G", "a", "A":
        let p = try getfloating(&opts)
        PF(String(start), p)

    default:
      throw CmdErr(1, "illegal format character \(convch)")
    }
    
    return String(fmt)
  }
  
  
  
  func mknum(_ str: String, _ ch: Character) -> String? {
    var copy: String = ""
    var copySize: Int = 0
    var newCopy: String
    var len: Int, newLen: Int
    
    len = str.count + 2
    if len > copySize {
      newLen = ((len + 1023) >> 10) << 10
      newCopy = String(repeating: " ", count: newLen)
      if newCopy.isEmpty {
        warnx(String(cString: strerror(ENOMEM)))
        return nil
      }
      copy = newCopy
      copySize = newLen
    }
    
    let index = str.index(str.startIndex, offsetBy: len - 3)
    copy = String(str[..<index])
    copy.append("j")
    copy.append(ch)
    return copy
  }
  
  func escape(_ fmtx: String, _ percent: Int) -> (Int, String) {

    var store = ""
    var fmt = Substring(fmtx)
    
    while !fmt.isEmpty {
      let c = fmt.removeFirst()
      if c != "\\" {
        store.append(c)
        continue
      }
      
      if fmt.isEmpty {
        store.append("\\")
        return (0, store)
      }
      
      let cc = fmt.removeFirst()
      switch cc {

      case "\\":
        store.append("\\")
      case "'":
        store.append("'")
      case "a": // bell/alert
        store.append("\u{07}")
        break
      case "b": // backspace
        store.append("\u{08}")
      case "c":
        if percent == 0 {
          return (1, store)
        }
        store.append("c")
      case "f":
        store.append("\u{0C}") // form-feed
      case "n":
        store.append("\n") // newline
      case "r":
        store.append("\r") // carriage return
      case "t":
        store.append("\t") // horizontal tab
      case "v":
        store.append("\u{0B}") // vertical tab
      default:
        if "01234567".contains(cc) {
          var c = (percent == 0 && cc == "0") ? 4 : 3
          var value = Int(String(cc))!
          while !fmt.isEmpty && "01234567".contains(fmt.first!)
                  && c > 0 {
//          for ( c-- && *fmt >= '0' && *fmt <= '7'; ++fmt) {
            value <<= 3;
            let dd = Int(String(fmt.removeFirst()))!
            value += dd
            c -= 1
          }
          
          // FIXME: do I need this?
//          --fmt;
          if ((percent != 0) && value == "%".first!.asciiValue!) {
            store.append("%%")
          } else {
            store.append(String(UnicodeScalar(value)!))
          }
        } else {
          store.append(cc)
        }
      }
    }
    return (0, store)
  }
  
  func getchr(_ opts : inout CommandOptions) -> Int {
    if opts.args.isEmpty {
      return 0
    }
    let char = opts.args.removeFirst()
    return Int(char.unicodeScalars.first!.value)
  }
  
  func getstr(_ opts : inout CommandOptions) -> String {
    if opts.args.isEmpty {
      return ""
    }
    return opts.args.removeFirst()
  }
  
  func getint(_ opts : inout CommandOptions) throws(CmdErr) -> Int {
    let val = try getnum(&opts)
    if val < Int.min || val > Int.max {
      throw CmdErr(1, "\(val): \(strerror(ERANGE)!)")
    }
    return val
  }
  
  func getunum(_ opts : inout CommandOptions) throws(CmdErr) -> UInt {
    if opts.args.isEmpty { return 0 }
    let ss = opts.args.removeFirst()
      if ss.first == "\"" || ss.first == "\'" {
        return UInt(asciicode(ss.dropFirst().first))
      }
    if let x = UInt(ss) {
        return x
      }
    throw CmdErr(1, "\(ss): expected numeric value")
  }
  
  func getnum(_ opts : inout CommandOptions) throws(CmdErr) -> Int {
    if opts.args.isEmpty { return 0 }
    let ss = opts.args.removeFirst()
      if ss.first == "\"" || ss.first == "\'" {
        return Int(asciicode(ss.dropFirst().first))
      }
    if let x = Int(ss) {
      return x
    }
      throw CmdErr(1, "\(ss): expected numeric value")
  }
  
  func getfloating(_ opts : inout CommandOptions) throws(CmdErr) -> Double {
    if opts.args.isEmpty { return 0 }
    let ss = opts.args.removeFirst()
    if ss.first == "\"" || ss.first == "\'" {
      return Double(asciicode(ss.dropFirst().first))
    }
        if let x = Double(ss) {
          return x
        }
          throw CmdErr(1, "\(ss): expected numeric value")
  }
  
  func asciicode(_ s : Character?) -> Int {
    guard let s else { return 0 }
    let ch = Int(s.unicodeScalars.first?.value ?? 0)
/*    if ch == 39 || ch == 34 {
      let s = args.first!.dropFirst()

      /*
      var mbs = mbstate_t()
      var wch = wchar_t()
      
      ch = s.withCString { p in
        let j = mbrtowc(&wch, p, Int(MB_LEN_MAX), &mbs )
        if j < 0 {
          wch = Int32(s.first!.asciiValue!)
        } else if j == 0 {
          wch = 0
        }
        return Int(wch)
      }
       */

     let sx = s.data(using: encoding)![0]
      ch = Int(sx)
    }
//    args.removeFirst()
 */
    return ch
  }
  
  var usage = "usage: printf format [arguments ...]"
}
