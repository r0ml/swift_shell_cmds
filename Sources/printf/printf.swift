
// Generated by Robert M. Lefkowitz <r0ml@liberally.net> in 2024 using ChatGPT
// from a file containing the following notice:

/*
 * SPDX-License-Identifier: BSD-3-Clause
 *
 * Copyright 2018 Staysail Systems, Inc. <info@staysail.tech>
 * Copyright 2014 Garrett D'Amore <garrett@damore.org>
 * Copyright 2010 Nexenta Systems, Inc.  All rights reserved.
 * Copyright (c) 1989, 1993
 *  The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

import CMigration

import ICU


@main class printf : ShellCommand {

  struct CommandOptions {
    var args : ArraySlice<String> = []
  }

  var options : CommandOptions!

  var mapping : [Character : Int] = [:]

  required init() {
    mapping = buildISOLatin1Mapping()
  }

  func parseOptions() throws(CmdErr) -> CommandOptions {
    var opts = CommandOptions()

    let go = BSDGetopt("")
    while let (ch, _) = try go.getopt() {
      switch ch {
      case "?":
        fallthrough
      default:
        throw CmdErr(1)
      }
    }

    opts.args = ArraySlice(go.remaining)
    
    if opts.args.count < 1 {
      throw CmdErr(1)
    }
    
    return opts
  }
  
  func runCommand() throws(CmdErr) {
    var opts = options!
    
    let (_, format) = escape(opts.args.removeFirst(), 1) // backslash interpretation

    while true {
      var maxargv = opts.args

      // Restart at the beginning of the format string.
      var fmt = Substring(format)
      var end = false
      var start = String(fmt)

      while !fmt.isEmpty {
        
        if fmt.first == "%" {
          print(start.prefix(start.count-fmt.count), terminator: "")
          if fmt.dropFirst().first == "%" {
            // %% prints a %
            print("%", terminator: "")
            fmt = fmt.dropFirst(2)
          } else {
            let fmtx = try printf_doformat(String(fmt), &opts)
            if let fmtx, fmtx != end_fmt {
              fmt = Substring(fmtx)
            }
            end = false
          }
          start = String(fmt)
        } else {
          fmt.removeFirst()
        }
        if opts.args.count < maxargv.count {
          maxargv = opts.args
        }
      }
      opts.args = maxargv
      
      if end {
        throw CmdErr(1, "missing format character")
      }
      print(start, terminator: "")
      if opts.args.isEmpty { return }
      end = true
    }
  }
    
  let end_fmt = "end"

  /// implement the formatting following a %
  func printf_doformat(_ fmt: String /* , _ rval: inout Int */, _ opts : inout CommandOptions) throws(CmdErr) -> String? {

    let skip1 = "#'-+ 0"
    var fieldwidth: Int = 0
    var haveprec: Bool = false
    var havewidth: Bool = false
    var precision: Int = 0
    var fargv: ArraySlice<String>?
    
    func PF(_ f : String, _ _func: CVarArg) {
      if havewidth {
        if haveprec {
          print(cFormat(f, fieldwidth, precision, _func), terminator: "")
        } else {
          print(cFormat(f, fieldwidth, _func), terminator: "")
        }
      } else if haveprec {
        print(cFormat(f, precision, _func), terminator: "")
      } else {
        print(cFormat(f, _func), terminator: "")
      }
    }

    var start = "%"
    
    // drop the leading %
    var fmt = fmt.dropFirst()
    
    let l = fmt.prefix(while: { "0123456789".contains($0) }).count
    if l > 0 && fmt.dropFirst(l).first == "$" {
      let idx = Int(String(fmt.prefix(l)))!
      opts.args = opts.args.dropFirst(idx - 1)

      fmt = fmt.dropFirst(l + 1)
      fargv = opts.args
      
    } else {
      fargv = nil
    }
    
    while !fmt.isEmpty && skip1.contains(fmt.first!) {
      let c = fmt.removeFirst()
      start.append(c)
    }
    
    if fmt.hasPrefix("*") {
      fmt = fmt.dropFirst()
      let l = fmt.prefix(while: { "0123456789".contains($0) }).count
      if l > 0 && fmt.dropFirst(l).first == "$" {
        let idx = Int(String(fmt.prefix(l)))!
        if fargv == nil {
          throw CmdErr(1, "incomplete use of n$")
        }

        opts.args = opts.args.dropFirst(idx - 1)

        fmt = fmt.dropFirst(l + 1)
      } else if fargv != nil {
        throw CmdErr(1,"incomplete use of n$")
      }
      
      fieldwidth = try getint(&opts)
      
      havewidth = true
      
      start.append("*")
    } else {
      havewidth = false
      
      while let c = fmt.first, "0123456789".contains(c) {
        start.append(c)
        fmt = fmt.dropFirst()
      }
    }
    
    if fmt.first == "." {
      fmt = fmt.dropFirst()
      start.append(".")
      
      if fmt.first == "*" {
        fmt = fmt.dropFirst()
        let l = fmt.prefix(while: { "0123456789".contains($0) }).count
        if l > 0 && fmt.dropFirst(l).first == "$" {
          let idx = Int(String(fmt.prefix(l)))!
          if fargv == nil {
            throw CmdErr(1, "incomplete use of n$")
          }
          
          opts.args = opts.args.dropFirst(idx - 1)

          fmt = fmt.dropFirst(l + 1)
        } else if fargv != nil {
          throw CmdErr(1, "incomplete use of n$")
        }
        
        precision = try getint(&opts)
        
        haveprec = true
        start.append("*")
      } else {
        haveprec = false
        
        while let c = fmt.first, "0123456789".contains(c) {
          start.append(c)
          fmt = fmt.dropFirst()
        }
      }
    } else {
      haveprec = false
    }
    if fmt.isEmpty {
      warnx("missing format character")
      return nil
    }
    if let c = fmt.first { start.append(c) }
    
    if fmt.first == "L" {
      fmt = fmt.dropFirst()
      if let c = fmt.first, !"aAeEfFgG".contains(c) {
        warnx("bad modifier L for \(c)")
        return nil
      }
    }

    if fargv != nil {
      opts.args = fargv ?? []
    }
    
    let convch = fmt.removeFirst()

    switch convch {
    case "b":
      
      start = String(start.dropLast())
      start.append("s")
      let (getout, p) = escape(getstr(&opts), 0)
      // FIXME: does this mean isEmpty?
      if p.count == 1 && p.first == "\0" {
        print(p.first!, terminator: "")
      } else {
        p.withCString { PF(String(start), $0 ) }
      }
      
      if getout != 0 {
        return end_fmt
      }
    case "c":
      let p = getchr(&opts)
      if p != 0 {
        PF(String(start), p )
      }
    case "s":
      let p = getstr(&opts)
        p.withCString { PF(String(start), $0) }
    case "d", "i", "o", "u", "x", "X":
      var f: String?
      let signedconv: Bool
      
      signedconv = (convch == "d" || convch == "i")
      f = mknum(String(start), convch)
      if f == nil {
        return nil
      }
      if signedconv {
        let v = try getnum(&opts)
        PF(f!, v)
      } else {
        let v = try getunum(&opts)
        PF(f!, v)
      }
    case "e", "E", "f", "F", "g", "G", "a", "A":
        let p = try getfloating(&opts)
        PF(String(start), p)

    default:
      throw CmdErr(1, "illegal format character \(convch)")
    }
    
    return String(fmt)
  }

  func mknum(_ str: String, _ ch: Character) -> String? {
    var copy: String = ""
    var copySize: Int = 0
    var newCopy: String
    var len: Int, newLen: Int
    
    len = str.count + 2
    if len > copySize {
      newLen = ((len + 1023) >> 10) << 10
      newCopy = String(repeating: " ", count: newLen)
      if newCopy.isEmpty {
        warnx(POSIXErrno(ENOMEM).description)
        return nil
      }
      copy = newCopy
      copySize = newLen
    }
    
    let index = str.index(str.startIndex, offsetBy: len - 3)
    copy = String(str[..<index])
    copy.append("j")
    copy.append(ch)
    return copy
  }
  
  func escape(_ fmtx: String, _ percent: Int) -> (Int, String) {

    var store = ""
    var fmt = Substring(fmtx)
    
    while !fmt.isEmpty {
      let c = fmt.removeFirst()
      if c != "\\" {
        store.append(c)
        continue
      }
      
      if fmt.isEmpty {
        store.append("\\")
        return (0, store)
      }
      
      let cc = fmt.removeFirst()
      switch cc {

      case "\\":
        store.append("\\")
      case "'":
        store.append("'")
      case "a": // bell/alert
        store.append("\u{07}")
        break
      case "b": // backspace
        store.append("\u{08}")
      case "c":
        if percent == 0 {
          return (1, store)
        }
        store.append("c")
      case "f":
        store.append("\u{0C}") // form-feed
      case "n":
        store.append("\n") // newline
      case "r":
        store.append("\r") // carriage return
      case "t":
        store.append("\t") // horizontal tab
      case "v":
        store.append("\u{0B}") // vertical tab
      default:
        if "01234567".contains(cc) {
          var c = (percent == 0 && cc == "0") ? 4 : 3
          var value = Int(String(cc))!
          while !fmt.isEmpty && "01234567".contains(fmt.first!)
                  && c > 0 {
            value <<= 3;
            let dd = Int(String(fmt.removeFirst()))!
            value += dd
            c -= 1
          }
          
          // FIXME: do I need this?
          if ((percent != 0) && value == "%".first!.asciiValue!) {
            store.append("%%")
          } else {
            store.append(String(UnicodeScalar(value)!))
          }
        } else {
          store.append(cc)
        }
      }
    }
    return (0, store)
  }
  
  func getchr(_ opts : inout CommandOptions) -> Int {
    if opts.args.isEmpty {
      return 0
    }
    let char = opts.args.removeFirst()
    return Int(char.unicodeScalars.first!.value)
  }
  
  func getstr(_ opts : inout CommandOptions) -> String {
    if opts.args.isEmpty {
      return ""
    }
    return opts.args.removeFirst()
  }
  
  func getint(_ opts : inout CommandOptions) throws(CmdErr) -> Int {
    let val = try getnum(&opts)
    if val < Int.min || val > Int.max {
      throw CmdErr(1, "\(val): \(POSIXErrno(ERANGE).description)")
    }
    return val
  }
  
  func getunum(_ opts : inout CommandOptions) throws(CmdErr) -> UInt {
    if opts.args.isEmpty { return 0 }
    let ss = opts.args.removeFirst()
      if ss.first == "\"" || ss.first == "\'" {
        return UInt(asciicode(ss.dropFirst().first))
      }
    if let x = UInt(ss) {
        return x
      }
    throw CmdErr(1, "\(ss): expected numeric value")
  }
  
  func getnum(_ opts : inout CommandOptions) throws(CmdErr) -> Int {
    if opts.args.isEmpty { return 0 }
    let ss = opts.args.removeFirst()
      if ss.first == "\"" || ss.first == "\'" {
        return Int(asciicode(ss.dropFirst().first))
      }
    if let x = Int(ss) {
      return x
    }
      throw CmdErr(1, "\(ss): expected numeric value")
  }
  
  func getfloating(_ opts : inout CommandOptions) throws(CmdErr) -> Double {
    if opts.args.isEmpty { return 0 }
    let ss = opts.args.removeFirst()
    if ss.first == "\"" || ss.first == "\'" {
      return Double(asciicode(ss.dropFirst().first))
    }
        if let x = Double(ss) {
          return x
        }
          throw CmdErr(1, "\(ss): expected numeric value")
  }


  func asciicode(_ s : Character?) -> Int {
    guard let s else { return 0 }

    // This deals with the ISOLatin1 problem
    if let sa = mapping[s] {
      return sa
    }

    // FIXME: if this character is a composite of multiple unicode scalars, it is not clear
    // what the value should be
    let ch = Int(s.unicodeScalars.first?.value ?? 0)
    return ch
  }
  
  var usage = "usage: printf format [arguments ...]"


  func buildISOLatin1Mapping() -> [Character : Int] {
    var mapping : [Character : Int] = [:]
    for i in 128..<256 {
      let k = Character(UnicodeScalar(i)!)
      mapping[k]=i
    }
    return mapping
  }


}
