
// Generated by Robert M. Lefkowitz <r0ml@liberally.net> in 2024 using ChatGPT
// from a file containing the following notice:

/*
 * SPDX-License-Identifier: BSD-3-Clause
 *
 * Copyright (c) 2010, 2012  David E. O'Brien
 * Copyright (c) 1980, 1992, 1993
 *  The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

import CMigration

let DEF_BUF = 65536

enum ScrDirection : UInt32 {
  case i = 105
  case o = 111
  case s = 115
  case e = 101
}

struct stamp {
  var scr_len : UInt64 = 0 /* amount of data */
  var scr_sec : UInt64 = 0 /* time it arrived in seconds... */
  var scr_usec : UInt32 = 0 /* ...and microseconds */
  var scr_direction : UInt32 = 0 /* 'i', 'o', etc (also indicates endianness) */
}

struct buf_elm {
  var rpos : size_t = 0
  var ibuf : Data = Data()
}



/*
static FILE *fscript;
static int master, slave;
static int child;
static const char *fname;
static char *fmfname;
#ifdef ENABLE_FILEMON
static int fflg
#endif
static int qflg, ttyflg;
static int usesleep, rawout, showexit;
static TAILQ_HEAD(, buf_elm) obuf_list = TAILQ_HEAD_INITIALIZER(obuf_list);

static struct termios tt;
*/

/*
#ifndef TSTAMP_FMT
/* useful for tool and human reading */
# define TSTAMP_FMT "%n@ %s [%Y-%m-%d %T]%n"
#endif
static const char *tstamp_fmt = TSTAMP_FMT;
static int tflg;

static void done(int) __dead2;
static void doshell(char **);
static void finish(void);
static void record(FILE *, char *, size_t, int);
static void consume(FILE *, off_t, char *, int);
static void playback(FILE *) __dead2;
static void usage(void);
*/

@main final class script : ShellCommand {
#if ENABLE_FILEMON
let optString = "adeFfkpqr"
#else
let optString = "adeFkpqr"
#endif

  var win = winsize()
//  var slave : Int32 = 0
//  var masterFH : FileHandle = FileHandle.standardOutput

  var fscript : FileDescriptor = FileDescriptor.standardOutput
  
  struct CommandOptions {
    var aflg = false
    var Fflg = false
    var kflg = false
    var pflg = false
    var qflg = false
    var tflg = false
    
    var tstamp_fmt = "%n@ %s [%Y-%m-%d %T]%n"
    
    
    var usesleep = true
    var rawout = false
    var flushtime = 30
    
    var args = [String]()
    var fname : String = ""
  }
  
  var obuf_list = [buf_elm]()
  
  var readstdin = true
  var start = time(nil)

    /*
     struct termios rtt, stt;
     struct winsize win;
     struct timeval tv, *tvp;
     time_t tvec, start;
     char obuf[BUFSIZ];
     char ibuf[BUFSIZ];
     fd_set rfd, wfd;
     struct buf_elm *be;
     ssize_t cc;
     int aflg, Fflg, kflg, pflg, ch, k, n, fcm;
     int flushtime, readstdin;
     #ifdef ENABLE_FILEMON
     int fm_fd, fm_log;
     #endif /* ENABLE_FILEMON */
     */

  func parseOptions() throws(CmdErr) -> CommandOptions {
    var opts = CommandOptions()
    
#if ENABLE_FILEMON
    fm_fd = -1;  /* Shut up stupid "may be used uninitialized" GCC
                  warning. (not needed w/clang) */
#endif /* ENABLE_FILEMON */
    
    let go = BSDGetopt("\(optString)T:t:")
    while let (ch, optarg) = try go.getopt() {
      //      let argc = CommandLine.argc
      //      let argv = CommandLine.unsafeArgv
      
      //      let chx = getopt(argc, argv, "\(optString)T:t:")
      //      if chx == -1 { break }
      //      let ch = UnicodeScalar(UInt32(chx))
      switch ch {
      case "a":
          opts.aflg = true
      case "d":
          opts.usesleep = false
      case "e":  /* Default behavior, accepted for linux compat */
        break
      case "F":
          opts.Fflg = true
#if ENABLE_FILEMON
      case "f":
          opts.fflg = true
#endif /* ENABLE_FILEMON */
      case "k":
          opts.kflg = true
      case "p":
          opts.pflg = true
      case "q":
          opts.qflg = true
      case "r":
          opts.rawout = true
      case "t":
          opts.flushtime = Int(atoi(optarg))
          if (opts.flushtime < 0) {
            err(1, "invalid flush time \(opts.flushtime)")
        }
      case "T":
          opts.tflg = true
          opts.pflg = true
        
        let oa = optarg
        if ((strchr(optarg, Int32("%".first!.asciiValue!))) != nil) {
          opts.tstamp_fmt = oa
        }
      case "?":
        fallthrough
      default:
        throw CmdErr(1)
      }
    }
    
    opts.args = go.remaining
    
    if opts.args.count > 0 {
      opts.fname = opts.args.removeFirst()
    } else {
      opts.fname = "typescript"
    }
    return opts
  }
  
  func runCommand(_ opts : CommandOptions) throws(CmdErr) {
    var fs : FileHandle?
    do {
      if opts.pflg {
        fs = FileHandle(forReadingAtPath: opts.fname)!
      } else {
        if !FileManager.default.fileExists(atPath: opts.fname) {
          FileManager.default.createFile(atPath: opts.fname, contents: nil)
        }
        fs = FileHandle(forWritingAtPath: opts.fname)!

        if opts.aflg { try fs?.seekToEnd() }
        else { try fs?.truncate(atOffset: 0) }
      }
    } catch(let e) {
      err(1, e.localizedDescription)
    }
    if let fs {
      fscript = fs
    } else {
      err(1, "unable to open \(opts.fname)")
    }
    
    /*
    if ((fscript = fopen(fname, pflg ? "r" : aflg ? "a" : "w")) == NULL) {
      err(1, "%s", fname);
    }
    */
    
    #if ENABLE_FILEMON
    if (fflg) {
      asprintf(&fmfname, "%s.filemon", fname);
      if (!fmfname) {
        err(1, "%s.filemon", fname);
      }
      if ((fm_fd = open("/dev/filemon", O_RDWR | O_CLOEXEC)) == -1) {
        err(1, "open(\"/dev/filemon\", O_RDWR)");
      }
      if ((fm_log = open(fmfname,
                         O_WRONLY | O_CREAT | O_TRUNC | O_CLOEXEC,
                         S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)) == -1) {
        err(1, "open(%s)", fmfname);
      }
      if (ioctl(fm_fd, FILEMON_SET_FD, &fm_log) < 0) {
        err(1, "Cannot set filemon log file descriptor");
      }
    }
#endif /* ENABLE_FILEMON */
    
    if (opts.pflg) {
      playback(fscript, opts);
    }
//    var master : Int32 = 0
    
  /*
    if (tcgetattr(STDIN_FILENO, &tt) == -1 ||
        ioctl(STDIN_FILENO, TIOCGWINSZ, &win) == -1) {

#if __APPLE__
      if (errno != ENOTTY) { /* For debugger. */
        err(1, "tcgetattr/ioctl");
      }
#else
      if (errno != ENOTTY && errno != ENODEV) { /* For debugger. */
        err(1, "tcgetattr/ioctl");
      }
#endif
    
      /* do I need master and slave? */
      /*
      if (openpty(&master, &slave, nil, nil, nil) == -1) {
        err(1, "openpty");
      }
    } else {
      if (openpty(&master, &slave, nil, &tt, &win) == -1) {
        err(1, "openpty");
      }
       */
      ttyflg = true
    }
    */
    
    /*
    var fcm = fcntl(master, F_GETFL);
    if (fcm == -1) {
      err(1, "master F_GETFL");
    }
    fcm |= O_NONBLOCK;
    if (fcntl(master, F_SETFL, fcm) == -1) {
      err(1, "master F_SETFL");
    }
    */
    
    if (opts.rawout) {
      record(fscript, Data(), .s);
    }
    
    var showexit = false

    if (!opts.qflg) {
      var tvec = time(nil);
      print("Script started, output file is \(opts.fname)")
      if (!opts.rawout) {
        let c = ctime(&tvec)!
        let cc = String(cString: c)
        print("Script started on \(cc)", terminator: "", to: &fscript)

        if let z = opts.args.first {
          showexit = true
          print("Command: ", terminator: "", to: &fscript)
          var ff = true
          for k in opts.args {
            let kk = ff ? "" : " "
            ff = false
            
            print("\(kk)\(k)", terminator: "", to: &fscript)
          }
          print("", to: &fscript)
        }
      }
      try? fscript.synchronize()

      #if ENABLE_FILEMON
      if (fflg) {
        printf("Filemon started, output file is %s\n",
                     fmfname);
      }
#endif /* ENABLE_FILEMON */
    }
    
    /*
    
    if (ttyflg) {
      var rtt = tt
      cfmakeraw(&rtt);
      rtt.c_lflag &= ~UInt(ECHO)
      tcsetattr(STDIN_FILENO, TCSAFLUSH, &rtt);
    }
    */
    
    
/*    child = fork();
    if (child < 0) {
      warn("fork");
      done(1);
    }
    if (child == 0) {
*/      #if ENABLE_FILEMON
      if (fflg) {
        var pid = getpid();
        if (ioctl(fm_fd, FILEMON_SET_PID, &pid) < 0) {
          err(1, "Cannot set filemon PID");
        }
      }
#endif /* ENABLE_FILEMON */
    let r = doshell(opts.args, opts)
//    }
//    close(slave)

    
    
    
    //    masterFH = FileHandle(fileDescriptor: master)
    
    // Launches the read-master task
//    let k = Task { await readMaster() }
    

    // FIXME: how does this work in Swift 6?
//    let j = Task { await self.readSlave() }

//    let kk = await j.value
//    finish();
    done(r, opts, showexit)
  }
  
  
  /*
  func readAndWrite() -> Bool {
    var tv = timeval()
    var tvp : timeval?
    var tvec = time(nil)

    var rfd = fd_set()
    var wfd = fd_set()
    
    FD_ZERO(&rfd)
    FD_ZERO(&wfd)
    FD_SET(master, &rfd)
    if (readstdin) {
      FD_SET(STDIN_FILENO, &rfd)
    }
    if !obuf_list.isEmpty {
      FD_SET(master, &wfd)
    }

    if (!readstdin && ttyflg) {
      tv.tv_sec = 1;
      tv.tv_usec = 0;
      tvp = tv
      readstdin = true
    } else if (flushtime > 0) {
      tv.tv_sec = flushtime - (tvec - start);
      tv.tv_usec = 0;
      tvp = tv
    } else {
      tvp = nil
    }
    

    /// `master + 1` is the same as `slave`
    var n : Int32
    if var tvp {
      n = withUnsafeMutablePointer(to: &tvp) { p in
        select(slave, &rfd, &wfd, nil, p)
      }
    } else {
      n = select(slave, &rfd, &wfd, nil, nil)
    }
    
    if (n < 0 && errno != EINTR) {
      return false;
    }
    

    if (n > 0 && FD_ISSET(master, &wfd) ) {
      while let be = obuf_list.first {
        
        let cc = be.ibuf.withUnsafeBytes { p in
          write(master, p.baseAddress, be.ibuf.count)
        }
          if (cc == -1) {
            if (errno == EWOULDBLOCK ||
                errno == EINTR) {
              break;
            }
            warn("write master");
            done(1);
          }
        
        if (cc == 0) {
          break; /* retry later ? */
        }
        
        var stt = termios()
        if (kflg && tcgetattr(master, &stt) >= 0 &&
            ((stt.c_lflag & UInt(ECHO) ) == 0)) {
          // FIXME: catch the try
          try! fscript.write(contentsOf: be.ibuf)
//            write(be.ibuf + be.rpos,
//                         1, cc, fscript);
        }
//          be.len -= cc;
//          if (be.len == 0) {
          obuf_list.removeFirst()
     //     TAILQ_REMOVE(&obuf_list, be, link);
     //     free(be);
//          } else {
//            be.rpos += cc;
//          }
      }
    }
    
     
    if (tvec - start >= flushtime) {
      try? fscript.synchronize()
      start = tvec;
    }
    if (Fflg) {
      try? fscript.synchronize()
    }

    return true
  }
  */
  
  
  /*
  func readMaster() async -> Bool {
      var isReading = true
      
      while isReading {
        let a = masterFH.availableData
        if a.count == 0 { isReading = false }
        FileHandle.standardOutput.write(a)
        if (rawout) {
          record(fscript, a, .o);
        } else {
          fscript.write(a)
        }
      }
      return true
  }
  */
  
  
  
  var usage : String { get  { return """
usage: script [-\(optString)] [-t time] [file [command ...]]
       script -p [-deq] [-T fmt] [file]
"""
  } }
  
  func finish() {
    var e : Int32
    var status : Int32
    
    fatalError("waitpid")
    // FIXME: put me back?
    /*
    if (waitpid(child, &status, 0) == child) {
      if (WIFEXITED(status)) {
        e = WEXITSTATUS(status);
      } else if (WIFSIGNALED(status)) {
        e = WTERMSIG(status);
      } else { /* can't happen */
        e = 1;
      }
      done(e);
    }
     */
  }
  
  func doshell(_ av : [String], _ opts : CommandOptions) -> Int32 {
    var env = getenv()
    
    var shell = env["SHELL"] ?? _PATH_BSHELL

//    close(master);
//    try? fscript.close()
//    free(fmfname);
    
//    login_tty(slave);
    
//    setenv("SCRIPT", fname, 1);
    env["SCRIPT"] = opts.fname
    let process = Process()
    process.arguments = Array(av.dropFirst())
    process.environment = env
    
    
    if let av0 = av.first {
      let ff = searchPath(for: av0)
      process.launchPath = ff!
      process.launch()
//      execvp(av0, av);
      warn(av0)
    } else {
      process.launchPath = shell
      process.arguments = ["-i"]
      
      process.launch()
//      execl(shell, shell, "-i", [] )
      warnx(shell)
      process.waitUntilExit()
      return process.terminationStatus
      
    }
    return 1
  }
  
  func done(_ eno : Int32, _ opts : CommandOptions, _ showexit : Bool) {
    var tvec = time_t()
    
    /*
    if (ttyflg) {
      tcsetattr(STDIN_FILENO, TCSAFLUSH, &tt);
    }
     */
    
    tvec = time(nil);
    if (opts.rawout) {
      record(fscript, Data(), .e);
    }
    if (!opts.qflg) {
      if (!opts.rawout) {
        if (showexit) {
          print("\nCommand exit status: \(eno)", terminator: "", to: &fscript)
        }
        let c = ctime(&tvec)!
        let cc = String(cString: c)
        print("\nScript done on \(cc)", terminator: "", to: &fscript)
      }
      print("\nScript done, output file is \(opts.fname)")
      #if ENABLE_FILEMON
      if (fflg) {
        printf("Filemon done, output file is %s\n",
                     fmfname);
      }
#endif /* ENABLE_FILEMON */
    }
    try? fscript.close()
//    try? masterFH.close()
 //   close(master);
    exit(eno);
  }
  
  func record(_ fp : FileDescriptor, _ buf : Data, _ direction : ScrDirection) {
    var iov = (iovec(), iovec() )
    var stampx = stamp()
    var tv = timeval()
    
    gettimeofday(&tv, nil)
    stampx.scr_len = UInt64(UInt(buf.count))
    stampx.scr_sec = UInt64(UInt(tv.tv_sec))
    stampx.scr_usec = UInt32(tv.tv_usec)
    stampx.scr_direction = direction.rawValue
    
/*
    iov.0.iov_len = MemoryLayout.size(ofValue: stampx)
    iov.0.iov_base = &stampx;
    iov.1.iov_len = cc;
    iov1.iov_base = buf;
*/
    
    do {
      try withUnsafeMutableBytes(of: &stampx) { p in
        try fp.write(contentsOf: Data(bytesNoCopy: p.baseAddress!, count: MemoryLayout<stamp>.size, deallocator: .none)
                 )
      }
      if buf.count > 0 { fp.write(buf) }
    } catch(let e) {
      err(1, e.localizedDescription)
    }
    
//    if (writev(fileno(fp), &iov.0, 2) == -1) {
//      err(1, "writev");
//    }
  }
  
  func consume(_ fp : FileDescriptor, _ lenx : UInt64, _ reg : Bool) -> Data {

    var len = lenx
    
    if (reg) {
      do {
        try fp.seek(toOffset: len + fp.offset() )
      } catch(let e) {
        err(1, e.localizedDescription)
      }
//      if (fseeko(fp, len, SEEK_CUR) == -1) {
//        err(1, "");
//      }
      return Data()
    }
    else {
      var res = Data()
      while (len > 0) {
//        let l = min(DEF_BUF, Int(len) );
        do {
          if let buf = try fp.read(upToCount: Int(len) ) {
            len = len - UInt64(buf.count)
            res.append(buf)
          } else {
            err(1, "cannot read buffer")
          }
        } catch(let e) {
//        if (fread(buf, sizeof(char), l, fp) != l) {
          err(1, "cannot read buffer");
        }
      }
      return res
      
    }
  }

  
  func swapstamp(_ stampx : inout stamp) {
    if (stampx.scr_direction > 0xff) {
      stampx.scr_len = stampx.scr_len.byteSwapped
      stampx.scr_sec = stampx.scr_sec.byteSwapped
      stampx.scr_usec = stampx.scr_usec.byteSwapped
      stampx.scr_direction = stampx.scr_direction.byteSwapped
    }
  }
    
    
    
  func readSlave(_ opts : CommandOptions) async -> Bool {
  //    let slaveFH = FileHandle.standardInput
  //    let slaveFH = FileHandle(fileDescriptor: slave)
    
      let slaveFH = FileDescriptor.standardInput
      var isReading = true
      //   var stt = termios()
      
      
      while isReading {
        let a = slaveFH.availableData
        print("slave: \(String(data: a, encoding: .ascii)!)")
        if a.count == 0 {
          isReading = false
          //        if (tcgetattr(masterFH.fileDescriptor, &stt) == 0 &&
          //            (stt.c_lflag & UInt(ICANON) ) != 0) {
          // VEOF is 0
          //          write(masterFH.fileDescriptor, &stt.c_cc, 1);
          //        }
          
        }
        
        if (opts.rawout) {
          record(fscript, a, .i);
        }
        FileDescriptor.standardOutput.write(a) // /* masterFH */ .write(a)
        
      }
      return true
  }


    
    
    
    func termset() {
     var traw = termios()
    
    if (tcgetattr(STDOUT_FILENO, &tt) == -1) {
#if __APPLE__
      if (errno != ENOTTY && errno != ENODEV) { /* For debugger. */
        err(1, "tcgetattr");
      }
#else
      if (errno != ENOTTY) { /* For debugger. */
        err(1, "tcgetattr");
      }

#endif
      return;
    }
    ttyflg = true
    traw = tt;
    cfmakeraw(&traw);
      traw.c_lflag |= UInt(ISIG);
    tcsetattr(STDOUT_FILENO, TCSANOW, &traw);
  }
  
  
  func playback(_ fp : FileDescriptor, _ opts : CommandOptions) {
    /*
     struct timespec tsi, tso;
     struct stamp stamp;
     struct stat pst;
     char buf[DEF_BUF];
     off_t nread, save_len;
     size_t l;
     time_t tclock;
     time_t lclock;
     int reg;
     */
    
    var stampx = stamp()
    var pst = stat()
    var tsi = timespec()
    var tso = timespec()
    var tclock : Int = time_t()
    var lclock : Int = time_t();

//    var buf : Data?
    
    if (fstat(fp.rawValue, &pst) == -1) {
      err(1, "fstat failed");
    }
    
    var reg = S_ISREG(pst.st_mode);
    
    
    var nread = Int64(0)
    
    while true {
      if reg && nread >= pst.st_size { break }
      //      for (nread = 0; !reg || nread < pst.st_size; nread += save_len) {
      
      var ss : Data?
      
      do {
        ss = try fp.read(upToCount: MemoryLayout<stamp>.size)
      } catch(let e) {
        err(1, "reading playback header: \(e.localizedDescription)")
      }
      //      if (fread(&stampx, sizeof(stampx), 1, fp) != 1) {
      
      // EOF?
      if ss == nil { break }
      
      if ss?.count != MemoryLayout<stamp>.size {
        if (reg) {
          err(1, "reading playback header");
        }
        else {
          break;
        }
      }
      var stampx = ss!.withUnsafeBytes { p in
        p.bindMemory(to: stamp.self)[0]
      }
      swapstamp(&stampx);
      var save_len = Int64(MemoryLayout.size(ofValue: stampx))
      
      if (reg && stampx.scr_len >
          (pst.st_size - save_len) - nread) {
        errx(1, "invalid stamp");
      }
      
      save_len += Int64(stampx.scr_len)
      tclock = Int(stampx.scr_sec)
      tso.tv_sec = Int(stampx.scr_sec)
      tso.tv_nsec = Int(stampx.scr_usec * 1000)
      if (nread == 0) {
        tsi = tso;
      }
        
      switch ScrDirection(rawValue: stampx.scr_direction) {
      case .s:
        
          if (!opts.qflg) {
          let c = ctime(&tclock)!
          let cc = String(cString: c)
          print("Script started on \(cc)", terminator: "")
        }
        tsi = tso;
        let _ = consume(fp, stampx.scr_len, reg);
        termset();
        atexit( termreset )
        break;
        
      case .e:
        
        termreset();
          if (!opts.qflg) {
          let c = ctime(&tclock)!
          let cc = String(cString: c)
          print("\nScript done on \(cc)", terminator: "")
        }
        let _ = consume(fp, stampx.scr_len, reg)

        break;
      case .i:
        /* throw input away */

        let _ = consume(fp, stampx.scr_len, reg);

        break;
      case .o:
          if (opts.tflg) {
          if (stampx.scr_len == 0) {
            continue;
          }
          if (tclock - lclock > 0) {
            
            let bb = withUnsafeTemporaryAllocation(byteCount: 256, alignment: 1) { p in
              let k = p.baseAddress!.assumingMemoryBound(to: CChar.self)
              let l = strftime(k, 256, opts.tstamp_fmt,
                           localtime(&tclock))
              let d = Data(bytesNoCopy: k, count: l, deallocator: .none)
              let bb = String(data: d, encoding: .ascii)
              return bb
            }
            print(bb!, terminator: "")
          }
          lclock = tclock;
        } else {
          tsi.tv_sec = tso.tv_sec - tsi.tv_sec;
          tsi.tv_nsec = tso.tv_nsec - tsi.tv_nsec;
          if (tsi.tv_nsec < 0) {
            tsi.tv_sec -= 1;
            tsi.tv_nsec += 1000000000;
          }
          if (opts.usesleep) {
            nanosleep(&tsi, nil)
          }
          tsi = tso;
        }
        while (stampx.scr_len > 0) {
//          let l = min(DEF_BUF, stampx.scr_len);
          
          do {
            if let bb = try fp.read(upToCount: Int(stampx.scr_len)) {
              FileDescriptor.standardOutput.write(bb)
              stampx.scr_len -= UInt64(bb.count);
            }

//            if (fread(buf, sizeof(char), l, fp) != l) {
//              err(1, "cannot read buffer");
//            }
          } catch(let e) {
            err(1, "cannot read buffer: \(e.localizedDescription)")
          }
          
        }
        break;
      default:
        errx(1, "invalid direction");
      }
    }
     
    try? fp.close()
    exit(0)
  }
  
}

func FD_SET(_ a : Int32, _ b : inout fd_set ) {
  __darwin_fd_set(a, &b)
}

func FD_ISSET(_ a : Int32, _ b : inout fd_set ) -> Bool {
  return __darwin_fd_isset(a, &b) != 0
}

func FD_ZERO(_ b : inout fd_set) {
  bzero(&b, MemoryLayout.size(ofValue:b))
}

func _WSTATUS(_ i : Int32) -> Int32 {
  return i & 0177
}

func WTERMSIG(_ i : Int32) -> Int32 {
  return _WSTATUS(i)
}

// =====================================

nonisolated(unsafe) var tt = termios()
nonisolated(unsafe) var ttyflg = false

func termreset() {
  if (ttyflg) {
    tcsetattr(STDOUT_FILENO, TCSADRAIN, &tt);
    ttyflg = false
  }
}
