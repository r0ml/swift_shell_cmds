
// Generated by Robert M. Lefkowitz <r0ml@liberally.net> in 2024 using ChatGPT
// from a file containing the following notice:

/*
 * SPDX-License-Identifier: BSD-2-Clause-NetBSD
 *
 * Copyright (c) 2005 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Brian Ginsbach.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

import Foundation
import shared

@main final class seq : ShellCommand {
  
  var opts = Option()
  var args : [String] = []
  
  func parseOptions() throws(shared.CmdErr) {
    let go = BSDGetopt_long(optstring, longOpts)
    while let (opt, optarg) = try go.getopt_long() {
      switch opt {
      case "f", "format":  /* format (plan9) */
        opts.format = optarg
        opts.equalWidth = false
      case "s", "separator":  /* separator (GNU) */
        opts.separator = unescape(optarg)
      case "t", "terminator":  /* terminator (new) */
        opts.terminator = unescape(optarg)
      case "w", "equal-width":  /* equal width (plan9) */
        if opts.format == nil {
          if opts.equalWidth {
            opts.pad = " ";
          }
          opts.equalWidth = true
        }
        
      case "h", "help":  /* help (GNU) */
        fallthrough
      default:
        throw CmdErr(1)
      }
    }
    
    args = go.remaining
    if args.count < 1 || args.count > 3 {
      throw CmdErr(1)
    }
  }
  
  
  var usage: String = "usage: seq [-w] [-f format] [-s string] [-t string] [first [incr]] last"
  
  
  func MAX(_ a: Double, _ b: Double) -> Double {
    return a < b ? b : a
  }
  
  func ISSIGN(_ c: Character) -> Bool {
    return String(c) == "-" || String(c) == "+"
  }
  
  func ISEXP(_ c: Character) -> Bool {
    return String(c) == "e" || String(c) == "E"
  }
  
  func ISODIGIT(_ c: Character) -> Bool {
    return Int(String(c))! >= 0 && Int(String(c))! <= 7
  }
  
  var decimal_point: String = "." // default
  var defaultFormat: String = "%g" // default
  
  struct Option {
    var format: String?
    var separator: String = "\n"
    var terminator: String?
    var equalWidth: Bool = false
    var pad : Character = "0"
  }
  
//  var options = Option(format: nil, separator: nil, terminator: nil, equalWidth: false)
  
  
  let decimalPoint: String = "." // default
  
  
  
  let optstring = "f:hs:t:w"
  let longOpts: [shared.option] = [
    shared.option("format", .required_argument),
    shared.option("separator", .required_argument),
    shared.option("terminator", .required_argument),
    shared.option("equal-width", .no_argument),
    shared.option("help", .no_argument),
    //      (nil, .noArgument, 0)
  ]
  
  
  /*
   func e_atof(_ str: String) -> Double {
   return Double(str)!
   }
   
   func decimal_places(_ str: String) -> Int {
   return str.components(separatedBy: ".").last!.count
   }
   */
  
  /*
   func numeric(_ str: String) -> Bool {
   return Double(str) != nil
   }
   
   func valid_format(_ str: String) -> Bool {
   return str.contains("%")
   }
   */
  
  
  /*
   * numeric - verify that string is numeric
   */
  func numeric(s: String) -> Bool {
    var s = s
    var seenDecimalPt = false
    let decimalPtLen = decimalPoint.count
    
    /* skip any sign */
    if ISSIGN(s.first!) {
      s.removeFirst()
    }
    
    while !s.isEmpty {
      if !s.first!.isWholeNumber {
        if !seenDecimalPt && s.hasPrefix(decimalPoint) {
          s.removeFirst(decimalPtLen)
          seenDecimalPt = true
          continue
        }
        if ISEXP(s.first!) {
          s.removeFirst()
          if ISSIGN(s.first!) || s.first!.isWholeNumber {
            s.removeFirst()
            continue
          }
        }
        break
      }
      s.removeFirst()
    }
    return s.isEmpty
  }
  
  /*
   * valid_format - validate user specified format string
   */
  func valid_format(_ fmtx: String) -> Bool {
    var fmt = fmtx
    var conversions = 0
    
    while !fmt.isEmpty {
      /* scan for conversions */
      if fmt.first! != "%" {
        fmt.removeFirst()
        continue
      }
      fmt.removeFirst()
      
      /* allow %% but not things like %10% */
      if fmt.first! == "%" {
        fmt.removeFirst()
        continue
      }
      
      /* flags */
      while !fmt.isEmpty && "#0- +'".contains(fmt.first!) {
        fmt.removeFirst()
      }
      
      /* field width */
      while !fmt.isEmpty && "0123456789".contains(fmt.first!) {
        fmt.removeFirst()
      }
      
      /* precision */
      if fmt.first! == "." {
        fmt.removeFirst()
        while !fmt.isEmpty && "0123456789".contains(fmt.first!) {
          fmt.removeFirst()
        }
      }
      
      /* conversion */
      switch fmt.first! {
      case "A", "a", "E", "e", "F", "f", "G", "g":
        /* floating point formats are accepted */
        conversions += 1
      default:
        /* anything else is not */
        return false
      }
    }
    
    /* PR 236347 -- user format strings must have a conversion */
    return conversions == 1
  }
  
  /*
   func unescape(_ str: String) -> String {
   return str.replacingOccurrences(of: "\\", with: "")
   }
   */
  
  
  /*
   * unescape - handle C escapes in a string
   */
  func unescape(_ oorig: String) -> String {
    var new = ""
    var orig = oorig
    while !orig.isEmpty {
      let cp = orig.removeFirst()
      if cp != "\\" {
        new.append(cp)
        continue
      }
      
      if orig.isEmpty {
        break
      }
      
      let ncp = orig.removeFirst()
      
      switch ncp {
      case "a":  /* alert (bell) */
        new.append("\u{07}")
      case "b":  /* backspace */
        new.append("\u{08}")
      case "e":  /* escape */
        new.append("\u{1B}")
      case "f":  /* formfeed */
        new.append("\u{0C}")
      case "n":  /* newline */
        new.append("\n")
      case "r":  /* carriage return */
        new.append("\r")
      case "t":  /* horizontal tab */
        new.append("\t")
      case "v":  /* vertical tab */
        new.append("\u{0B}")
      case "\\":  /* backslash */
        new.append( "\\")
      case "'":  /* single quote */
        new.append("'")
      case "\"":  /* double quote */
        new.append("\"")
      case "0", "1", "2", "3", "4", "5", "6", "7":  /* octal */
        var i = 0
        var c : Character = "\0"
        while i < 3 && !orig.isEmpty {
          i += 1
          let ch = orig.removeFirst()
          c = Character(UnicodeScalar(Int(c.asciiValue!) << 3 | Int(ch.asciiValue!) - 48)!)
        }
        new.append(c)
      case "x":  /* hexadecimal number */
        var i = 0
        var c : Character = "\0"
        while i < 2 && !orig.isEmpty {
          i += 1
          let ch = orig.removeFirst()
          c = Character(UnicodeScalar(Int(c.asciiValue!) << 4 | Int(ch.asciiValue!) - (ch.isNumber ? 48 : 55))!)
        }
        new.append(c)
      default:
        break
      }
    }
    
    return new
  }
  
  /*
   * e_atof - convert an ASCII string to a double
   *  exit if string is not a valid double, or if converted value would
   *  cause overflow or underflow
   */
  func e_atof(_ num: String) -> Double {
    guard let dbl = Double(num) else {
      fatalError("Invalid floating point argument: \(num)")
    }
    
    /* zero shall have no sign */
    if dbl == -0.0 {
      return 0
    }
    return dbl
  }
  
  /*
   * decimal_places - count decimal places in a number (string)
   */
  func decimal_places(number: String) -> Int {
    var places = 0
    
    /* look for a decimal point */
    if let dp = number.range(of: ".") {
      let decimalPart = number[dp.upperBound...]
      for char in decimalPart {
        if char.isNumber {
          places += 1
        }
      }
    }
    return places
  }
  
  func runCommand() throws(shared.CmdErr) {
    
    let last = e_atof(args.last!) // replace "1" with actual input
    
    var first : Double = 1
    var incr : Double = 0
    
    if args.count > 1 {
      first = e_atof(args[0])
    }
    
    if args.count > 2 {
      incr = e_atof(args[1])
      if incr == 0 {
        throw CmdErr(1, "zero \( first < last ? "in" : "de") crement")
      }
    }
    
    if incr == 0 {
      incr = first < last ? 1 : -1
    }
    
    if incr <= 0 && first < last {
      throw CmdErr(1, "needs positive incement")
    }
    
    if incr >= 0 && first > last {
      throw CmdErr(1, "needs negative decrement")
    }
    
    if var fmt = opts.format {
      if (!valid_format(fmt)) {
        throw CmdErr(1, "invalid format string: `\(fmt)'")
     }
      fmt = unescape(fmt)
      if (!valid_format(fmt)) {
        throw CmdErr(1, "invalid format string")
      }
      opts.format = fmt
    } else {
      opts.format = generate_format(first, incr, last, opts.equalWidth, opts.pad)
    }
    // More processing here
    
    for cur in stride(from: first, through: last, by: incr) {
      print(String(format: opts.format!, cur), terminator: opts.separator)
    }
    
    // More processing here
    
    if opts.terminator != nil {
      print("", terminator: opts.terminator!)
    }
  }
  
  /*
   * generateFormat - create a format string
   *
   * XXX to be bug for bug compatible with Plan9 and GNU return "%g"
   * when "%g" prints as "%e" (this way no width adjustments are made)
   */
  func generate_format(_ first: Double, _ incr: Double, _ lastx: Double, _ equalize: Bool, _ pad: Character) -> String {
    var buf = ""
    var cc: Character = "\0"
    var precision, width1, width2, places: Int
    
    if !equalize {
      return defaultFormat
    }
    
    var last = lastx
    
    /* figure out "last" value printed */
    if first > last {
      last = first - incr * floor((first - last) / incr)
    } else {
      last = first + incr * floor((last - first) / incr)
    }
    
    buf = String(format: "%g", incr)
    if buf.contains("e") {
      cc = "e"
    }
    precision = decimal_places(number: buf)
    
    width1 = buf.count
    if buf.contains("e") {
      cc = "e"
    }
    places = decimal_places(number: buf)
    if places > 0 {
      width1 -= (places + decimalPoint.count)
    }
    
    precision = max(places, precision)
    
    width2 = buf.count
    if buf.contains("e") {
      cc = "e"
    }
    places = decimal_places(number: buf)
    if places > 0 {
      width2 -= (places + decimalPoint.count)
    }
    
    if precision != 0 {
      buf = String(format: "%%%c%d.%d%c", [pad, max(width1, width2) + decimalPoint.count + precision, precision, (cc != "\0") ? cc : "f"])
    } else {
      buf = String.init(format: "%%%c%d%c", [pad, max(width1, width2), (cc != "\0") ? cc : "g"])
    }
    
    return buf
  }
}
