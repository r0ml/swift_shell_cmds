
// Generated by Robert M. Lefkowitz <r0ml@liberally.net> in 2024 using ChatGPT
// from a file containing the following notice:

/*
 * Copyright (c) 2006 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Erik E. Fair.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

import Foundation
import shared

@main class shlock {
  
  let LOCK_GOOD : Int32 = 0
  let LOCK_BAD : Int32 = 1
  
  let LOCK_SET : Int32 = 0
  let LOCK_FAIL : Int32 = 1

  var Debug = false
  var Pname : String = ""
  var file: String = ""
  var uucpstyle = false // indicating UUCP style locks

  required init() {}
  
  static func main() {
    let z = Self().main()
    exit(z)
  }
  
  func xtmpfile(_ file: String, _ pid: pid_t, _ uucpstyle: Bool) -> String? {
    let buf = "shlock\(getpid())"
    var tempname = file
    if let range = tempname.range(of: "/", options: .backwards) {
      tempname = tempname.prefix(upTo: range.upperBound).appending(buf)
    } else {
      tempname = buf
    }
    print("\(Pname): temporary filename: \(tempname)")
    
    let buf2 = "\(pid)"
    let len = buf2.count
    var fd: Int32
    repeat {
      fd = open(tempname, O_RDWR|O_CREAT|O_TRUNC|O_SYNC|O_EXCL, 0644)
      if fd == -1 {
        switch errno {
        case EEXIST:
          if unlink(tempname) == -1 {
            warn("unlink(\(tempname))")
            return nil
          }
        default:
          warn("open(\(tempname))")
          return nil
        }
      }
    } while fd == -1
    
    var pidx = pid
    if uucpstyle {
      if write(fd, &pidx, MemoryLayout<pid_t>.size) != MemoryLayout<pid_t>.size {
        print("write(\(tempname),\(pid))")
        close(fd)
        if unlink(tempname) == -1 {
          print("unlink(\(tempname))")
        }
        return nil
      }
    } else {
      if write(fd, buf2, len) != len {
        print("write(\(tempname),\(pid))")
        close(fd)
        if unlink(tempname) == -1 {
          print("unlink(\(tempname))")
        }
        return nil
      }
    }
    close(fd)
    return tempname
  }
  
  func p_exists(pid: pid_t) -> Bool {
    print("\(Pname): process \(pid) is ")
    if pid <= 0 {
      print("invalid")
      return false
    }
    if kill(pid, 0) == -1 {
      switch errno {
      case ESRCH:
        print("dead \(pid)")
        return false
      case EPERM:
        print("alive")
        return true
      default:
        print("state unknown: \(String(cString: strerror(errno)))")
        return true
      }
    }
    print("alive")
    return true
  }
  
  func cklock(_ file: String, _ st: inout stat?, _ uucpstyle: Bool) -> Bool {
    let fd = open(file, O_RDONLY)
    var pid: pid_t = 0
    
    print("\(Pname): checking extant lock <\(file)>")
    if fd == -1 {
      if errno != ENOENT {
        warn("open(\(file))")
      }
      return true
    }
    
    if st != nil && fstat(fd, &st!) == -1 {
      warn("stat(\(file))")
      close(fd)
      return true
    }
    
    var blx : Bool = true
    var buf = Data()
    
    if uucpstyle {
      let len = read(fd, &pid, MemoryLayout<pid_t>.size)
      blx = len != MemoryLayout<pid_t>.size
    } else {
      withUnsafeTemporaryAllocation(byteCount: Int(BUFSIZ), alignment: 1) { p in
        let len = read(fd, p.baseAddress!, Int(BUFSIZ) )
        if len > 0 {
          buf = Data(bytes: p.baseAddress!, count: len)
        }
        blx = len <= 0
      }
    }
    if blx {
      close(fd)
      print("\(Pname): lock file format error")
      return false
    }
    close(fd)
    
    let s = String(data: buf, encoding: .ascii) ?? ""
    return p_exists(pid: uucpstyle ? pid : pid_t( pid_t(s) ?? 0 ))
  }
  
  func mklock(file: String, pid: pid_t, uucpstyle: Bool) -> Bool {
    var tmp: String
    var retcode = false
    
    print("\(Pname): trying lock <\(file)> for process \(pid)")
    if let t = xtmpfile(file, pid, uucpstyle) {
      tmp = t
    } else {
      return false
    }
    
    
    
    
    
    var nx : Bool? = nil
    while link(tmp, file) == -1 {
      switch errno {
      case EEXIST:
        nx = doExist(tmp)
      default:
        warn("link(\(tmp), \(file))")
        nx = true
      }
    }
    
    
    if nx == nil {
      var sttmp = stat()
      if stat(tmp, &sttmp) == -1 {
        warn("stat(\(tmp))")
        nx = true
      } else if (sttmp.st_nlink == 2) {
        if Debug {
          print("\(Pname): got lock <\(file)>")
        }
        retcode = true
        nx = true
      }
    } else { nx = false }
    
    if let nx, !nx {
      let tmp2 = "\(tmp)-2"
      if unlink(tmp2) == -1 {
        warn("unlink(\(tmp2))")
      }
    }

    if unlink(tmp) == -1 {
      warn("unlink\(tmp))")
    }

    return retcode;
    
    
  }
  
  func doExist(_ tmp : String) -> Bool? {
    if (Debug) {
      warn("\(Pname): lock <\(file)> already exists")
      return true
    }
    
    var stlock = stat(), sttmp = stat(), stlock2 = stat()

    var s = Optional(stlock)
    if (cklock(file, &s, uucpstyle)) {
      if (Debug) { print("\(Pname): extant lock is valid") }
      return true
    }
    if let s { stlock = s }
    if stat(tmp, &sttmp) == -1 {
      warn("stat(\(tmp))")
      return true
    }
        /*
         * We need to take another lock against the lock
         * file to protect it against multiple removals
         */
        let tmp2 = "\(tmp)-2"
        if unlink(tmp2) == -1 && errno != ENOENT {
          warn("unlink(\(tmp2))")
          return true
        }
      if (stlock.st_ctime >= sttmp.st_ctime) {
        if Debug {
          print("\(Pname): lock time changed \(stlock.st_ctime) >= \(stlock2.st_ctime)")
          return true
        }
      }
        if (stlock.st_nlink != 1) {
          if (Debug) {
            print("\(Pname): someone else linked to it \(stlock.st_nlink)")
            return true
          }
        }
        if link(file, tmp2) == -1 {
          /* someone took our temp name! */
          warn("link(\(file), \(tmp2))")
          return false
        }
        if (stat(file, &stlock2) == -1) {
          warn("stat(\(file))")
          return false
        }
      if (stlock.st_ino != stlock2.st_ino) {
        if Debug {
          print("\(Pname): lock inode changed \(stlock.st_ino) != \(stlock2.st_ino)")
          return false
        }
      }
      if (stlock2.st_nlink != 2) {
        if Debug {
          print("\(Pname): someone else linked to it \(stlock2.st_nlink)")
          return false
        }
      }
        
      if Debug {
        print("\(Pname): lock is invalid, removing")
      }
       
      if unlink(file) == -1 {
        warn("unlink(\(file))")
        return false
      }
      if (unlink(tmp2) == -1) {
        return false
      }
      return nil
    }

  func bad_usage() {
    var fp = FileHandle.standardError
    print("\(Pname): USAGE: \(Pname) [-du] [-p PID] -f file", to: &fp)
    exit(LOCK_FAIL)
  }
  
  
  func main() -> Int32 {
    var pid: pid_t = 0
    var only_check = true // don't make a lock
    
    let a0 = CommandLine.arguments[0]
    
    Pname = a0.contains("/") ? a0.components(separatedBy: "/").last! : a0
    
    var args = CommandLine.arguments.dropFirst()
    while !args.isEmpty {
      let arg = args.removeFirst()
      if arg.hasPrefix("-") {
        switch arg.dropFirst().first {
        case "u":
          uucpstyle = true
        case "d":
          Debug = true
        case "p":
          if arg.count > 2 {
             pid = pid_t(arg.dropFirst(2) ) ?? 0
          } else {
            if args.isEmpty {
              bad_usage()
            }
            let z = args.removeFirst()
            pid = pid_t(z) ?? 0
          }
          only_check = false // wants one
        case "f":
          if arg.count > 2 {
            file = String(arg.dropFirst(2))
          } else {
            if arg.isEmpty {
              bad_usage()
              return 1
            }
            file = args.removeFirst()
          }
        default:
          bad_usage()
        }
      }
        }
    
    if file.isEmpty || (!only_check && pid <= 0) {
      bad_usage()
    }
    
    if only_check {
      var s : stat? = nil
      return cklock(file, &s, uucpstyle) ? LOCK_GOOD : LOCK_BAD
    }
    
    return mklock(file: file, pid: pid, uucpstyle: uucpstyle) ? LOCK_SET : LOCK_FAIL
  }

}
