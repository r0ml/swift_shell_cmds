
// Generated by Robert M. Lefkowitz <r0ml@liberally.net> in 2024 using ChatGPT
// from a file containing the following notice:

/*
 * test(1); version 7-like  --  author Erik Baalbergen
 * modified by Eric Gisin to be used as built-in.
 * modified by Arnold Robbins to add SVR3 compatibility
 * (-x -c -b -p -u -g -k) plus Korn's -L -nt -ot -ef and new -S (socket).
 * modified by J.T. Conklin for NetBSD.
 *
 * This program is in the Public Domain.
 */

import CMigration
import Darwin

func error(_ msg : String) {
  print(msg)
  exit(2)
}

func eaccess(_ path : String, _ mode : Int32) -> Int32 {
  return Darwin.faccessat(Darwin.AT_FDCWD, path, mode, Darwin.AT_EACCESS)
}

enum token_types : Int {
  case UNKNOWN = 0
  case UNOP = 0x100
  case BINOP = 0x200
  case BUNOP = 0x300
  case BBINOP = 0x400
  case PAREN = 0x500
}

enum token : Int {
  case EOI
  case OPERAND
  case FILRD = 0x101
  case FILWR
  case FILEX
  case FILEXIST
  case FILREG
  case FILDIR
  case FILCDEV
  case FILBDEV
  case FILFIFO
  case FILSOCK
  case FILSYM
  case FILGZ
  case FILTT
  case FILSUID
  case FILSGID
  case FILSTCK
  case STREZ
  case STRNZ
  case FILUID
  case FILGID
  case FILNT = 0x201
  case FILOT
  case FILEQ
  case STREQ
  case STRNE
  case STRLT
  case STRGT
  case INTEQ
  case INTNE
  case INTGE
  case INTGT
  case INTLE
  case INTLT
  case UNOT = 0x301
  case BAND = 0x401
  case BOR
  case LPAREN = 0x501
  case RPAREN
  
  var tokenType : token_types { get { TOKEN_TYPE(self) } }
}

struct t_op {
    var op_text: String
    var op_num: token
  
  init(_ a : String, _ b : token ) {
    op_text = a
    op_num  = b
  }
}

let ops1: [t_op] = [
  t_op( "=", .STREQ),
  t_op( "<", .STRLT),
  t_op( ">", .STRGT),
  t_op( "!", .UNOT),
  t_op( "(", .LPAREN),
  t_op( ")", .RPAREN)
]

let opsm1: [t_op] = [
  t_op("r", .FILRD),
  t_op("w", .FILWR),
  t_op("x", .FILEX),
  t_op("e", .FILEXIST),
  t_op("f", .FILREG),
  t_op("d", .FILDIR),
  t_op("c", .FILCDEV),
  t_op("b", .FILBDEV),
  t_op("p", .FILFIFO),
  t_op("u", .FILSUID),
  t_op("g", .FILSGID),
  t_op("k", .FILSTCK),
  t_op("s", .FILGZ),
  t_op("t", .FILTT),
  t_op("z", .STREZ),
  t_op("n", .STRNZ),
  t_op("h", .FILSYM),
  t_op("O", .FILUID),
  t_op("G", .FILGID),
  t_op("L", .FILSYM),
  t_op("S", .FILSOCK),
  t_op("a", .BAND),
  t_op("o", .BOR)
]

let ops2: [t_op] = [
  t_op("==", .STREQ),
  t_op("!=", .STRNE)
]

let opsm2: [t_op] = [
  t_op( "eq", .INTEQ),
  t_op( "ne", .INTNE),
  t_op( "ge", .INTGE),
  t_op( "gt", .INTGT),
  t_op( "le", .INTLE),
  t_op( "lt", .INTLT),
  t_op( "nt", .FILNT),
  t_op( "ot", .FILOT),
  t_op( "ef", .FILEQ)
]

func TOKEN_TYPE(_ t : token) -> token_types {
  return token_types(rawValue: t.rawValue & 0xff00)!
}

@main class test {

  var parenlevel = 0
  var t_wp : Array<String>.SubSequence = []
  var nargc : Int = 0
  
  required init() {}
  
  static func main() {
    let m = Self()
    let x = m.main(CommandLine.arguments)
    exit(x)
  }
  
  func main(_ argsa : [String] ) -> Int32 {
    var args = argsa
    
    var res: Bool
    var p: String
    
    if args.count == 0 {
      return 1
    }
    
    if let range = args[0].lastIndex(of: "/") {
      p = String(args[0][range...].dropFirst())
    } else {
      p = args[0]
    }
    
    if p == "[" {
      if args.last != "]" {
        print("missing ]")
      }
      args = args.dropLast()
    }
    
    if args.isEmpty { return 1 }
    
    t_wp = args.dropFirst()
    nargc = args.count - 1
    
    parenlevel = 0
    if nargc == 4 && t_wp.first! == "!" {
      nargc -= 1
      t_wp = t_wp.dropFirst()
      res = oexpr(t_lex(t_wp.first!))
    } else {
      res = !oexpr(t_lex(t_wp.first!))
    }
    
    nargc -= 1
    if nargc > 0 {
      print("\(t_wp.first!) unexpected operator")
    }
    
    return res ? 1 : 0
  }
  
  func syntax(op: String?, msg: String) {
    if let op = op, !op.isEmpty {
      error("\(op): \(msg)")
    } else {
      error("\(msg)")
    }
  }
  
  func oexpr(_ n: token) -> Bool {
    let res = aexpr(n: n)
    var tt : String?
    var bb : String?
    if nargc > 0 {
      nargc -= 1
      bb = t_wp.removeFirst()
      tt = t_wp.first
    }
    if t_lex(tt) == .BOR {
      if nargc > 0 {
        nargc -= 1
        t_wp = t_wp.dropFirst()
        tt = t_wp.first
      } else {
        tt = nil
      }
      return oexpr(t_lex(tt)) || res
    }
    if let bb { t_wp.insert(bb, at: t_wp.startIndex) }
    nargc += 1
    return res
  }
  
  func aexpr(n: token) -> Bool {
    let res = nexpr(n)
    var tt : String?
    var bb : String?
    
    if nargc > 0 {
      nargc -= 1
      bb = t_wp.removeFirst()
      tt = t_wp.first
    }
    if t_lex(tt) == .BAND {
      if nargc > 0 {
        nargc -= 1
        t_wp = t_wp.dropFirst()
        tt = t_wp.first
      } else {
        tt = nil
      }
      return aexpr(n: t_lex(tt)) && res
    }
    if let bb { t_wp.insert(bb, at: t_wp.startIndex) }
    nargc += 1
    return res
  }
  
  func nexpr(_ n : token) -> Bool {
    var tt : String?
    
    if n == .UNOT {
      if nargc > 0 {
        nargc -= 1
        t_wp = t_wp.dropFirst()
        tt = t_wp.first
      }
      return !nexpr( t_lex(tt))
    }
    return primary(n)
  }
  
  func primary(_ n: token) -> Bool {
    var res: Bool
    var tt : String?
    
    if n == .EOI {
      return false
    }
    if n == .LPAREN {
      parenlevel += 1
      if nargc > 0 {
        nargc -= 1
        t_wp = t_wp.dropFirst()
        tt = t_wp.first
      }
      let nn = t_lex(tt)
      if nn == .RPAREN {
        parenlevel -= 1
        return false
      }
      res = oexpr(nn)
      if nargc > 0 {
        nargc -= 1
        t_wp = t_wp.dropFirst()
        tt = t_wp.first
      } else {
        tt = nil
      }
      if t_lex(tt) != .RPAREN {
        syntax(op: nil, msg: "closing paren expected")
      }
      parenlevel -= 1
      return res
    }
    if n.tokenType == .UNOP {
      nargc -= 1
      if nargc == 0 {
        syntax(op: nil, msg: "argument expected")
      }
      switch n {
      case .STREZ:
        t_wp = t_wp.dropFirst()
        return t_wp.first!.count == 0
      case .STRNZ:
        t_wp = t_wp.dropFirst()
        return t_wp.first!.count != 0
      case .FILTT:
        t_wp = t_wp.dropFirst()
          return 0 != Darwin.isatty(Int32(getn(t_wp.first!)))
      default:
        t_wp = t_wp.dropFirst()
        return filstat(nm: t_wp.first!, mode: n)
      }
    }
    
    let nn = t_lex(nargc > 0 ? t_wp.dropFirst().first : nil)
    if nn.tokenType == .BINOP {
      return binop(n: nn)
    }
    
    return t_wp.first!.count > 0
  }
  
  func binop(n: token) -> Bool {
    let opnd1 = t_wp.first!
    var op : String? = nil
    if nargc > 0 {
      nargc -= 1
      t_wp = t_wp.dropFirst()
      op = t_wp.first
    }
    
    var opnd2 : String?
    if nargc > 0 {
      nargc -= 1
      t_wp = t_wp.dropFirst()
      opnd2 = t_wp.first
    }
    
    guard let opnd2 else {
      syntax(op: op, msg: "argument expected")
      return false
    }
    
    switch n {
    case .STREQ:
      return opnd1 == opnd2
    case .STRNE:
      return opnd1 != opnd2
    case .STRLT:
      return opnd1 < opnd2
    case .STRGT:
      return opnd1 > opnd2
    case .INTEQ:
      return intcmp(opnd1, opnd2) == 0
    case .INTNE:
      return intcmp(opnd1, opnd2) != 0
    case .INTGE:
      return intcmp(opnd1, opnd2) >= 0
    case .INTGT:
      return intcmp(opnd1, opnd2) > 0
    case .INTLE:
      return intcmp(opnd1, opnd2) <= 0
    case .INTLT:
      return intcmp(opnd1, opnd2) < 0
    case .FILNT:
      return newerf(opnd1, opnd2)
    case .FILOT:
      return olderf(opnd1, opnd2)
    case .FILEQ:
      return equalf(opnd1, opnd2)
    default:
      fatalError()
    }
  }
  
  func filstat(nm: String, mode: token) -> Bool {
    guard let s = try? FileMetadata(for: FilePath(nm), followSymlinks: !(mode == .FILSYM)) else {
      return false
    }
    
    switch mode {
    case .FILRD:
        return eaccess(nm, Darwin.R_OK) == 0
    case .FILWR:
        return eaccess(nm, Darwin.W_OK) == 0
    case .FILEX:
        if eaccess(nm, Darwin.X_OK) != 0 {
        return false
      }
        if s.filetype == .directory || Darwin.geteuid() != 0 {
        return true
      }
        return s.permissions.containsAny(of: [.ownerExecute, .groupExecute, .otherExecute])
    case .FILEXIST:
        return eaccess(nm, Darwin.F_OK) == 0
    case .FILREG:
        return s.filetype == .regular
    case .FILDIR:
        return s.filetype == .directory
    case .FILCDEV:
        return s.filetype == .characterDevice
    case .FILBDEV:
        return s.filetype == .blockDevice
    case .FILFIFO:
        return s.filetype == .fifo
    case .FILSOCK:
        return s.filetype == .socket
    case .FILSYM:
        return s.filetype == .symbolicLink
    case .FILSUID:
        return s.permissions.contains(.setUserID )
    case .FILSGID:
        return s.permissions.contains(.setGroupID )
    case .FILSTCK:
        return s.permissions.contains(.saveText)
    case .FILGZ:
        return s.size > 0
    case .FILUID:
      return s.userId == geteuid()
    case .FILGID:
      return s.groupId == getegid()
    default:
      return true
    }
  }
  
  
  func find_op_1char(_ ops: [t_op], _ c : String) -> token {
    for op in ops {
      if c == op.op_text {
        return op.op_num
      }
    }
    return .OPERAND
  }
  
  func find_op(_ s: String) -> token {
    if s.isEmpty {
      return .OPERAND
    } else if s.count == 1 {
      return find_op_1char( ops1, s)
    } else if s.count == 2 {
      return s.first == "-" ? find_op_1char(opsm1, String(s.dropFirst()) ) :
      find_op_1char(ops2, s)
    } else if s.count == 3 {
      return s.first == "-" ? find_op_1char(opsm2, String(s.dropFirst())) :
          .OPERAND
    } else {
        return .OPERAND
    }
  }
  
  func t_lex(_ s: String?) -> token {
    guard let s else {
      return .EOI
    }
    let num = find_op(s)
    if ((TOKEN_TYPE(num) == .UNOP || TOKEN_TYPE(num) == .BUNOP)
        && isunopoperand()) ||
        (num == .LPAREN && islparenoperand()) ||
        (num == .RPAREN && isrparenoperand()) {
      return .OPERAND
    }
    return num
  }
  
  func isunopoperand() -> Bool {
    if nargc == 1 {
      return true
    }
    
    let s = t_wp.dropFirst().first!
    
    if nargc == 2 {
      return parenlevel == 1 && s == ")"
    }
    
    let t = t_wp[t_wp.index(t_wp.startIndex, offsetBy: 2)]
    let num = find_op(s)
    return TOKEN_TYPE(num) == .BINOP &&
    (parenlevel == 0 || t != ")")
  }
  
  func islparenoperand() -> Bool {
    if nargc == 1 {
      return true
    }

    let s = t_wp.dropFirst().first!
    
    if nargc == 2 {
      return parenlevel == 1 && s == ")"
    }
    
    if nargc != 3 {
      return false
    }
    let num = find_op(s)
    return num.tokenType == .BINOP
  }
  
  func isrparenoperand() -> Bool {
    if nargc == 1 {
      return false
    }
    
    let s = t_wp.dropFirst().first
    if nargc == 2 {
      return parenlevel == 1 && s == ")"
    }
    return false
  }
  
  func getn(_ ss: String) -> Int {
    return ss.withCString { s in
      var p: UnsafeMutablePointer<CChar>?
      let r: Int = Darwin.strtol(s, &p, 10)
      
      if p == nil || s == p! {
        error("\(s): bad number")
      }
      
      if errno != 0 {
        error((errno == EINVAL) ? "\(s): bad number" :
                "\(s): out of range")
      }
      
      while Darwin.isspace(Int32(p!.pointee)) != 0 {
        p = p!.successor()
      }
      
      if p!.pointee != 0 {
        error("\(s): bad number")
      }
      
      return r
    }
  }
  
  func getq(_ ss: String) -> Int {
    let rr = ss.withCString {s in
      var p: UnsafeMutablePointer<CChar>?
      errno = 0
      let r = Darwin.strtoimax(s, &p, 10)
      
      if p == nil || s == p! {
        error("\(s): bad number")
      }
      
      if errno != 0 {
        error((errno == EINVAL) ? "\(s): bad number" :
                "\(s): out of range")
      }
      
      while Darwin.isspace(Int32(p!.pointee)) != 0 {
        p = p!.successor()
      }
      
      if p!.pointee != 0 {
        error("\(s): bad number")
      }
      return r
    }
    return rr
  }
  
  func intcmp(_ s1 : String, _ s2 : String) -> Int {
    let q1 = getq(s1)
    let q2 = getq(s2)
    
    if q1 > q2 {
      return 1
    }
    
    if q1 < q2 {
      return -1
    }
    
    return 0
  }
  
  func newerf(_ f1: String, _ f2: String) -> Bool {
    guard let b1 = try? FileMetadata(for: FilePath(f1), followSymlinks: true),
    let b2 = try? FileMetadata(for: FilePath(f2), followSymlinks: true)
    else {
      return false
    }
    
    if b1.lastModified > b2.lastModified {
      return true
    }
    return false
  }
  
  func olderf(_ f1: String, _ f2: String) -> Bool {
    return newerf(f2, f1)
  }
  
  func equalf(_ f1: String, _ f2: String) -> Bool {
    if let b1 = try? FileMetadata(for: FilePath(f1), followSymlinks: true ),
       let b2 = try? FileMetadata(for: FilePath(f2), followSymlinks: true ) {
      return b1.device == b2.device && b1.inode == b2.inode
    } else {
      return false
    }
  }
}
