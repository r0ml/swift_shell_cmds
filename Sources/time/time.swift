
// Generated by Robert M. Lefkowitz <r0ml@liberally.net> in 2024 using ChatGPT
// from a file containing the following notice:

/*
 * SPDX-License-Identifier: BSD-3-Clause
 *
 * Copyright (c) 1987, 1988, 1993
 *  The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

import Foundation
import CMigration

let PRIu64 = "u"

nonisolated(unsafe) var child_running = true

func child_handler(_ sig: Int32) {
  child_running = false
//  print("child")
  
}

nonisolated(unsafe) var siginfo_recvd = false

func siginfo(_ sig: Int32) {
  siginfo_recvd = true
}

// var sigmask = sigset_t()
// var suspmask = sigset_t()
// var origmask = sigset_t()

// ===================================

actor Stuff {
//  var pid : pid_t = -1
  var status : Int32 = 0
  var ru = Darwin.rusage()
  var rusage_ret : Int32 = 0
  var ruinfo = Darwin.rusage_info_v4()

  func w4(_ pid : Darwin.pid_t) -> Int32 {
    return Darwin.wait4(pid, &status, 0, &ru)
  }

  func lflagSetup(_ pid : pid_t) -> Int32 {
    withUnsafeMutableBytes(of: &ruinfo) {p in
      let qq = p.baseAddress
      let zz = qq!.assumingMemoryBound(to: rusage_info_t?.self)
      rusage_ret = Darwin.proc_pid_rusage(pid, RUSAGE_INFO_V4, zz)
    }
    return rusage_ret
  }
}


@main final class time : ShellCommand {
  var stuff = Stuff()

  struct CommandOptions {
    var decimal_point : Int8 = Int8(".".first!.asciiValue!)
    var pflag = false
    var hflag = false
    var lflag = false
    var aflag = false
    var ofn : String?

    var args : [String] = []
  }
  
  var xstatus : Int32 = 0
  var fh : FileHandle = FileHandle.standardOutput
  var before_ts = Darwin.timespec()
  var after = Darwin.timespec()
  
  var pid : pid_t = -1

  var usage = "usage: time [-al] [-h | -p] [-o file] utility [argument ...]"

  /*
   * Return the frequency of the kernel's statistics clock.
   */
  func getstathz() -> Int {
    
    var mib = [Darwin.CTL_KERN, Darwin.KERN_CLOCKRATE]
    return mib.withUnsafeMutableBufferPointer { mibp in
      var size = MemoryLayout<clockinfo>.size
      var clockrate = Darwin.clockinfo()
      if Darwin.sysctl(mibp.baseAddress, 2, &clockrate, &size, nil, 0) == -1 {
        err(1, "sysctl kern.clockrate")
      }
      return Int(clockrate.stathz)
    }
  }
  
  func humantime(out: FileHandle, sec: Int, centisec: Int, options opts : CommandOptions) {
    let days = sec / (60 * 60 * 24)
    let secx = sec % (60 * 60 * 24)
    let hrs = secx / (60 * 60)
    let secy = secx % (60 * 60)
    let mins = secy / 60
    let secz = secy % 60
    
    out.write("\t")
    if days != 0 {
      out.write("\(days)d")
    }
    if hrs != 0 {
      out.write("\(hrs)h")
    }
    if mins != 0 {
      out.write("\(mins)m")
    }
    out.write("\(secz)\(opts.decimal_point)\(String(format: "%02d", centisec))s")
  }
  
  func showtime(out: inout FileHandle, before: timespec, after: inout timespec, ru: rusage, options opts: CommandOptions) {
    
    after.tv_sec -= before.tv_sec
    after.tv_nsec -= before.tv_nsec
    if after.tv_nsec < 0 {
      after.tv_sec -= 1
      after.tv_nsec += 1000000000
    }
    
    if opts.pflag {
      print(String(format: "real %jd%c%02ld",
                   after.tv_sec, opts.decimal_point, after.tv_nsec/10000000), to: &out)
      print(String(format: "user %jd%c%02ld",
                   ru.ru_utime.tv_sec, opts.decimal_point,
                   ru.ru_utime.tv_usec/10000), to: &out)
      print(String(format: "sys %jd%c%02ld",
                   ru.ru_stime.tv_sec, opts.decimal_point,
                   ru.ru_stime.tv_usec/10000), to: &out)
    } else if opts.hflag {
      humantime(out: out, sec: Int(after.tv_sec), centisec: Int(after.tv_nsec/10000000), options: opts)
      print(" real\t", terminator: "", to: &out)
      humantime(out: out, sec: Int(ru.ru_utime.tv_sec), centisec: Int(ru.ru_utime.tv_usec)/10000, options: opts)
      
      print(" user\t", terminator: "", to: &out)
      
      humantime(out: out, sec: Int(ru.ru_stime.tv_sec), centisec: Int(ru.ru_stime.tv_usec)/10000, options: opts)
      print(" sys\n", to: &out)
    } else {
      print(String(format: "%9jd%c%02ld real ",
                   after.tv_sec, opts.decimal_point,
                   after.tv_nsec/10000000), terminator: "", to: &out)
      print(String(format: "%9jd%c%02ld user ",
                   ru.ru_utime.tv_sec, opts.decimal_point,
                   ru.ru_utime.tv_usec/10000), terminator: "", to: &out)
      print(String(format: "%9jd%c%02ld sys",
                   ru.ru_stime.tv_sec, opts.decimal_point,
                   ru.ru_stime.tv_usec/10000), to: &out)
    }
  }
  
  
  // =========================================================================
  

  func parseOptions() throws(CmdErr) -> CommandOptions  {
    //    let argc = CommandLine.argc
    //    let argv = CommandLine.unsafeArgv
    
    /*    int aflag, ch, lflag, status, rusage_ret = -1;
     int exitonsig;
     pid_t pid;
     struct rlimit rl;
     struct rusage ru;
     struct rusage_info_v4 ruinfo;
     sigset_t sigmask, suspmask, origmask;
     struct timespec after;
     char *ofn = NULL;
     FILE *out = stderr;
     */
    
    var opts = CommandOptions()
    Darwin.setlocale(Darwin.LC_NUMERIC, "")
    opts.decimal_point = localeconv().pointee.decimal_point[0]
    
    let go = BSDGetopt("ahlo:p")
    while let (ch, optarg) = try go.getopt() {
      switch ch {
      case "a":
          opts.aflag = true
        break;
      case "h":
          opts.hflag = true
        break;
      case "l":
          opts.lflag = true
        break;
      case "o":
          opts.ofn = optarg
        break;
      case "p":
          opts.pflag = true
        break;
      case "?":
        fallthrough
      default:
        throw CmdErr(1)
      }
    }
    opts.args = go.remaining
    return opts
  }
  
  func runCommand(_ opts : CommandOptions) async throws(CmdErr) {
    if opts.args.count == 0 { return }
  
    /* r0ml: Supposing I get rid of all this muck
    sigemptyset(&sigmask)
    /*
     * Block SIGCHLD so that the check for `child_running` doesn't miss the
     * handler before calling `sigsuspend` and blocking forever.
     */
     Darwin.sigaddset(&sigmask, Darwin.SIGCHLD);
     Darwin.sigprocmask(Darwin.SIG_BLOCK, &sigmask, &origmask);
    
    /*
     * Ensure child signals are handled by the parent prior to fork; otherwise,
     * they could be missed between the child forking and calling `sigsuspend`.
     */
     */
    Darwin.signal(Darwin.SIGCHLD, child_handler);
    /*
    sigemptyset(&suspmask);
    
    var out : UnsafeMutablePointer<FILE>?
    */
    if let ofn = opts.ofn {
      if !FileManager.default.fileExists(atPath: ofn) {
        FileManager.default.createFile(atPath: ofn, contents: Data() )
      }
      fh = FileHandle(forWritingAtPath: ofn)!
    } else {
      fh = FileHandle.standardOutput
    }
    if opts.aflag { fh.seekToEndOfFile() }
    
    /* r0ml: switched to FileHandle?
    if let ofn {
      out = fopen(ofn, aflag ? "ae" : "we")
      if out == nil {
        err(1, ofn);
      }
      // unbuffered
      setvbuf(out, nil, _IONBF, 0);
    }
    */
    
    if (clock_gettime(CLOCK_MONOTONIC, &before_ts) != 0) {
      err(1, "clock_gettime")
    }
    /*
     * NB: Don't add anything between these two lines -- measurement is
     * happening now.
     */
    
//    var pid : pid_t = -1
//    var ru = rusage()
    
    if let ff = searchPath(for: opts.args[0]) {
      
      var sigmask = sigset_t()
      var origmask = sigset_t()
      
      sigemptyset(&sigmask);
      /*
       * Block SIGCHLD so that the check for `child_running` doesn't miss the
       * handler before calling `sigsuspend` and blocking forever.
       */
      sigaddset(&sigmask, SIGCHLD);
      sigprocmask(SIG_BLOCK, &sigmask, &origmask);


      
      
      let process = Process()
      
      guard FileManager.default.isExecutableFile(atPath: ff) else {
        throw CmdErr(127, "\(ff) is not an executable")
      }
      
      process.launchPath = ff
      process.arguments = Array(opts.args.dropFirst())
      process.launch()
      
      pid = process.processIdentifier
      
      
/*      Task.detached {
        while true {
          let rr = await self.stuff.lflagSetup(self.pid)
          print("rr flag \(rr)")
          let k = await self.stuff.w4(self.pid)
          if k == self.pid /*|| k == -1 */ { break }
        }
      }
      await Task.yield()
  */
      

      
      /*
      var suspmask = sigset_t()
      sigemptyset(&suspmask)
      
      while child_running {
        sigsuspend(&suspmask)
      }
      */
      
//      process.waitUntilExit()

//      let ss = await stuff.lflagSetup(pid)
//      print("ss flag \(ss)")
        let _ = await self.stuff.w4(self.pid)
      /*
      if k == self.pid {
        print("pid yes")
      } else {
        print("pid no")
      }
      */
      process.waitUntilExit()

//      print("exited")
      xstatus = process.terminationStatus

    } else {
      err(1, "not found: \(opts.args[0])")
    }
    
    //      err(errno == ENOENT ? 127 : 126, args.first! );
    /* NOTREACHED */
    
    /*
     * Let the child handle signals that normally exit.
     */
    
/* r0ml: more muck to get rid of
 signal(SIGINT, SIG_IGN)
    signal(SIGQUIT, SIG_IGN)
    siginfo_recvd = false
    signal(SIGINFO, siginfo)
    siginterrupt(SIGINFO, 1)
    
    while (child_running) {
      if (siginfo_recvd) {
        siginfo_recvd = false
        if ((clock_gettime(CLOCK_MONOTONIC, &after)) != 0) {
          err(1, "clock_gettime");
        }
        var ru = rusage()
        getrusage(RUSAGE_CHILDREN, &ru);
        
        var so = FileHandle.standardOutput
        showtime(out: &so, before: before_ts, after: &after, ru: ru);
      }
      /*
       * This would be racy, but SIGCHLD is blocked above (as part of
       * `sigmask`).
       */
      sigsuspend(&suspmask);
    }
*/

    
    if ((clock_gettime(CLOCK_MONOTONIC, &after)) != 0) {
      err(1, "clock_gettime");
    }


/*
 var ruz = rusage()
    getrusage(RUSAGE_CHILDREN, &ruz);
    
    var so = FileHandle.standardOutput
    showtime(out: &so, before: before_ts, after: &after, ru: ruz);
*/
    
    
    
    /*
     * minimize what's added between these statements to preserve the
     * accuracy of the time measurement.
     */
    
    if ((clock_gettime(CLOCK_MONOTONIC, &after)) != 0) {
      err(1, "clock_gettime")
    }
    
//    var ruinfo = Optional(rusage_info_v4())
//    var rusage_ret : Int32 = 0
    
//    if (lflag) {
//      let tt = await stuff.lflagSetup(pid)
//      print("tt flag \(tt)")
//    }
    
    /*
     var ru = rusage()
     while true {
     let k = wait4(pid, &status, 0, &ru)
     if k == pid || k == -1 { break }
     }
     */
    
    if ( !WIFEXITED(xstatus)) {
      warnx("command terminated abnormally");
    }
    
      let ru = await stuff.ru
      let _ = await stuff.rusage_ret
//      print("stuff rusage \(rusage_ret)")
      let exitonsig : Int32 = WIFSIGNALED(xstatus) ? xstatus & 0x7f : 0;
    showtime(out: &fh, before: before_ts, after: &after, ru: ru, options: opts);
      
      
    if opts.lflag {
        
        await lflagPrint(&fh,
                         ru: ru,
                         rusage_ret: stuff.rusage_ret,
                         ruinfo: stuff.ruinfo )
      }
      
      
      
      
      /*
       * If the child has exited on a signal, exit on the same
       * signal, too, in order to reproduce the child's exit status.
       * However, avoid actually dumping core from the current process.
       */
      if exitonsig != 0 {
        Darwin.signal(exitonsig, Darwin.SIG_DFL)
        //      if (j == SIG_ERR) {
        //        warn("signal")
        //      } else {
        var rl = Darwin.rlimit()
        rl.rlim_max = 0
        rl.rlim_cur = 0
        if (Darwin.setrlimit(RLIMIT_CORE, &rl) == -1) {
          warn("setrlimit")
        }
        Darwin.kill(Darwin.getpid(), exitonsig);
        //      }
      }
      
    Darwin.exit (WIFEXITED(xstatus) ? WEXITSTATUS(xstatus) : Darwin.EXIT_FAILURE)
  }
  
  func lflagPrint(_ fh : inout FileHandle, ru : Darwin.rusage, rusage_ret : Int32, ruinfo : Darwin.rusage_info_v4 ) {
    let hz = getstathz()
    
    let kk = hz * (ru.ru_utime.tv_sec + ru.ru_stime.tv_sec)
    
    var ticks = kk + hz * Int((ru.ru_utime.tv_usec + ru.ru_stime.tv_usec)) / 1000000
    
    /*
     * If our round-off on the tick calculation still puts us at 0,
     * then always assume at least one tick.
     */
    if (ticks == 0) {
      ticks = 1
    }
    
    print(String(format: "%20ld  %@",
                 ru.ru_maxrss, "maximum resident set size"), to: &fh)
    print(String(format: "%20ld  %@",
                 ru.ru_ixrss / ticks, "average shared memory size"), to: &fh)
    print(String(format: "%20ld  %@",
                 ru.ru_idrss / ticks, "average unshared data size"), to: &fh)
    
    print(String(format: "%20ld  %@",
                 ru.ru_isrss / ticks, "average unshared stack size"), to: &fh)
    
    print(String(format: "%20ld  %@",
                 ru.ru_minflt, "page reclaims"), to: &fh)
    print(String(format: "%20ld  %@",
                 ru.ru_majflt, "page faults"), to: &fh)
    print(String(format: "%20ld  %@",
                 ru.ru_nswap, "swaps"), to: &fh)
    print(String(format: "%20ld  %@",
                 ru.ru_inblock, "block input operations"), to: &fh)
    print(String(format: "%20ld  %@",
                 ru.ru_oublock, "block output operations"), to: &fh)
    print(String(format: "%20ld  %@",
                 ru.ru_msgsnd, "messages sent"), to: &fh)
    print(String(format: "%20ld  %@",
                 ru.ru_msgrcv, "messages received"), to: &fh)
    print(String(format: "%20ld  %@",
                 ru.ru_nsignals, "signals received"), to: &fh)
    print(String(format: "%20ld  %@",
                 ru.ru_nvcsw, "voluntary context switches"), to: &fh)
    print(String(format: "%20ld  %@",
                 ru.ru_nivcsw, "involuntary context switches"), to: &fh)
    
    if (rusage_ret >= 0) {
      
      if (ruinfo.ri_instructions > 0) {
        print(String(format: "%20\(PRIu64)  %@", ruinfo.ri_instructions,
                     "instructions retired"), to: &fh)
      }
      
      if (ruinfo.ri_cycles > 0) {
        print(String(format: "%20\(PRIu64)  %@", ruinfo.ri_cycles,
                     "cycles elapsed"), to: &fh)
      }
      if (ruinfo.ri_lifetime_max_phys_footprint > 0) {
        print(String(format: "%20\(PRIu64)  %@",
                     ruinfo.ri_lifetime_max_phys_footprint,
                     "peak memory footprint"), to: &fh)
      }
    }
  }
}

