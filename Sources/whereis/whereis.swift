
// Generated by Robert M. Lefkowitz <r0ml@liberally.net> in 2024 using ChatGPT
// from a file containing the following notice:

/*
 * SPDX-License-Identifier: BSD-2-Clause-FreeBSD
 *
 * Copyright © 2002, Jörg Wunsch
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * 4.3BSD UI-compatible whereis(1) utility.  Rewritten from scratch
 * since the original 4.3BSD version suffers legal problems that
 * prevent it from being redistributed, and since the 4.4BSD version
 * was pretty inferior in functionality.
 */

// FIXME: deal with #ifndef __APPLE__ stuff
import CMigration

import Darwin


let NO_BIN_FOUND : Int32 = 1
let NO_MAN_FOUND : Int32 = 2
let NO_SRC_FOUND : Int32 = 4

let PATH_LIBEXEC = "/usr/libexec"


/* How to obtain the location of manpages, and how to match this result. */
let MANWHEREISMATCH = "^.* [(]source: (.*)[)]$"

// typealias ccharp = UnsafePointer<CChar>

func decolonify(_ s: String) -> [String] {
  return s.split(separator: ":").map { String($0) }
}

/*
 * Join string list `cpp' into a colon-separated string.
 */
func colonify(_ cpp: [String]) -> String {
  return cpp.joined(separator: ":")
}


@main final class Whereis : ShellCommand {
  
  var usage = "usage: whereis [-abmqu] [-BM dir ... -f] program ..."

  struct CommandOptions {
  var opt_a: Bool = false
  var opt_b: Bool = false
  var opt_m: Bool = false
  var opt_q: Bool = false
  var opt_u: Bool = false
  var bindirs: [String]? = nil
  var mandirs: [String]? = nil
  var query: [String] = []

    var unusual : Int32 = 0

  }
  
  
  
//  var re : Regex<String>
//  = Regex(MANWHEREISMATCH)
  /*
   var i: Int
   var printed: Int
   var bin: String?
   var buf = [CChar](repeating: 0, count: BUFSIZ)
   var cp: String?
   var cp2: String?
   var man: String?
   var name: String?
   var src: String?
   var dp: UnsafePointer<CChar>?
   var nlen: size_t
   var olen: size_t
   var s: size_t
   var sb = stat()
   var re = regex_t()
   var matches = [regmatch_t](repeating: regmatch_t(), count: 2)
   var rlen: regoff_t
   var p: UnsafeMutablePointer<FILE>?
   */
  
  func scanopts(_ opts : inout CommandOptions) throws(CmdErr) {
    // FIXME: where does this get used?
    var dirlist : [String]
    
//    let argc = CommandLine.argc
//    let argv = CommandLine.unsafeArgv
  
    let go = BSDGetopt("BMabfmqu")
    while let (ch, _) = try go.getopt() {
      switch ch {
      case "B":
          dirlist = opts.bindirs ?? []
        fallthrough
      case "M":
          dirlist = opts.mandirs ?? []
        fatalError("not yet implemented")
        // FIXME: put me back
        /*
        while optind < argc,
              let jj = argv[Int(optind)],
                let ao = Optional(String(cString: jj)),
              ao == "-f" || ao == "-B" || ao == "-M" {
          dirlist.append(contentsOf: decolonify(ao))
          optind += 1
        }
         */
      case "a":
          opts.opt_a = true
      case "b":
          opts.opt_b = true
      case "f":
        break
      case "m":
          opts.opt_m = true
      case "q":
          opts.opt_q = true
      case "u":
          opts.opt_u = true
      default:
        throw CmdErr(1)
      }
    }
    
    opts.query = go.remaining
    if opts.query.count == 0 {
      throw CmdErr(1)
    }
  }
  
  func parseOptions() async throws(CmdErr) -> CommandOptions {
    var opts = CommandOptions()

    try scanopts(&opts)
    await defaults(&opts)
    
    if opts.mandirs == nil {
      opts.opt_m = false
    }
    if opts.bindirs == nil {
      opts.opt_b = false
    }
    
    if !(opts.opt_m || opts.opt_b) {
      errx(Int(EX_DATAERR), "no directories to search")
    }
    
    if opts.opt_m {
      setenv("MANPATH", colonify(opts.mandirs!), 1)
//      re = try
//      if regcomp(&re, MANWHEREISMATCH, REG_EXTENDED) != 0 {
//        regerror(i, &re, buf, BUFSIZ - 1)
//        errx(EX_UNAVAILABLE, "regcomp(%s) failed: %s", MANWHEREISMATCH, buf)
//      }
    }
    
    return opts
    
  }
  

  func runCommand(_ optsx : CommandOptions) async throws(CmdErr) {
    var opts = optsx
    
    while let nam = opts.query.first {
      opts.query.removeFirst()
       var name = Substring(nam)
      
      if let x = name.lastIndex(of: "/") {
        name = name[x...]
      }
      
      if name.hasSuffix(".z") || name.hasSuffix(".Z") {
        name = name.dropLast(2)
      } else if name.hasSuffix(".gz") {
        name = name.dropLast(3)
      } else if name.hasSuffix(".bz2") {
        name = name.dropLast(4)
      }

      let namex = String(name)
      
      var bin : String? = nil
      var man : String? = nil
      //      s = strlen(name)
      
      if opts.opt_b {
        bin = do_optB(namex, &opts)
      }
      
      if opts.opt_m  {
        man = await do_optM(namex, &opts)
      }
      
      if opts.opt_u && opts.unusual == 0 {
        continue
      }
      
      var printed = 0
      if !opts.opt_q {
        Darwin.fputs("\(name):", Darwin.stdout)
        printed += 1
      }
      if let bin {
        if printed > 0 {
          Darwin.fputs(" ", Darwin.stdout)
        }
        Darwin.fputs(bin, Darwin.stdout)
        printed += 1
      }
      if let man {
        if printed > 0 {
          Darwin.fputs(" ", Darwin.stdout)
        }
        Darwin.fputs(man, Darwin.stdout)
        printed += 1
      }
      
      // FIXME: this is from #ifndef __APPLE__ stuff
      /*
       if let src {
       if printed > 0 {
       fputs(" ", stdout)
       }
       fputs(src, stdout)
       printed += 1
       }
       */
      
      if printed > 0 {
        Darwin.fputs("\n", Darwin.stdout)
      }
    }
    
    /*
     if opt_m {
     regfree(&re)
     }
     */
    
    Darwin.exit(0)
  }
  
  func do_optB(_ name : String, _ opts : inout CommandOptions) -> String? {
    opts.unusual = opts.unusual | NO_BIN_FOUND
    
    var bin : String?
    while let dp = opts.bindirs?.first {
      opts.bindirs?.removeFirst()
      let cp = "\(dp)/\(name)"
      var sb : stat! = stat()
      if stat(cp, &sb) == 0 && (sb.st_mode & S_IFMT) == S_IFREG && (sb.st_mode & (S_IXUSR | S_IXGRP | S_IXOTH)) != 0 {
        opts.unusual = opts.unusual & ~NO_BIN_FOUND
        if var bin {
          bin.append(" ")
          bin.append(cp)
        } else {
          bin = cp
        }
        if !opts.opt_a {
          break
        }
      }
    }
    return bin
  }
  
  func do_optM(_ name : String, _ opts : inout CommandOptions) async -> String? {
    opts.unusual = opts.unusual | NO_MAN_FOUND
    let cp = opts.opt_a ? ["-a","-w", name] : ["-S1:8:6", "-w", name]
//    let cpx = cp + ["-M", colonify(mandirs ?? [])]
    let res = try! ProcessRunner.run(command: "/usr/bin/man", arguments: cp)
    return res.stdout
  }
  
  
  /// Returns the output of running `executable` with `args`. Throws an error if the process exits indicating failure.
//  @discardableResult
//  func captureStdoutLaunch(_ executable: String, _ args: [String], _ input : String? = nil ) throws -> (Int32, String?, String?) {
    
    
    
//    let res = try ProcessRunner.run(command: executable, arguments: args)
    
//    let process = Process()
//    let output = Pipe()
//    let stderr = Pipe()
//    let inputs : Pipe? = if input != nil { Pipe() } else { nil }
//    let execu = executable
//    process.launchPath = execu
//    process.arguments = args
//    process.standardOutput = output
//    process.standardInput = inputs
//    process.standardError = stderr
//    process.launch()
    
//    if let inputs, let input {
//      Task.detached {
//        if let k = input.data(using: .utf8) {
//          inputs.fileHandleForWriting.write( k )
//        }
//        try? inputs.fileHandleForWriting.close()
//      }
//    }
    
//    process.waitUntilExit()
    
//    let k1 = String(data: output.fileHandleForReading.readDataToEndOfFile(), encoding: .ascii)
//    let k2 = String(data: stderr.fileHandleForReading.readDataToEndOfFile(), encoding: .ascii)
//    return (process.terminationStatus, k1, k2)
    

//      }
  
  /*
   * Provide defaults for all options and directory lists.
   */
  func defaults(_ opts : inout CommandOptions) async {
//      var s: Int
//      var b: String
  //    var buf = [Character](repeating: "\0", count: BUFSIZ)
//      var cp: String
//      var nele: Int
//      var p: UnsafeMutablePointer<FILE>?
//      var bindirs: [String?]
//      var mandirs: [String?]

      // default to -bm if none has been specified
    if !opts.opt_b && !opts.opt_m {
      opts.opt_b = true
      opts.opt_m = true
      }

      // -b defaults to default path + /usr/libexec + user's path
    if opts.bindirs == nil {
        var mib = [CTL_USER, USER_CS_PATH]
        var s : Int = 0
        if sysctl(&mib, 2, nil, &s, nil, 0) == -1 {
          err(1, "sysctl: user_cs_path")
        }
        if (s == 0) {
          err(1, "user_cs_path: sysctl: zero length\n")
        }
        
        let b = withUnsafeTemporaryAllocation(byteCount: s, alignment: 1) { b in
          if sysctl(&mib, 2, b.baseAddress, &s, nil, 0) == -1 {
              let sverrno = errno
              errno = sverrno
              err(1, "sysctl: user_cs_path");
            }
          let k = b.baseAddress?.assumingMemoryBound(to: UInt8.self)
          return String(cString: k!)
        }
          // Retrieve the standard path.
          // This part is system-specific and may not be directly translatable to Swift.
          // You would need to use a Swift or Objective-C API to get the system path.

      opts.bindirs = decolonify(b)
      opts.bindirs?.append(PATH_LIBEXEC)
          if let path = getenv("PATH") {
              // don't destroy the original environment...
            opts.bindirs?.append(contentsOf: decolonify(path))
          }
      }

      // -m defaults to $(manpath)
    if opts.mandirs == nil {
      
      /* How to query the current manpath. */
      let MANPATHCMD = ["manpath","-q"]
      do {
        let res = try ProcessRunner.run(command: "/usr/bin/manpath", arguments: MANPATHCMD)
        var b = Substring(res.stdout)
        if let x = b.lastIndex(of: "\n") {
          b = b[b.startIndex..<x]
        }
        opts.mandirs = decolonify(String(b))
      } catch {
        err( Int(EX_OSERR), "cannot execute manpath command")
      }
    }
  }
}
