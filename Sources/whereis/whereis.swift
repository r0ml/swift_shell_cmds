
// Generated by Robert M. Lefkowitz <r0ml@liberally.net> in 2024 using ChatGPT
// from a file containing the following notice:

/*
 * SPDX-License-Identifier: BSD-2-Clause-FreeBSD
 *
 * Copyright © 2002, Jörg Wunsch
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * 4.3BSD UI-compatible whereis(1) utility.  Rewritten from scratch
 * since the original 4.3BSD version suffers legal problems that
 * prevent it from being redistributed, and since the 4.4BSD version
 * was pretty inferior in functionality.
 */

// FIXME: deal with #ifndef __APPLE__ stuff
import Foundation
import shared

let NO_BIN_FOUND : Int32 = 1
let NO_MAN_FOUND : Int32 = 2
let NO_SRC_FOUND : Int32 = 4

let PATH_LIBEXEC = "/usr/libexec"


/* How to obtain the location of manpages, and how to match this result. */
let MANWHEREISMATCH = "^.* [(]source: (.*)[)]$"

// typealias ccharp = UnsafePointer<CChar>

func decolonify(_ s: String) -> [String] {
  return s.components(separatedBy: ":")
}

/*
 * Join string list `cpp' into a colon-separated string.
 */
func colonify(_ cpp: [String]) -> String {
  return cpp.joined(separator: ":")
}


@main final class Whereis : ShellCommand {
  
  var usage = "usage: whereis [-abmqu] [-BM dir ... -f] program ..."

  //  struct Options {
  var opt_a: Bool = false
  var opt_b: Bool = false
  var opt_m: Bool = false
  var opt_q: Bool = false
  var opt_u: Bool = false
  var bindirs: [String]? = nil
  var mandirs: [String]? = nil
  var query: [String] = []
  //  }
  
  
  
  var unusual : Int32 = 0
//  var re : Regex<String>
//  = Regex(MANWHEREISMATCH)
  /*
   var i: Int
   var printed: Int
   var bin: String?
   var buf = [CChar](repeating: 0, count: BUFSIZ)
   var cp: String?
   var cp2: String?
   var man: String?
   var name: String?
   var src: String?
   var dp: UnsafePointer<CChar>?
   var nlen: size_t
   var olen: size_t
   var s: size_t
   var sb = stat()
   var re = regex_t()
   var matches = [regmatch_t](repeating: regmatch_t(), count: 2)
   var rlen: regoff_t
   var p: UnsafeMutablePointer<FILE>?
   */
  
  func scanopts() throws(CmdErr) {
    var dirlist : [String]
    
//    let argc = CommandLine.argc
//    let argv = CommandLine.unsafeArgv
  
    let go = BSDGetopt("BMabfmqu")
    while let (ch, _) = try go.getopt() {
      switch ch {
      case "B":
        dirlist = bindirs ?? []
        fallthrough
      case "M":
        dirlist = mandirs ?? []
        fatalError("not yet implemented")
        // FIXME: put me back
        /*
        while optind < argc,
              let jj = argv[Int(optind)],
                let ao = Optional(String(cString: jj)),
              ao == "-f" || ao == "-B" || ao == "-M" {
          dirlist.append(contentsOf: decolonify(ao))
          optind += 1
        }
         */
      case "a":
        opt_a = true
      case "b":
        opt_b = true
      case "f":
        break
      case "m":
        opt_m = true
      case "q":
        opt_q = true
      case "u":
        opt_u = true
      default:
        throw CmdErr(1)
      }
    }
    
    query = go.remaining
    if query.count == 0 {
      throw CmdErr(1)
    }
  }
  
  func parseOptions() throws(CmdErr) {
    
    setlocale(LC_ALL, "")
    
    try scanopts()
    defaults()
    
    if mandirs == nil {
      opt_m = false
    }
    if bindirs == nil {
      opt_b = false
    }
    
    if !(opt_m || opt_b) {
      errx(Int(EX_DATAERR), "no directories to search")
    }
    
    if opt_m {
      setenv("MANPATH", colonify(mandirs!), 1)
//      re = try
//      if regcomp(&re, MANWHEREISMATCH, REG_EXTENDED) != 0 {
//        regerror(i, &re, buf, BUFSIZ - 1)
//        errx(EX_UNAVAILABLE, "regcomp(%s) failed: %s", MANWHEREISMATCH, buf)
//      }
    }
    
    
    
  }
  

  func runCommand() throws(CmdErr) {
    
    while let nam = query.first {
      query.removeFirst()
       var name = Substring(nam)
      
      if let x = name.lastIndex(of: "/") {
        name = name[x...]
      }
      
      if name.hasSuffix(".z") || name.hasSuffix(".Z") {
        name = name.dropLast(2)
      } else if name.hasSuffix(".gz") {
        name = name.dropLast(3)
      } else if name.hasSuffix(".bz2") {
        name = name.dropLast(4)
      }

      let namex = String(name)
      
      var bin : String? = nil
      var man : String? = nil
      //      s = strlen(name)
      
      if opt_b {
        bin = do_optB(namex)
      }
      
      if opt_m  {
        man = do_optM(namex)
      }
      
      if opt_u && unusual == 0 {
        continue
      }
      
      var printed = 0
      if !opt_q {
        fputs("\(name):", stdout)
        printed += 1
      }
      if let bin {
        if printed > 0 {
          fputs(" ", stdout)
        }
        fputs(bin, stdout)
        printed += 1
      }
      if let man {
        if printed > 0 {
          fputs(" ", stdout)
        }
        fputs(man, stdout)
        printed += 1
      }
      
      // FIXME: this is from #ifndef __APPLE__ stuff
      /*
       if let src {
       if printed > 0 {
       fputs(" ", stdout)
       }
       fputs(src, stdout)
       printed += 1
       }
       */
      
      if printed > 0 {
        fputs("\n", stdout)
      }
    }
    
    /*
     if opt_m {
     regfree(&re)
     }
     */
    
    exit(0)
  }
  
  func do_optB(_ name : String) -> String? {
    unusual = unusual | NO_BIN_FOUND
    
    var bin : String?
    while let dp = bindirs?.first {
      bindirs?.removeFirst()
      let cp = "\(dp)/\(name)"
      var sb : stat! = stat()
      if stat(cp, &sb) == 0 && (sb.st_mode & S_IFMT) == S_IFREG && (sb.st_mode & (S_IXUSR | S_IXGRP | S_IXOTH)) != 0 {
        unusual = unusual & ~NO_BIN_FOUND
        if var bin {
          bin.append(" ")
          bin.append(cp)
        } else {
          bin = cp
        }
        if !opt_a {
          break
        }
      }
    }
    return bin
  }
  
  func do_optM(_ name : String) -> String? {
    unusual = unusual | NO_MAN_FOUND
    let cp = opt_a ? ["-a","-w", name] : ["-S1:8:6", "-w", name]
//    let cpx = cp + ["-M", colonify(mandirs ?? [])]
    let (_, man, _) = try! captureStdoutLaunch("/usr/bin/man", cp)
    return man
  }
  
  
  /// Returns the output of running `executable` with `args`. Throws an error if the process exits indicating failure.
  @discardableResult
  func captureStdoutLaunch(_ executable: String, _ args: [String], _ input : String? = nil ) throws -> (Int32, String?, String?) {
    let process = Process()
    let output = Pipe()
    let stderr = Pipe()
    
    let inputs : Pipe? = if input != nil { Pipe() } else { nil }
    
    let execu = executable
    
    
    
    process.launchPath = execu
    process.arguments = args
    process.standardOutput = output
    process.standardInput = inputs
    process.standardError = stderr
    process.launch()
    
    if let inputs, let input {
      Task.detached {
        inputs.fileHandleForWriting.write( input.data(using: .utf8) ?? Data() )
        try? inputs.fileHandleForWriting.close()
      }
    }
    
    process.waitUntilExit()
    
    let k1 = String(data: output.fileHandleForReading.readDataToEndOfFile(), encoding: .ascii)
    let k2 = String(data: stderr.fileHandleForReading.readDataToEndOfFile(), encoding: .ascii)
    return (process.terminationStatus, k1, k2)

  }
  
  /*
   * Provide defaults for all options and directory lists.
   */
  func defaults() {
//      var s: Int
//      var b: String
  //    var buf = [Character](repeating: "\0", count: BUFSIZ)
//      var cp: String
//      var nele: Int
//      var p: UnsafeMutablePointer<FILE>?
//      var bindirs: [String?]
//      var mandirs: [String?]

      // default to -bm if none has been specified
      if !opt_b && !opt_m {
          opt_b = true
        opt_m = true
      }

      // -b defaults to default path + /usr/libexec + user's path
      if bindirs == nil {
        var mib = [CTL_USER, USER_CS_PATH]
        var s : Int = 0
        if sysctl(&mib, 2, nil, &s, nil, 0) == -1 {
          err(1, "sysctl: user_cs_path")
        }
        if (s == 0) {
          err(1, "user_cs_path: sysctl: zero length\n")
        }
        
        let b = withUnsafeTemporaryAllocation(byteCount: s, alignment: 1) { b in
          if sysctl(&mib, 2, b.baseAddress, &s, nil, 0) == -1 {
              let sverrno = errno
              errno = sverrno
              err(1, "sysctl: user_cs_path");
            }
          let k = b.baseAddress?.assumingMemoryBound(to: UInt8.self)
          return String(cString: k!)
        }
          // Retrieve the standard path.
          // This part is system-specific and may not be directly translatable to Swift.
          // You would need to use a Swift or Objective-C API to get the system path.

          bindirs = decolonify(b)
          bindirs?.append(PATH_LIBEXEC)
          if let path = ProcessInfo.processInfo.environment["PATH"] {
              // don't destroy the original environment...
            bindirs?.append(contentsOf: decolonify(path))
          }
      }

      // -m defaults to $(manpath)
    if mandirs == nil {
      
      /* How to query the current manpath. */
      let MANPATHCMD = ["manpath","-q"]
      do {
        let (_, bb, _) = try captureStdoutLaunch("/usr/bin/manpath", MANPATHCMD)
        var b = Substring(bb!)
        if let x = b.lastIndex(of: "\n") {
          b = b[b.startIndex..<x]
        }
        mandirs = decolonify(String(b))
      } catch(let e) {
        err( Int(EX_OSERR), "cannot execute manpath command")
      }
    }
  }
}
