
// Generated by Robert M. Lefkowitz <r0ml@liberally.net> in 2024 using ChatGPT
// from a file containing the following notice:

/*
 * SPDX-License-Identifier: BSD-3-Clause
 *
 * Copyright (c) 2000 Dan Papasian.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

import CMigration

import Darwin


func usage() {
    print("usage: which [-as] program ...")
    exit(EXIT_FAILURE)
}

// #define S_ISREG(m)      (((m) & S_IFMT) == S_IFREG)     /* regular file */

func S_ISREG(_ m : mode_t) -> Bool {
  return (m & Darwin.S_IFMT) == Darwin.S_IFREG
}

func isThere(candidate: String, silent: Bool) -> Bool {
  var fin = Darwin.stat()

    if access(candidate, X_OK) == 0 && stat(candidate, &fin) == 0 && S_ISREG(fin.st_mode) && (getuid() != 0 || (fin.st_mode & (S_IXUSR | S_IXGRP | S_IXOTH)) != 0) {
        if !silent {
            print("\(candidate)")
        }
        return true
    }
    return false
}

func printMatches(path: String, filename: String, allpaths: Bool ) -> Bool {
    var candidate = ""
    var found = false

    if filename.contains("/") {
        return isThere(candidate: filename)
    }

    for dx in path.split(separator: ":") {
        let d = dx.isEmpty ? "." : dx
        candidate = "\(d)/\(filename)"
        if candidate.count >= PATH_MAX {
            continue
        }
        if isThere(candidate: candidate) {
            found = true
            if !allpaths {
                break
            }
        }
    }
    return found
}


@main final class Which : ShellCommand {
  struct CommandOptions {
    var silent = false
    var allpaths = false
    var args = ArraySlice<String>()
  }
  
  func parseOptions() throws(CmdErr) -> CommandOptions {
    var opts = CommandOptions()
    let go = BSDGetopt("as")
    while let (ch, _) = try go.getopt() {
      switch ch {
      case "a":
          opts.allpaths = true
      case "s":
          opts.silent = true
      default:
        throw CmdErr(1)
      }
    }
    
    opts.args = ArraySlice(go.remaining)
    
    if opts.args.count == 0 {
      throw CmdErr(1)
    }
    return opts
  }
  
  func runCommand(_ opts : CommandOptions) throws(CmdErr) {
//    guard let path = ProcessInfo.processInfo.environment["PATH"]
    guard let path = getenv("PATH")
    else {
      throw CmdErr(1, "no PATH")
    }
    
    for a in opts.args {
      if a.count >= Darwin.FILENAME_MAX || !printMatches(path: path, filename: a, allpaths: opts.allpaths) {
        throw CmdErr(Int(Darwin.EXIT_FAILURE))
      }
    }
  }
  
  var usage = "usage: which [-as] program ..."
}
