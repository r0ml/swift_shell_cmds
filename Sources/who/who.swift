
// Generated by Robert M. Lefkowitz <r0ml@liberally.net> in 2024 using ChatGPT
// from a file containing the following notice:

/*
 * SPDX-License-Identifier: BSD-2-Clause-FreeBSD
 *
 * Copyright (c) 2002 Tim J. Robbins.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

import Foundation
import CMigration


@main final class Who : ShellCommand {
  struct CommandOptions {
    var Hflag : Bool = false     // Write column headings
    var aflag : Bool = false     // Print all entries
    var bflag : Bool = false     // Show date of the last reboot
    // #ifdef __APPLE__
    var lflag : Bool = false      // waiting to login
    // #endif
    var mflag : Bool = false      // Show info about current terminal
    // #ifdef __APPLE__
    var pflag : Bool = false      // Processes active & spawned by init
    // #endif
    // #ifdef __APPLE__
    var dflag : Bool = false      // dead processes
    // #endif
    var qflag : Bool = false      // "Quick" mode
    // #ifdef __APPLE__
    var rflag : Bool = false      // run-level of the init process
    // #endif
    var sflag : Bool = false      // Show name, line, time
    // #ifdef __APPLE__
    var tflag : Bool = false      // time of change to system clock
    // #endif
    var Tflag : Bool = false      // Show terminal state
    var uflag : Bool = false      // Show idle time
    // #ifdef __APPLE__
  //  #include <get_compat.h>
    var unix2003_std : Bool = false
    var arg : String?
    var args = ArraySlice<String>()
  }

  func parseOptions() throws(CmdErr) -> CommandOptions {
    var opts = CommandOptions()

    setlocale(LC_TIME, "")
    
    // #ifdef __APPLE__
    // let unix2003_std = true //  COMPAT_MODE("bin/who", "unix2003")
    
    let go = BSDGetopt("abdHlmpqrstTu")
    //    while true {
    //      let ch = getopt(argc, argv, "abdHlmpqrstTu")
    while let (ch, _) = try go.getopt() {
      
      switch ch {
      case "H":
        opts.Hflag = true
      case "T":
        opts.Tflag = true
      case "a":
        opts.aflag = true
        opts.bflag = true
        opts.Tflag = true
        opts.uflag = true
#if os(macOS)
        opts.dflag = true
        opts.lflag = true
        opts.pflag = true
        opts.rflag = true
        opts.sflag = true
        opts.tflag = true
#endif
      case "b":
        opts.bflag = true
#if os(macOS)
      case "d":
        opts.dflag = true
      case "l":
        opts.lflag = true
#endif
      case "m":
        opts.mflag = true
#if os(macOS)
      case "p":
        opts.pflag = true
#endif
      case "q":
        opts.qflag = true
#if os(macOS)
      case "r":
        opts.rflag = true
      case "s":
        opts.sflag = true
      case "t":
        opts.tflag = true
#endif
      case "u":
        opts.uflag = true
      default:
        throw CmdErr(1)
      }
    }
    
    opts.args = ArraySlice(go.remaining)
    if opts.args.isEmpty {
      return opts
    }
    
    
    if opts.args.count >= 2, opts.args[0] == "am", (opts.args[1] == "i" || opts.args[1] == "I") {
      opts.mflag = true
      opts.args = opts.args.dropFirst(2)
    }
    if opts.args.count > 1 {
      throw CmdErr(1)
    }
    
    opts.arg = opts.args.first
    return opts
  }
  
  
  func runCommand(_ opts : CommandOptions) throws(CmdErr) {
    if let arg = opts.arg {
#if !os(macOS)
      if setutxdb(UTXDB_ACTIVE, arg) != 0 {
        throw .opterr(1, arg)
      }
#else
      if (utmpxname(arg) == 0) || (wtmpxname(arg) == 0) {
        throw CmdErr(1, usage)
      }
#endif
    }
    
    if opts.qflag {
      quick()
    } else {
      var oo = opts
      if oo.sflag {
        oo.Tflag = false
        oo.uflag = false
      }
      if oo.Hflag {
        heading(oo)
      }
      if oo.mflag {
        whoami(oo)
      } else {
        process_utmp(oo)
      }
    }
    
    endutxent()
    
#if os(macOS)
    if ferror(stdout) != 0 || fflush(stdout) != 0 {
      throw CmdErr(1, "stdout")
    }
#endif
    
    exit(0)
  }
  
  var usage = "usage: who [-abdHlmpqrstTu] [am I] [file]"
  
  func leftPad(_ s : String, _ n : Int) -> String {
    return String(repeating: " ", count: n - s.count).appending(s)
  }
  func heading(_ o : CommandOptions) {
    
    print("NAME".padding(toLength: 16, withPad: " ", startingAt: 0), terminator: " ")
    if o.Tflag {
      print("S ", terminator: "")
    }
    print("\("LINE".padding(toLength: 12, withPad: " ", startingAt: 0)) \("TIME".padding(toLength: 12, withPad: " ", startingAt: 0)) ", terminator: "")
    if o.uflag {
      print("IDLE  ", terminator: "")
    }
    if o.unix2003_std && o.uflag && !o.Tflag {
      print("     PID ", terminator: "")
    }
    print("FROM".padding(toLength: 16, withPad: " ", startingAt: 0), terminator: "\n")
  }
  
  let d_first = nl_langinfo(D_MD_ORDER).pointee == ("d" as UnicodeScalar).value
  
  func row(ut: inout utmpx, _ o : CommandOptions) {
    var buf = [CChar](repeating: 0, count: 80)
    //  var tty = [CChar](repeating: 0, count: Int(_PATH_DEV.count) + Int(_UTX_LINESIZE))
    var sb = stat()
    var idle: time_t = 0
    var t: time_t = 0
    //    var d_first = -1
    var tm: UnsafeMutablePointer<tm>?
    var login_pidstr : String = "???"
    
    var state = "?"
    idle = 0
    if o.Tflag || o.uflag {
      withUnsafeBytes(of: ut.ut_line) { u in
        let tty = "\(_PATH_DEV)\(String(bytes:u, encoding: .utf8) ?? "???")"
        if stat(tty, &sb) == 0 {
          state = sb.st_mode & (S_IWOTH|S_IWGRP) != 0 ? "+" : "-"
          idle = time(nil) - sb.st_mtimespec.tv_sec
        }
      }
      if o.unix2003_std && !o.Tflag {
        if ut.ut_pid != 0 {
          login_pidstr = String(format: "%8d", ut.ut_pid)
        } else {
          login_pidstr = "       ?"
        }
      }
    }
    
    if ut.ut_type == BOOT_TIME {
      print("                 ", terminator: "")
    } else {
      // FIXME: why is this ut_name instead of ut_user?
      // FIXME: why is this ut_name in XCode, but ut_user in swift build?
      //      withUnsafeBytes(of: ut.ut_name) { u in
      withUnsafeBytes(of: ut) { u in
        let j = Array(u.bindMemory(to: CChar.self))
        let  m = String(cString: j, encoding: .nonLossyASCII)!
        //     let m = String(bytes: u, encoding: .utf8) ?? "???"
        print( m.padding(toLength: 16, withPad: " ", startingAt: 0), terminator: " ")
      }
    }
    if o.Tflag {
      print(String(format: "%c ", state), terminator: "")
    }
    if ut.ut_type == BOOT_TIME {
      print("system boot".padding(toLength: 12, withPad: " ", startingAt: 0), terminator: " ")
    } else if ut.ut_type == LOGIN_PROCESS {
      print("LOGIN".padding(toLength: 12, withPad: " ", startingAt: 12), terminator: " ")
    } else {
      withUnsafeBytes(of: ut.ut_line) { u in
        let j = Array(u.bindMemory(to: CChar.self))
        let m = String(cString: j, encoding: .nonLossyASCII)!
        print( m.padding(toLength: 12, withPad: " ", startingAt: 0), terminator: " ")
      }
    }
    t = ut.ut_tv.tv_sec
    tm = localtime(&t)
    strftime(&buf, buf.count, d_first ? "%e %b %R" : "%b %e %R", tm)
    print( String(cString: buf, encoding: .nonLossyASCII)!.padding(toLength: 12, withPad: " ", startingAt: 0), terminator: " ")
    if o.uflag {
      if idle < 60 {
        print("  .   ", terminator: "")
      } else if idle < 24 * 60 * 60 {
        print(String(format: "%02d:%02d ", Int(idle / 60 / 60), Int(idle / 60 % 60)), terminator: "")
      } else {
        print(" old  ", terminator: "")
      }
      if o.unix2003_std && !o.Tflag {
        print( "\(login_pidstr) ", terminator: "")
      }
    }
    if ut.ut_host.0 != 0 {
      withUnsafeBytes(of: ut.ut_host) { a in
        print("(\(String(bytes:a, encoding: .utf8) ?? "???" ))", terminator: "")
      }
    }
    if o.dflag && ut.ut_type == DEAD_PROCESS {
      print("\tterm=\(0) exit=\(0)", terminator: "")
    }
    print("\n", terminator: "")
  }
  
  func ttystat(_ line: String) -> Int {
    var sb = stat()
    //    var ttybuf = [Int8](repeating: 0, count: MAXPATHLEN)
    //    snprintf(&ttybuf, ttybuf.count, "%s%s", _PATH_DEV, line)
    let ttybuf = "\(_PATH_DEV)\(line)"
    return ttybuf.withCString { t in
      stat(t, &sb) == 0 ? 0 : -1
    }
  }
  
  func process_utmp(_ o : CommandOptions) {
    //    var utx: UnsafeMutablePointer<utmpx>?
    
    while let utx = getutxent() {
      if o.aflag {
        row(ut: &utx.pointee, o)
      } else if !o.bflag && utx.pointee.ut_type == USER_PROCESS {
        withUnsafeBytes(of: utx.pointee.ut_line) { uu in
          if ttystat(String(bytes: uu, encoding: .utf8) ?? "???") == 0 {
            if !o.rflag && !o.lflag && !o.dflag {
              row(ut: &utx.pointee, o)
            }
          }
        }
      } else if o.bflag && utx.pointee.ut_type == BOOT_TIME {
        row(ut: &utx.pointee, o)
      } else if o.dflag && utx.pointee.ut_type == DEAD_PROCESS {
        row(ut: &utx.pointee, o)
      } else if o.lflag && utx.pointee.ut_type == LOGIN_PROCESS {
        row(ut: &utx.pointee, o)
      }
    }
    if o.rflag {
      print("   .       run-level 3")
    }
  }
  
  func quick() {
    //    var utx: UnsafeMutablePointer<utmpx>?
    var col = 0
    let ncols = ttywidth()
    var num = 0
    
    while let utx = getutxent() {
      // FIXME: it's ut_name in Xcode, but ut_user in SPM!
      // but since it is the first element of the struct, just go with the struct
      let utnx = UnsafeRawPointer(utx).assumingMemoryBound(to: CChar.self)
      //      if utx.pointee.ut_name.0 == 0 || utx.pointee.ut_type != USER_PROCESS {
      if utnx.pointee == 0 || utx.pointee.ut_type != USER_PROCESS {
        continue
      }
      //      withUnsafeBytes(of: utx.pointee.ut_name) { n in
      withUnsafeBytes(of: utx.pointee) { n in
        print(  (String(bytes: n, encoding: .utf8) ?? "???").padding(toLength: 16, withPad: " ", startingAt: 0))
      }
      if col < ncols / (16 + 1) {
        col += 1
        print(" ")
      } else {
        col = 0
        print("\n")
      }
      num += 1
    }
    if col != 0 {
      print("\n")
    }
    print("# users = \(num)\n")
  }
  
  func whoami(_ o : CommandOptions) {
    var ut = utmpx()
    //    var utx: UnsafeMutablePointer<utmpx>?
    //  var pwd: UnsafeMutablePointer<passwd>?
    var name: String // UnsafePointer<Int8>?
    var tty: String // UnsafePointer<Int8>?
    
    
    if let ttyx = ttyname(STDIN_FILENO) {
      tty = String(cString: ttyx)
      if tty.hasPrefix(_PATH_DEV) { //  strncmp(tty, _PATH_DEV, strlen(_PATH_DEV) - 1) == 0 {
        tty = String(tty.dropFirst(_PATH_DEV.count)) //   += strlen(_PATH_DEV) - 1
      }
    } else {
      tty = "tty??"
    }
    
    let _ = tty.withCString { ttyc in
      strlcpy(&ut.ut_line, ttyc, strlen(ttyc))
    }
    
    if let utx = getutxline(&ut), utx.pointee.ut_type == USER_PROCESS {
      row(ut: &utx.pointee, o)
      return
    }
    
    memset(&ut, 0, MemoryLayout<utmpx>.size)
    if let pwd = getpwuid(getuid()) {
      name = String(cString: pwd.pointee.pw_name)
    } else {
      name = "?"
    }
    let _ = name.withCString { n in
      //    strlcpy(&ut.ut_name, n, strlen(n))
      strlcpy(&ut, n, strlen(n))
    }
    gettimeofday(&ut.ut_tv, nil)
    row(ut: &ut, o)
  }
  
  func ttywidth() -> Int {
    var ws = winsize()
    //    var width: Int64 = 0
    //    var cols: UnsafeMutablePointer<Int8>?
    var ep: UnsafeMutablePointer<Int8>?
    
    if let cols = getenv("COLUMNS"), cols.pointee != 0 {
      errno = 0
      let width = strtol(cols, &ep, 10)
      if errno != 0 || width <= 0 || width > Int.max || ep == cols ||  ep?.pointee != 0 {
        fputs("invalid COLUMNS environment variable ignored\n", stderr)
      } else {
        return Int(width)
      }
    }
    if ioctl(STDOUT_FILENO, TIOCGWINSZ, &ws) != -1 {
      return Int(ws.ws_col)
    }
    
    return 80
  }
}
