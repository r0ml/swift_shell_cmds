
// Generated by Robert M. Lefkowitz <r0ml@liberally.net> in 2024 using ChatGPT
// from a file containing the following notice:

/*
 * SPDX-License-Identifier: BSD-3-Clause
 *
 * Copyright (c) 1990, 1993
 *  The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * John B. Roll Jr.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

import Foundation
import shared

/* Instead of using inout variables (passing a string in and then mutating it, pass in a string and return the
   replaced string.  The "maxsize" argument can be ignored -- because in Swift, I don't need to do memory management,
  so it is easier to just let the result string be as large as it needs to be.
 
 This function was originally in a separate source file (strnsubst.c)
*/
func strnsubst(str: String, match: String, replstr: String) -> String {
  return str.replacingOccurrences(of: match, with: replstr)
}

/*
 // These all point to the same thing:
 // an array of strings which will be passed to the
 // subprocess as its argument list
 
 var av: [String]? // mostly identical to bxp -- although probably bxp-1 (includes the command)
var bxp: [String]? // the beginning of xxp
var ep: [String]?
var endxp: [String]?  // the end of xxp
var xp: [String]?  // the current pointer in the building of xxp
 */
 
/*
 // These all point to the same thing:
 // the current argument being parsed
var argp: String? // the pointer to the beginning of the current argument
var bbp: String?  // the pointer to the beginning of the buffer containing arguments
var ebp: String? // the end of the buffer containing arguments
var p: String? // the current position of the end of the current argument
 */

// var replstr: String?
// var eofstr: String?

// var count: Int = 0
// var rval: Int = 0
// var cnt: Int = 0
// var jfound: Int = 0
// var curprocs: Int = 0



// var childerr: Int32 = 0

@main final class Xargs : ShellCommand {
  let unix2003 = true
  var pad9314053: Int = MemoryLayout<UnsafePointer<CChar>>.size
  let NOPID: pid_t = 0
  
  var childpids: Set<pid_t> = []
  var opts = Options()
  var jbxp : [String] = []
  var kbxp : [String] = []
  var rval = 0
  
  class Options {
    var arg_max: Int = Int(sysconf(_SC_ARG_MAX))
    var Jflag = false
    var Iflag = false
    var Lflag = 0
    var tflag = false
    var zflag = false
    var xflag = false
    var nargs: Int = 5000
    var nflag = false
    var jfound = false
    
    var pflag = false
    var Rflag = 0
    var Sflag = 0
    var maxprocs: Int = 0
    
    // nline is the calculation of how long the command is going to be (in C)
    // in Swift, I can just build a command line -- however long it is.
    //      var nline: Int = -1 // Int(sysconf(_SC_ARG_MAX)) - Int(MAXPATHLEN)
    var linelen: Int = -1
    var rl: rlimit = rlimit()
    var replstr: String?
    var eofstr: String?
    var oflag = false
    var nline = -1
    
    var args : [String] = []
    
    var inp : UnsafeMutablePointer<FILE>! = stdin
  }
  
  enum PromptCases {
    case zero
    case one
    case two
  }
  
  func numericArg(_ chx : String, _ arg : String, _ min : Int) throws(CmdErr) -> Int {
    let ch = chx.count == 1 ? "-\(chx)" : "--\(chx)"
    if let i = Int(arg) {
      if i >= min {
        return i
      } else {
        throw CmdErr(1, "\(ch) \(arg): too small")
      }
    } else {
      throw CmdErr(1, "\(ch) \(arg): invalid")
    }
  }
  
// FIXME: the protocol for ShellCommand should support a cleanup
/*    defer {
      if let k = opts.inp {
        fclose(k)
      }
    }
 */
  
  func parseOptions() throws(CmdErr) {
    let optstr = "+0E:I:J:L:n:oP:pR:S:s:rtxf:"
    
    let long_options: [shared.option] /* [(String?, Int32, UnsafeMutablePointer<Int32>?, Int32)] */ = [
      option("exit", /* "x", */ .no_argument),
      option("interactive", /* "p", */ .no_argument),
      option("max-args", /* "n", */ .required_argument),
      option("max-chars", /* "s", */ .required_argument),
      option("max-procs", /* "P", */ .required_argument),
      option("no-run-if-empty", /* "r", */ .no_argument),
      option("null", /* "0", */ .no_argument),
      option("verbose", /* "t", */ .no_argument),
      option("input-file", /* "f" , */ .required_argument),
    ]
    
    setlocale(LC_ALL, "")
    
    opts.nline = opts.arg_max - Int(MAXPATHLEN)
    
    
    
    var ep = environ
    
    // FIXME: convert to getopt_long
    let go = BSDGetopt_long(optstr, long_options)
    
    while let epp = ep.pointee {
      opts.nline -= strlen(epp) + 1 + MemoryLayout<UnsafeMutablePointer<Int8>?>.size
      ep = ep.advanced(by: 1)
    }
    opts.nline -= pad9314053
    opts.maxprocs = 1
    
    
    while let (ch, optarg) = try go.getopt_long() {
      
      //      let ch = getopt_long(argc, argv, optstr, long_options, nil)
      switch ch {
      case "E":
        opts.eofstr = optarg
        //        eoflen = strlen(optarg)
      case "I":
        opts.Jflag = false
        opts.Iflag = true
        opts.Lflag = 1
        opts.replstr = optarg
      case "J":
        opts.Iflag = false
        opts.Jflag = true
        opts.replstr = optarg
      case "L":
        opts.Lflag = try numericArg(ch, optarg, 1)
        if unix2003 {
          opts.nflag = false
          opts.nargs = 5000
        }
      case "n", "max-args":
        opts.nflag = true
        opts.nargs = try numericArg(ch, optarg, 1)
        if unix2003 {
          opts.Lflag = 0
        }
      case "o":
        opts.oflag = true
      case "P", "max-procs":
        opts.maxprocs = try numericArg(ch, optarg, 0)
        
        if getrlimit(RLIMIT_NPROC, &opts.rl) != 0 {
          throw CmdErr(1, "getrlimit failed")
        }
        if opts.maxprocs == 0 || opts.maxprocs > opts.rl.rlim_cur {
          opts.maxprocs = Int(opts.rl.rlim_cur)
        }
      case "p", "interactive":
        opts.pflag = true
      case "R":
        opts.Rflag = try numericArg(ch, optarg, Int.min)
        if opts.Rflag < 0 {
          opts.Rflag = Int.max
        }
      case "r", "no-run-if-empty":
        break
      case "S":
        opts.Sflag = try numericArg(ch, optarg, 0)
      case "s", "max-chars":
        opts.nline = try numericArg(ch, optarg, 0)
        pad9314053 = 0
      case "t", "verbose":
        opts.tflag = true
      case "x", "exit":
        opts.xflag = true
      case "0", "null":
        opts.zflag = true
      case "f", "input-file":
        if let z = fopen(optarg,"r") {
          opts.inp = z
        } else {
          throw CmdErr(1, "-f \(optarg): "+String(cString: strerror(errno)) )
        }
      case "?":
        fallthrough
      default:
        throw CmdErr(1)
      }
    }
    
    let args = go.remaining
    //    let args = Array(arguments.dropFirst(Int(optind)))
    opts.args = args
    
    if !opts.Iflag && opts.Rflag != 0 {
      throw CmdErr(1)
    }
    if !opts.Iflag && opts.Sflag != 0{
      throw CmdErr(1)
    }
    if opts.Iflag && opts.Rflag == 0 {
      opts.Rflag = 5
    }
    if opts.Iflag && opts.Sflag == 0 {
      opts.Sflag = 255
    }
    if opts.xflag && !opts.nflag {
      throw CmdErr(1)
    }
    if opts.Iflag || opts.Lflag != 0 {
      opts.xflag = true
    }
    if let s = opts.replstr, s.isEmpty {
      throw CmdErr(1, "replstr may not be empty")
    }

    childpids = Set<pid_t>()
    
    opts.linelen = 1 + opts.args.count + opts.nargs + 1

    let _PATH_ECHO = "/bin/echo"
    let echo = _PATH_ECHO
    
    var cnt = 0
    if opts.args.isEmpty {
      jbxp.append(echo)
      cnt = echo.count
    } else {
      if opts.Jflag, let rr = opts.replstr, let k = opts.args.firstIndex(of: rr) {
        opts.jfound = true
        jbxp.append(contentsOf: opts.args[0..<k])
        kbxp = Array(opts.args[(k+1)...])
        cnt -= rr.count + 1 + pad9314053
      } else {
        jbxp.append(contentsOf: opts.args)
      }
      cnt = opts.args.reduce(0, { $0 + $1.count + 1 + pad9314053} )
    }
    
    opts.nline -= cnt
    if opts.nline <= 0 {
     throw CmdErr(1, "insufficient space for command")
     }    
  }

  /**
    r0ml added this function.
    the original had a function called to read each character -- with the embedded logic and state to handle execution when complete.
   
   This function reads the next *argument* instead of the next character, and the logic for what to do is embedded at this level.
   */
  
  enum ArgState {
      case eof
    case tab
    case zero
    case newline
  }
  
  func parseArgument(_ prevc : Character) throws(CmdErr) -> (String, Character?) {
    var indouble = false
    var insingle = false
    var argp = ""
    var wasquoted = false
    var prevchar = prevc
    
    // Constructs the next argument from stdin

    while true {
      let ch = getc(opts.inp)

      if ch == EOF {
        if insingle || indouble {
          throw CmdErr(1, "unterminated quote")
        }
        return (argp, nil)
      }

      let chx = Character(UnicodeScalar(UInt8(ch)))
      switch chx {
      case " ":
        fallthrough
      case "\t":
        if insingle || indouble || opts.zflag || opts.Lflag > 0 {
          argp.append(chx)
          break
        } else {
          if !opts.Iflag {
            if argp.count == 0 && !wasquoted {
              break
            }
            return (argp, chx)
          }
        }
      case "\0":
        if opts.zflag {
/*          if argp.count == 0 && !wasquoted {
            break
          }
 */
          return (argp, chx)
        } else {
          argp.append(chx)
        }
      case "\n":
        if opts.zflag {
          argp.append(chx)
          break
        }
        if unix2003 {
          // is this the same as last_was_newline?
          if argp.count == 0 {
            break
          }
          // if line ends in blank, next line is continuation
        if !opts.Iflag && prevchar == " " {
            break
          }
        }
        if insingle || indouble {
          throw CmdErr(1, "unterminated quote")
        }
        if argp.count == 0 && !wasquoted {
          break
        }
        return (argp, chx)
      case "'":
        if indouble || opts.zflag {
          argp.append(chx)
        } else {
          insingle.toggle()
          wasquoted = true
        }
      case "\"":
        if insingle || opts.zflag {
          argp.append(chx)
        } else {
          indouble.toggle()
          wasquoted = true
        }
      case "\\":
        if opts.zflag {
          argp.append(chx)
          break
        }
        if !insingle && !indouble {
          let ch = getc(opts.inp)
          if ch == EOF {
            throw CmdErr(1, "backslash at EOF")
          }
          argp.append(Character(UnicodeScalar(UInt8(ch))))
          break
        }
      default:
        argp.append(chx)
        // The original code tests to see if the argument exceeds the available space at this point, and if so, reports an error or truncates the argument.
        // the "available space" is opts.nline
        // As Swift will grow the argument string size, perhaps this is not necessary.
        if argp.count >= opts.nline {
          fatalError("see xargs.c[572]")
        }
      }
      prevchar = chx
    }
  }

  func prerun(_ jbxp : [String], _ ibxp : [String], _ kbxp : [String], _ inpline : String) throws(CmdErr) {
    let repls = opts.Rflag
   
    if repls == 0 {
      try run(jbxp + (ibxp.filter { !$0.isEmpty }) + kbxp)
      return
    }
    
    var avj = jbxp
    
    var tmp = [String]()
/*    [String?](repeating: nil, count: argc + 1)
    if tmp.isEmpty {
      print("malloc failed")
      xexit(argv: &argv, 1)
    }
    tmp2 = tmp
  */
    
    if let firstArg = avj.first {
      tmp.append(firstArg)
      avj.removeFirst()
    }
    
    var rr = 0
    for var tmpLast in avj {
      if rr < repls, let replstr = opts.replstr, tmpLast.contains(replstr) {
          tmpLast = strnsubst(str: tmpLast, match: replstr, replstr: inpline)
          rr += 1
        }
      tmp.append(tmpLast)
    }
    
    try run(tmp)
    
    /*
    for _ in tmp2 {
      tmp.removeLast()
    }
    */

    // inpline = ""
    /*
    if inpline != nil {
      inpline = nil
    }
     */
  }
  
  func run(_ args : [String] ) throws(CmdErr) {
    var pid: pid_t = 0
    var rc: Int32 = 0

    var file_actions = posix_spawn_file_actions_t(bitPattern: 0)
    var inpath = _PATH_DEVNULL
    
    if opts.tflag || opts.pflag {
      print(args.joined(separator: " "))
      if opts.pflag {
        switch prompt() {
        case .zero:
          return
        case .one:
          break
        case .two:
          break
        }
      }
      print("\n")
    }

    if opts.oflag {
      inpath = _PATH_TTY
    }
    
    if posix_spawn_file_actions_init(&file_actions) != 0 {
      throw CmdErr(1, "posix_spawn_file_actions_init failed")
    }
      
    if posix_spawn_file_actions_addopen(&file_actions, STDIN_FILENO, inpath, O_RDONLY, 0444) != 0 {
      throw CmdErr(1, "posix_spawn_file_actions_addopen failed")
    }
  
    
    /*
    let pipe = Pipe()
    let pip = pipe.fileHandleForWriting.fileDescriptor
    if posix_spawn_file_actions_adddup2(&file_actions,
                                        pip, STDOUT_FILENO ) != 0 {
      throw CmdErr.opterr(1, "posix_spawn_file_actions_adddup2 failed")
    }
    */
    
    let xy = (args.map { strdup($0.cString(using: .utf8)) }) + [UnsafeMutablePointer(bitPattern: 0)]
    defer { xy.forEach { free($0) } }

    rc = posix_spawnp(&pid, args[0], &file_actions, nil, xy, environ)
    
    if rc != 0 {
      waitchildren(jbxp[0], true)
      errno = rc
//      fputs(args[0], stderr)
      throw CmdErr(rc == ENOENT ? 127 : 126, args[0])
    } else {
      childpids.insert(pid)
 //     let jj = try pipe.fileHandleForReading.availableData
//      print( String(data: jj, encoding: .utf8)! )
      waitchildren(jbxp[0], false)
    }
  }
  
  // wait for a status from a subprocess
  func xwait(_ block: Bool)-> (pid_t, Int32) {
    
    if childpids.isEmpty {
      errno = ECHILD
      return (-1, 0)
    }
    
    var status : Int32 = 0
    
    while let pid = Optional(waitpid(-1, &status, block ? 0 : WNOHANG)), pid > 0 {
      if let p = childpids.remove(pid) {
        return (p, status)
      }
    }
    
    return (NOPID, status)
    // return pid
  }
  

  

  
  /*
  mutating func arg1(_ av : [String]) throws {
    if insingle || indouble {
      fputs("unterminated quote", stderr)
      try xexit(av[0], 1)
    }
    
    try arg2(av)
  }
  */
  
  var count = 0
  
  /*
  mutating func arg2(_ av : [String]) throws {

    foundeof = inpline == opts.eofstr
    
    if opts.Iflag && !lastWasNewline {
      foundeof = false
    }
    
    if foundeof { // } && (p - strlen(opts.eofstr) == bbp) {
      try waitchildren(av[0], true)
      exit(Int32(rval))
    }
    
    if (!argp.isEmpty || wasquoted) && !foundeof {
//      p += 1
      // FIXME: what is xp doing?
      av.append(argp)
      if opts.Iflag {
        var curlen: size_t = 0
        
//        if inpline == nil {
//          //            curlen = 0
//        } else {
        curlen = inpline.count
        if inpline.count > 0 {
          inpline.append(" ")
        }
//        }
        curlen += 1
        //          inpline = realloc(inpline, curlen + 2 + strlen(argp))
        //          if inpline == nil {
        //            fputs("realloc failed", stderr)
        //            try xexit(av[0], 1)
        //          }
        

        if curlen == 1 {
          inpline = argp
        } else {
          inpline.append(argp)
        }
        
      }
    }
    
    // FIXME: what happens here?
    
//    fatalError("I'm lost")
    
    /*
    if xp == endxp || p + (count * pad9314053) > ebp || ch == EOF ||
        (opts.Lflag <= count && opts.xflag) || foundeof {
      /*        if xflag && xp != endxp && p + (count * pad9314053) > ebp {
       fputs("insufficient space for arguments", stderr)
       try xexit(av[0], 1)
       }
       */
      if jfound {
        for avj in av {
          xp += 1
        }
      }
     */
      try prerun(av)
    // FIXME: also tested for ch == EOF -- which should not be necessary if foundeof?
      if foundeof {
        try waitchildren(av[0], true)
        exit(Int32(rval))
      }
    // FIXME: what does xp do?
//      xp = bxp
      count = 0
    argp = ""
  }
  */
  
  func runCommand() throws(CmdErr) {
    var pc : Character? = "\n"
    var a : String = ""
    var ibxp = [String]()
    
    while pc != nil {
      (a, pc) = try parseArgument(pc!)
      if (!a.isEmpty) || (opts.zflag && opts.xflag) {
        ibxp.append(a)
      }
      if (pc == nil && ibxp.count > 0) || ibxp.count >= opts.nargs || (opts.xflag && opts.Lflag <= ibxp.count)  {
          //        try arg2(av)
          try prerun(jbxp, ibxp, kbxp, a)
        ibxp = []
      }
    }
  }
  
  
  func prompt() -> PromptCases {
    var cre = regex_t()
    var rsize: size_t = 0
    var match: Int32 = 0
    
    let ttyfp = fopen(_PATH_TTY, "r")
    if ttyfp != nil {
      return .two
    }
    fputs("?...", stderr)
    fflush(stderr)
    let response = fgetln(ttyfp, &rsize)
    if response == nil || regcomp(&cre, nl_langinfo(YESEXPR), REG_EXTENDED) != 0 {
      fclose(ttyfp)
      return .zero
    }
    response![Int(rsize) - 1] = 0
    match = regexec(&cre, response, 0, nil, 0)
    fclose(ttyfp)
    regfree(&cre)
    return match == 0 ? .one : .zero
  }
  
  var usage = "usage: xargs [-0opt] [-E eofstr] [-I replstr [-R replacements] [-S replsize]] [-J replstr] [-L number] [-n number [-x]] [-P maxprocs] [-s size] [utility [argument ...]]"

  func xexit(_ name: String, _ exit_code: Int) throws {
    waitchildren(name, true)
    exit(Int32(exit_code))
  }
  
  func waitchildren(_ name: String, _ waitl: Bool) {
    var waitall = waitl
//    var pid: pid_t
    var cause_exit : Int32 = 0
    
    while let (pid, status) = Optional(xwait( waitall || childpids.count >= opts.maxprocs)) {
/*      if (childerr != 0 && cause_exit == 0) {
        errno = childerr
        waitall = true
        cause_exit = errno == ENOENT ? 127 : 126
        fputs(name, stderr)
      } else
 */
      if pid <= 0 {
        if (cause_exit != 0) {
          exit(cause_exit)
        }
        if (pid == -1 && errno != ECHILD) {
          fputs("waitpid", stderr)
          exit(1)
        }
        return
      }
      

      if status & 0x7f != 0x7f && status & 0x7f != 0 { // (WIFSIGNALED(status) != 0) {
        waitall = true
        cause_exit = 1
        fputs("\(name): terminated with signal \(status & 0x7f); aborting", stderr)
      } else if status >> 8 == 255 {
        waitall = true
        cause_exit = 1
        fputs("\(name): exited with status 255; aborting", stderr)
      } else if (status >> 8) != 0 {
        rval = 1
      }
    }
    
  }
  
}
