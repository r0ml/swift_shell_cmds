
// Generated by Robert M. Lefkowitz <r0ml@liberally.net> in 2024 using ChatGPT
// from a file containing the following notice:

/*
 * SPDX-License-Identifier: BSD-3-Clause
 *
 * Copyright (c) 1990, 1993
 *  The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * John B. Roll Jr.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

import CMigration
// import Darwin

@main final class Xargs : ShellCommand {
  let unix2003 = true
//  var pad9314053: Int = MemoryLayout<UnsafePointer<CChar>>.size
  let NOPID = 0

  var childpids: Set<Int> = []
  var jbxp : [String] = []
  var kbxp : [String] = []
  var rval = 0
  
  class CommandOptions {
//    var arg_max: Int = Int(Darwin.sysconf(Darwin._SC_ARG_MAX))
    var Jflag = false
    var Iflag = false
    var Lflag = 0
    var tflag = false
    var zflag = false
    var xflag = false
    var nargs: Int = 5000
    var nflag = false
    var jfound = false
    
    var pflag = false
    var Rflag = 0
    var Sflag = 0
    var maxprocs: Int = 0
    
    // nline is the calculation of how long the command is going to be (in C)
    // in Swift, I can just build a command line -- however long it is.
    //      var nline: Int = -1 // Int(sysconf(_SC_ARG_MAX)) - Int(MAXPATHLEN)
    var linelen: Int = -1
//    var rl: rlimit = Darwin.rlimit()
    var replstr: String?
    var eofstr: String?
    var oflag = false
//    var nline = -1

    var args : [String] = []
    
    var inp = FileDescriptor.standardInput // UnsafeMutablePointer<FILE>! = stdio_h.stdin
  }
  
  func numericArg(_ chx : String, _ arg : String, _ min : Int) throws(CmdErr) -> Int {
    let ch = chx.count == 1 ? "-\(chx)" : "--\(chx)"
    if let i = Int(arg) {
      if i >= min {
        return i
      } else {
        throw CmdErr(1, "\(ch) \(arg): too small")
      }
    } else {
      throw CmdErr(1, "\(ch) \(arg): invalid")
    }
  }
  
// FIXME: the protocol for ShellCommand should support a cleanup
/*    defer {
      if let k = opts.inp {
        fclose(k)
      }
    }
 */
  
  func parseOptions() throws(CmdErr) -> CommandOptions {
    let optstr = "+0E:I:J:L:n:oP:pR:S:s:rtxf:"
    let opts = CommandOptions()
    
    let long_options: [CMigration.option] /* [(String?, Int32, UnsafeMutablePointer<Int32>?, Int32)] */ = [
      option("exit", /* "x", */ .no_argument),
      option("interactive", /* "p", */ .no_argument),
      option("max-args", /* "n", */ .required_argument),
      option("max-chars", /* "s", */ .required_argument),
      option("max-procs", /* "P", */ .required_argument),
      option("no-run-if-empty", /* "r", */ .no_argument),
      option("null", /* "0", */ .no_argument),
      option("verbose", /* "t", */ .no_argument),
      option("input-file", /* "f" , */ .required_argument),
    ]

//    opts.nline = opts.arg_max - MAXPATHLEN

//    var ep = getenv()

    let go = BSDGetopt_long(optstr, long_options)

    /*
    while let epp = ep.pointee {
      opts.nline -= stdlib_h.strlen(epp) + 1 + MemoryLayout<UnsafeMutablePointer<Int8>?>.size
      ep = ep.advanced(by: 1)
    }
     */

//    opts.nline -= pad9314053


    opts.maxprocs = 1
    
    
    while let (ch, optarg) = try go.getopt_long() {
      
      //      let ch = getopt_long(argc, argv, optstr, long_options, nil)
      switch ch {
      case "E":
        opts.eofstr = optarg
        //        eoflen = strlen(optarg)
      case "I":
        opts.Jflag = false
        opts.Iflag = true
        opts.Lflag = 1
        opts.replstr = optarg
      case "J":
        opts.Iflag = false
        opts.Jflag = true
        opts.replstr = optarg
      case "L":
        opts.Lflag = try numericArg(ch, optarg, 1)
        if unix2003 {
          opts.nflag = false
          opts.nargs = 5000
        }
      case "n", "max-args":
        opts.nflag = true
        opts.nargs = try numericArg(ch, optarg, 1)
        if unix2003 {
          opts.Lflag = 0
        }
      case "o":
        opts.oflag = true
      case "P", "max-procs":
          // FIXME: do I need this ?  Or will posix_spawn behave appropriately?

          opts.maxprocs = try numericArg(ch, optarg, 0)

          // FIXME: put me back?
          /*
        if getrlimit(RLIMIT_NPROC, &opts.rl) != 0 {
          throw CmdErr(1, "getrlimit failed")
        }
        if opts.maxprocs == 0 || opts.maxprocs > opts.rl.rlim_cur {
          opts.maxprocs = Int(opts.rl.rlim_cur)
        }
           */
      case "p", "interactive":
        opts.pflag = true
      case "R":
        opts.Rflag = try numericArg(ch, optarg, Int.min)
        if opts.Rflag < 0 {
          opts.Rflag = Int.max
        }
      case "r", "no-run-if-empty":
        break
      case "S":
        opts.Sflag = try numericArg(ch, optarg, 0)
      case "s", "max-chars":
          // FIXME: do I need this?  Will posix_spawn complain if the command line is too big?
          break
//        opts.nline = try numericArg(ch, optarg, 0)
//        pad9314053 = 0
      case "t", "verbose":
        opts.tflag = true
      case "x", "exit":
        opts.xflag = true
      case "0", "null":
        opts.zflag = true
      case "f", "input-file":
          do {
          opts.inp = try FileDescriptor(forReading: optarg)
        } catch(let e) {
          throw CmdErr(1, "-f \(optarg): \(e)")
        }
      case "?":
        fallthrough
      default:
        throw CmdErr(1)
      }
    }
    
    let args = go.remaining
    //    let args = Array(arguments.dropFirst(Int(optind)))
    opts.args = args
    
    if !opts.Iflag && opts.Rflag != 0 {
      throw CmdErr(1)
    }
    if !opts.Iflag && opts.Sflag != 0{
      throw CmdErr(1)
    }
    if opts.Iflag && opts.Rflag == 0 {
      opts.Rflag = 5
    }
    if opts.Iflag && opts.Sflag == 0 {
      opts.Sflag = 255
    }
    if opts.xflag && !opts.nflag {
      throw CmdErr(1)
    }
    if opts.Iflag || opts.Lflag != 0 {
      opts.xflag = true
    }
    if let s = opts.replstr, s.isEmpty {
      throw CmdErr(1, "replstr may not be empty")
    }

    childpids = Set<Int>()

    opts.linelen = 1 + opts.args.count + opts.nargs + 1

    let _PATH_ECHO = "/bin/echo"
    let echo = _PATH_ECHO
    
//    var cnt = 0
    if opts.args.isEmpty {
      jbxp.append(echo)
//      cnt = echo.count
    } else {
      if opts.Jflag, let rr = opts.replstr, let k = opts.args.firstIndex(of: rr) {
        opts.jfound = true
        jbxp.append(contentsOf: opts.args[0..<k])
        kbxp = Array(opts.args[(k+1)...])
//        cnt -= rr.count + 1 + pad9314053
      } else {
        jbxp.append(contentsOf: opts.args)
      }
//      cnt = opts.args.reduce(0, { $0 + $1.count + 1 + pad9314053} )
    }
    
//    opts.nline -= cnt
//    if opts.nline <= 0 {
//     throw CmdErr(1, "insufficient space for command")
//     }
    return opts
  }

  /**
    r0ml added this function.
    the original had a function called to read each character -- with the embedded logic and state to handle execution when complete.
   
   This function reads the next *argument* instead of the next character, and the logic for what to do is embedded at this level.
   */
  
  enum ArgState {
      case eof
    case tab
    case zero
    case newline
  }
  
  func parseArgument(_ prevc : Character, _ inp : inout AsyncCharacterReader.AsyncIterator, _ opts : CommandOptions) async throws(CmdErr) -> (String, Character?) {
    var indouble = false
    var insingle = false
    var argp = ""
    var wasquoted = false
    var prevchar = prevc
    
    // Constructs the next argument from stdin



    while true {
      var ch : Character? = nil
      do {
        ch = try await inp.next()
      } catch(let e) {
        throw CmdErr(1, "reading input: \(e)")
      }
      guard let ch else {
        return (argp, nil)
      }

      if ch == nil {
        if insingle || indouble {
          throw CmdErr(1, "unterminated quote")
        }
        return (argp, nil)
      }

      switch ch {
      case " ":
        fallthrough
      case "\t":
        if insingle || indouble || opts.zflag || opts.Lflag > 0 {
          argp.append(ch)
          break
        } else {
          if !opts.Iflag {
            if argp.count == 0 && !wasquoted {
              break
            }
            return (argp, ch)
          }
        }
      case "\0":
        if opts.zflag {
/*          if argp.count == 0 && !wasquoted {
            break
          }
 */
          return (argp, ch)
        } else {
          argp.append(ch)
        }
      case "\n":
        if opts.zflag {
          argp.append(ch)
          break
        }
        if unix2003 {
          // is this the same as last_was_newline?
          if argp.count == 0 {
            break
          }
          // if line ends in blank, next line is continuation
        if !opts.Iflag && prevchar == " " {
            break
          }
        }
        if insingle || indouble {
          throw CmdErr(1, "unterminated quote")
        }
        if argp.count == 0 && !wasquoted {
          break
        }
        return (argp, ch)
      case "'":
        if indouble || opts.zflag {
          argp.append(ch)
        } else {
          insingle.toggle()
          wasquoted = true
        }
      case "\"":
        if insingle || opts.zflag {
          argp.append(ch)
        } else {
          indouble.toggle()
          wasquoted = true
        }
      case "\\":
        if opts.zflag {
          argp.append(ch)
          break
        }
        if !insingle && !indouble {
          do {
            let ch = try await inp.next()
            guard let ch else {
              throw CmdErr(1, "backslash at EOF")
            }
            argp.append(ch)
          } catch(let e) {
            throw CmdErr(1, "reading input: \(e)")
          }
          break
        }
      default:
        argp.append(ch)
        // The original code tests to see if the argument exceeds the available space at this point, and if so, reports an error or truncates the argument.
        // the "available space" is opts.nline
        // As Swift will grow the argument string size, perhaps this is not necessary.
//        if argp.count >= opts.nline {
//          fatalError("see xargs.c[572]")
//        }
      }
      prevchar = ch
    }
  }

  func prerun(_ jbxp : [String], _ ibxp : [String], _ kbxp : [String], _ inpline : String, _ opts : CommandOptions) async throws(CmdErr) {
    let repls = opts.Rflag
   
    if repls == 0 {
      try await run(jbxp + (ibxp.filter { !$0.isEmpty }) + kbxp, opts)
      return
    }
    
    var avj = jbxp
    
    var tmp = [String]()
/*    [String?](repeating: nil, count: argc + 1)
    if tmp.isEmpty {
      print("malloc failed")
      xexit(argv: &argv, 1)
    }
    tmp2 = tmp
  */
    
    if let firstArg = avj.first {
      tmp.append(firstArg)
      avj.removeFirst()
    }
    
    var rr = 0
    for var tmpLast in avj {
      if rr < repls, let replstr = opts.replstr, tmpLast.contains(replstr) {
        tmpLast = tmpLast.replacing(replstr, with: inpline) //  strnsubst(str: tmpLast, match: replstr, replstr: inpline)
          rr += 1
        }
      tmp.append(tmpLast)
    }
    
    try await run(tmp, opts)

    /*
    for _ in tmp2 {
      tmp.removeLast()
    }
    */

    // inpline = ""
    /*
    if inpline != nil {
      inpline = nil
    }
     */
  }
  
  func run(_ args : [String], _ opts : CommandOptions) async throws(CmdErr) {


    /*
    var pid: pid_t = 0
    var rc: Int32 = 0

    var file_actions = posix_spawn_file_actions_t(bitPattern: 0)
    var inpath = _PATH_DEVNULL
    
    if opts.tflag || opts.pflag {
      print(args.joined(separator: " "))
      if opts.pflag {
        switch rpmatch("?...") {
        case .yes:
          return
        case .no:
          break
          case .neither:
          break
        }
      }
      print("\n")
    }

    if opts.oflag {
      inpath = Darwin._PATH_TTY
    }

    if posix_spawn_file_actions_init(&file_actions) != 0 {
      throw CmdErr(1, "posix_spawn_file_actions_init failed")
    }
      
    if posix_spawn_file_actions_addopen(&file_actions, STDIN_FILENO, inpath, O_RDONLY, 0444) != 0 {
      throw CmdErr(1, "posix_spawn_file_actions_addopen failed")
    }
  
    
    /*
    let pipe = Pipe()
    let pip = pipe.fileHandleForWriting.fileDescriptor
    if posix_spawn_file_actions_adddup2(&file_actions,
                                        pip, STDOUT_FILENO ) != 0 {
      throw CmdErr.opterr(1, "posix_spawn_file_actions_adddup2 failed")
    }
    */
    
    let xy = (args.map {a in a.withCString { s in strdup(s) } } ) + [UnsafeMutablePointer(bitPattern: 0)]
    defer { xy.forEach { free($0) } }
*/

    // use a TaskGroup here?

    let p = ProcessRunner2(command: args[0], arguments: args, environment: nil )

    do {
      let m = try await p.run(captureStdout: false, captureStderr: false)

    } catch(let e) {
      throw CmdErr(1, "\(e)")
    }

//    rc = Darwin.posix_spawnp(&pid, args[0], &file_actions, nil, xy, Darwin.environ)



/*
    if rc != 0 {
      try waitchildren(jbxp[0], true, opts)
      errno = rc
//      fputs(args[0], stderr)
      throw CmdErr(rc == ENOENT ? 127 : 126, args[0])
    } else {
      childpids.insert(Int(pid))
 //     let jj = try pipe.fileHandleForReading.availableData
//      print( String(data: jj, encoding: .utf8)! )
      try waitchildren(jbxp[0], false, opts)
    }
     */
  }

  /*
  // wait for a status from a subprocess
  func xwait(_ block: Bool)-> (Int, Int32) {

    if childpids.isEmpty {
      errno = ECHILD
      return (-1, 0)
    }
    
    var status : Int32 = 0
    
    while let pid = Optional(waitpid(-1, &status, block ? 0 : WNOHANG)), pid > 0 {
      if let p = childpids.remove(Int(pid)) {
        return (p, status)
      }
    }
    
    return (NOPID, status)
    // return pid
  }
  */

  

  
  /*
  mutating func arg1(_ av : [String]) throws {
    if insingle || indouble {
      fputs("unterminated quote", stderr)
      try xexit(av[0], 1)
    }
    
    try arg2(av)
  }
  */
  
  var count = 0
  
  /*
  mutating func arg2(_ av : [String]) throws {

    foundeof = inpline == opts.eofstr
    
    if opts.Iflag && !lastWasNewline {
      foundeof = false
    }
    
    if foundeof { // } && (p - strlen(opts.eofstr) == bbp) {
      try waitchildren(av[0], true)
      exit(Int32(rval))
    }
    
    if (!argp.isEmpty || wasquoted) && !foundeof {
//      p += 1
      // FIXME: what is xp doing?
      av.append(argp)
      if opts.Iflag {
        var curlen: size_t = 0
        
//        if inpline == nil {
//          //            curlen = 0
//        } else {
        curlen = inpline.count
        if inpline.count > 0 {
          inpline.append(" ")
        }
//        }
        curlen += 1
        //          inpline = realloc(inpline, curlen + 2 + strlen(argp))
        //          if inpline == nil {
        //            fputs("realloc failed", stderr)
        //            try xexit(av[0], 1)
        //          }
        

        if curlen == 1 {
          inpline = argp
        } else {
          inpline.append(argp)
        }
        
      }
    }
    
    // FIXME: what happens here?
    
//    fatalError("I'm lost")
    
    /*
    if xp == endxp || p + (count * pad9314053) > ebp || ch == EOF ||
        (opts.Lflag <= count && opts.xflag) || foundeof {
      /*        if xflag && xp != endxp && p + (count * pad9314053) > ebp {
       fputs("insufficient space for arguments", stderr)
       try xexit(av[0], 1)
       }
       */
      if jfound {
        for avj in av {
          xp += 1
        }
      }
     */
      try prerun(av)
    // FIXME: also tested for ch == EOF -- which should not be necessary if foundeof?
      if foundeof {
        try waitchildren(av[0], true)
        exit(Int32(rval))
      }
    // FIXME: what does xp do?
//      xp = bxp
      count = 0
    argp = ""
  }
  */
  
  func runCommand(_ opts : CommandOptions) async throws(CmdErr) {
    var pc : Character? = "\n"
    var a : String = ""
    var ibxp = [String]()

    var argi = opts.inp.characters.makeAsyncIterator()

    while pc != nil {
      (a, pc) = try await parseArgument(pc!, &argi, opts)
      if (!a.isEmpty) || (opts.zflag && opts.xflag) {
        ibxp.append(a)
      }
      if (pc == nil && ibxp.count > 0) || ibxp.count >= opts.nargs || (opts.xflag && opts.Lflag <= ibxp.count)  {
          //        try arg2(av)
          try await prerun(jbxp, ibxp, kbxp, a, opts)
        ibxp = []
      }
    }
  }
  
  /*
  func prompt() -> PromptCases {
    var cre = Darwin.regex_t()
    var rsize: Darwin.size_t = 0
    var match: Int32 = 0
    
    let ttyfp = stdio_h.fopen(Darwin._PATH_TTY, "r")
    if ttyfp != nil {
      return .two
    }
    stdio_h.fputs("?...", stdio_h.stderr)
    stdio_h.fflush(stdio_h.stderr)
    let response = stdio_h.fgetln(ttyfp, &rsize)
    if response == nil || Darwin.regcomp(&cre, Darwin.nl_langinfo(Darwin.YESEXPR), Darwin.REG_EXTENDED) != 0 {
      stdio_h.fclose(ttyfp)
      return .zero
    }
    response![Int(rsize) - 1] = 0
    match = Darwin.regexec(&cre, response, 0, nil, 0)
    stdio_h.fclose(ttyfp)
    Darwin.regfree(&cre)
    return match == 0 ? .one : .zero
  }
  */

  var usage = "usage: xargs [-0opt] [-E eofstr] [-I replstr [-R replacements] [-S replsize]] [-J replstr] [-L number] [-n number [-x]] [-P maxprocs] [-s size] [utility [argument ...]]"

  /*
  func xexit(_ name: String, _ exit_code: Int, _ opts : CommandOptions) throws(CmdErr) {
    try waitchildren(name, true, opts)
    throw CmdErr(exit_code, "")
  }
  
  func waitchildren(_ name: String, _ waitl: Bool, _ opts : CommandOptions) throws(CmdErr) {
    var waitall = waitl
    var cause_exit : Int32 = 0

    var se = FileDescriptor.standardError

    while let (pid, status) = Optional(xwait( waitall || childpids.count >= opts.maxprocs)) {
/*      if (childerr != 0 && cause_exit == 0) {
        errno = childerr
        waitall = true
        cause_exit = errno == ENOENT ? 127 : 126
        fputs(name, stderr)
      } else
 */
      if pid <= 0 {
        if (cause_exit != 0) {
          throw CmdErr(Int(cause_exit), "")
        }
        if (pid == -1 && errno != ECHILD) {
          throw CmdErr(1, "waitpid")
        }
        return
      }
      

      if status & 0x7f != 0x7f && status & 0x7f != 0 { // (WIFSIGNALED(status) != 0) {
        waitall = true
        cause_exit = 1
        print("\(name): terminated with signal \(status & 0x7f); aborting", to: &se)
      } else if status >> 8 == 255 {
        waitall = true
        cause_exit = 1
        print("\(name): exited with status 255; aborting", to: &se)
      } else if (status >> 8) != 0 {
        rval = 1
      }
    }
    
  }
  */
}




