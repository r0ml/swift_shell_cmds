
// Generated by Robert M. Lefkowitz <r0ml@liberally.net> in 2024 using ChatGPT
// from a file containing the following notice:

/*
 * SPDX-License-Identifier: BSD-3-Clause
 *
 * Copyright (c) 1990, 1993
 *  The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * John B. Roll Jr.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

import CMigration

@main final class Xargs : ShellCommand {
  let unix2003 = true
//  var pad9314053: Int = MemoryLayout<UnsafePointer<CChar>>.size
  let NOPID = 0

  var childpids: Set<Int> = []
  var jbxp : [String] = []
  var kbxp : [String] = []
  var rval = 0
  
  class CommandOptions {
//    var arg_max: Int = Int(Darwin.sysconf(Darwin._SC_ARG_MAX))
    var Jflag = false
    var Iflag = false
    var Lflag = 0
    var tflag = false
    var zflag = false
    var xflag = false
    var nargs: Int = 5000
    var nflag = false
    var jfound = false
    
    var pflag = false
    var Rflag = 0
    var Sflag = 0
    var maxprocs: Int = 0
    
    // nline is the calculation of how long the command is going to be (in C)
    // in Swift, I can just build a command line -- however long it is.
    //      var nline: Int = -1 // Int(sysconf(_SC_ARG_MAX)) - Int(MAXPATHLEN)
    var linelen: Int = -1
//    var rl: rlimit = Darwin.rlimit()
    var replstr: String?
    var eofstr: String?
    var oflag = false
//    var nline = -1

    var args : [String] = []
    
    var inp = FileDescriptor.standardInput // UnsafeMutablePointer<FILE>! = stdio_h.stdin
  }
  
  func numericArg(_ chx : String, _ arg : String, _ min : Int) throws(CmdErr) -> Int {
    let ch = chx.count == 1 ? "-\(chx)" : "--\(chx)"
    if let i = Int(arg) {
      if i >= min {
        return i
      } else {
        throw CmdErr(1, "\(ch) \(arg): too small")
      }
    } else {
      throw CmdErr(1, "\(ch) \(arg): invalid")
    }
  }
  
  func parseOptions() throws(CmdErr) -> CommandOptions {
    let optstr = "+0E:I:J:L:n:oP:pR:S:s:rtxf:"
    let opts = CommandOptions()
    
    let long_options: [CMigration.option] = [
      option("exit", .no_argument),             // x
      option("interactive", .no_argument),      // p
      option("max-args", .required_argument),   // n
      option("max-chars", .required_argument),  // s
      option("max-procs", .required_argument),  // P
      option("no-run-if-empty", .no_argument),  // r
      option("null", .no_argument),             // 0
      option("verbose", .no_argument),          // t
      option("input-file", .required_argument), // f
    ]

    let go = BSDGetopt_long(optstr, long_options)
    opts.maxprocs = 1
    while let (ch, optarg) = try go.getopt_long() {
      switch ch {
      case "E":
        opts.eofstr = optarg
      case "I":
        opts.Jflag = false
        opts.Iflag = true
        opts.Lflag = 1
        opts.replstr = optarg
      case "J":
        opts.Iflag = false
        opts.Jflag = true
        opts.replstr = optarg
      case "L":
        opts.Lflag = try numericArg(ch, optarg, 1)
        if unix2003 {
          opts.nflag = false
          opts.nargs = 5000
        }
      case "n", "max-args":
        opts.nflag = true
        opts.nargs = try numericArg(ch, optarg, 1)
        if unix2003 {
          opts.Lflag = 0
        }
      case "o":
        opts.oflag = true
      case "P", "max-procs":
          // FIXME: do I need this ?  Or will posix_spawn behave appropriately?

          opts.maxprocs = try numericArg(ch, optarg, 0)

          // FIXME: put me back?
          /*
        if getrlimit(RLIMIT_NPROC, &opts.rl) != 0 {
          throw CmdErr(1, "getrlimit failed")
        }
        if opts.maxprocs == 0 || opts.maxprocs > opts.rl.rlim_cur {
          opts.maxprocs = Int(opts.rl.rlim_cur)
        }
           */
      case "p", "interactive":
        opts.pflag = true
      case "R":
        opts.Rflag = try numericArg(ch, optarg, Int.min)
        if opts.Rflag < 0 {
          opts.Rflag = Int.max
        }
      case "r", "no-run-if-empty":
        break
      case "S":
        opts.Sflag = try numericArg(ch, optarg, 0)
      case "s", "max-chars":
          // FIXME: do I need this?  Will posix_spawn complain if the command line is too big?
          break
//        opts.nline = try numericArg(ch, optarg, 0)
//        pad9314053 = 0
      case "t", "verbose":
        opts.tflag = true
      case "x", "exit":
        opts.xflag = true
      case "0", "null":
        opts.zflag = true
      case "f", "input-file":
          do {
          opts.inp = try FileDescriptor(forReading: optarg)
        } catch(let e) {
          throw CmdErr(1, "-f \(optarg): \(e)")
        }
      case "?":
        fallthrough
      default:
        throw CmdErr(1)
      }
    }
    
    let args = go.remaining
    opts.args = args
    
    if !opts.Iflag && opts.Rflag != 0 {
      throw CmdErr(1)
    }
    if !opts.Iflag && opts.Sflag != 0{
      throw CmdErr(1)
    }
    if opts.Iflag && opts.Rflag == 0 {
      opts.Rflag = 5
    }
    if opts.Iflag && opts.Sflag == 0 {
      opts.Sflag = 255
    }
    if opts.xflag && !opts.nflag {
      throw CmdErr(1)
    }
    if opts.Iflag || opts.Lflag != 0 {
      opts.xflag = true
    }
    if let s = opts.replstr, s.isEmpty {
      throw CmdErr(1, "replstr may not be empty")
    }

    childpids = Set<Int>()

    opts.linelen = 1 + opts.args.count + opts.nargs + 1

    let _PATH_ECHO = "/bin/echo"
    let echo = _PATH_ECHO
    
    if opts.args.isEmpty {
      jbxp.append(echo)
    } else {
      if opts.Jflag, let rr = opts.replstr, let k = opts.args.firstIndex(of: rr) {
        opts.jfound = true
        jbxp.append(contentsOf: opts.args[0..<k])
        kbxp = Array(opts.args[(k+1)...])
      } else {
        jbxp.append(contentsOf: opts.args)
      }
    }
    return opts
  }

  /**
    r0ml added this function.
    the original had a function called to read each character -- with the embedded logic and state to handle execution when complete.
   
   This function reads the next *argument* instead of the next character, and the logic for what to do is embedded at this level.
   */
  
  enum ArgState {
      case eof
    case tab
    case zero
    case newline
  }
  
  func parseArgument(_ prevc : Character, _ inp : inout AsyncCharacterReader.AsyncIterator, _ opts : CommandOptions) async throws(CmdErr) -> (String, Character?) {
    var indouble = false
    var insingle = false
    var argp = ""
    var wasquoted = false
    var prevchar = prevc
    
    // Constructs the next argument from stdin
    while true {
      var ch : Character? = nil
      do {
        ch = try await inp.next()
      } catch(let e) {
        throw CmdErr(1, "reading input: \(e)")
      }
      guard let ch else {
        if insingle || indouble {
          throw CmdErr(1, "unterminated quote")
        }
        return (argp, nil)
      }

      switch ch {
      case " ":
        fallthrough
      case "\t":
        if insingle || indouble || opts.zflag || opts.Lflag > 0 {
          argp.append(ch)
          break
        } else {
          if !opts.Iflag {
            if argp.count == 0 && !wasquoted {
              break
            }
            return (argp, ch)
          }
        }
      case "\0":
        if opts.zflag {
          return (argp, ch)
        } else {
          argp.append(ch)
        }
      case "\n":
        if opts.zflag {
          argp.append(ch)
          break
        }
        if unix2003 {
          // is this the same as last_was_newline?
          if argp.count == 0 {
            break
          }
          // if line ends in blank, next line is continuation
        if !opts.Iflag && prevchar == " " {
            break
          }
        }
        if insingle || indouble {
          throw CmdErr(1, "unterminated quote")
        }
        if argp.count == 0 && !wasquoted {
          break
        }
        return (argp, ch)
      case "'":
        if indouble || opts.zflag {
          argp.append(ch)
        } else {
          insingle.toggle()
          wasquoted = true
        }
      case "\"":
        if insingle || opts.zflag {
          argp.append(ch)
        } else {
          indouble.toggle()
          wasquoted = true
        }
      case "\\":
        if opts.zflag {
          argp.append(ch)
          break
        }
        if !insingle && !indouble {
          do {
            let ch = try await inp.next()
            guard let ch else {
              throw CmdErr(1, "backslash at EOF")
            }
            argp.append(ch)
          } catch(let e) {
            throw CmdErr(1, "reading input: \(e)")
          }
          break
        }
      default:
        argp.append(ch)
        // The original code tests to see if the argument exceeds the available space at this point, and if so, reports an error or truncates the argument.
        // the "available space" is opts.nline
        // As Swift will grow the argument string size, perhaps this is not necessary.
//        if argp.count >= opts.nline {
//          fatalError("see xargs.c[572]")
//        }
      }
      prevchar = ch
    }
  }

  func prerun(_ jbxp : [String], _ ibxp : [String], _ kbxp : [String], _ inpline : String, _ opts : CommandOptions) async throws(CmdErr) {
    let repls = opts.Rflag
   
    if repls == 0 {
      try await run(jbxp + (ibxp.filter { !$0.isEmpty }) + kbxp, opts)
      return
    }
    
    var avj = jbxp
    
    var tmp = [String]()

    if let firstArg = avj.first {
      tmp.append(firstArg)
      avj.removeFirst()
    }
    
    var rr = 0
    for var tmpLast in avj {
      if rr < repls, let replstr = opts.replstr, tmpLast.contains(replstr) {
        tmpLast = tmpLast.replacing(replstr, with: inpline) //  strnsubst(str: tmpLast, match: replstr, replstr: inpline)
          rr += 1
        }
      tmp.append(tmpLast)
    }
    
    try await run(tmp, opts)
  }
  
  func run(_ args : [String], _ opts : CommandOptions) async throws(CmdErr) {

    if opts.tflag || opts.pflag {
      print(args.joined(separator: " "))
      if opts.pflag {
        switch await prompt() {
          case .yes:
            return
          case .no:
            break
          case .neither:
            break
        }
      }
      print("\n")
    }

    let inpath = opts.oflag ? _PATH_TTY : _PATH_DEVNULL

    // use a TaskGroup here?

    let p = ProcessRunner(command: args[0], arguments: args, environment: nil )

    do {
      let m = try await p.run(captureStdout: false, captureStderr: false)

    } catch(let e) {
      throw CmdErr(1, "\(e)")
    }
  }

  /*
  mutating func arg2(_ av : [String]) throws {

    foundeof = inpline == opts.eofstr
    
    if opts.Iflag && !lastWasNewline {
      foundeof = false
    }

    if (!argp.isEmpty || wasquoted) && !foundeof {
//      p += 1
      // FIXME: what is xp doing?
      av.append(argp)
      if opts.Iflag {
        var curlen: size_t = 0
    */

  func runCommand(_ opts : CommandOptions) async throws(CmdErr) {
    var pc : Character? = "\n"
    var a : String = ""
    var ibxp = [String]()

    var argi = opts.inp.characters.makeAsyncIterator()

    defer {
      if opts.inp != FileDescriptor.standardInput {
        try? opts.inp.close()
      }
    }

    while pc != nil {
      (a, pc) = try await parseArgument(pc!, &argi, opts)
      if (!a.isEmpty) || (opts.zflag && opts.xflag) {
        ibxp.append(a)
      }
      if (pc == nil && ibxp.count > 0) || ibxp.count >= opts.nargs || (opts.xflag && opts.Lflag <= ibxp.count)  {
          //        try arg2(av)
          try await prerun(jbxp, ibxp, kbxp, a, opts)
        ibxp = []
      }
    }
  }

  func prompt() async -> YesNo {
    let ttyfp = try? FileDescriptor.open(_PATH_TTY, .readOnly)
    guard let ttyfp else {
      return .neither
    }
    defer {
      try? ttyfp.close()
    }

    var se = FileDescriptor.standardError
    print("?...", terminator: "", to: &se)
    var ma = ttyfp.bytes.lines.makeAsyncIterator()
    guard let response = try? await ma.next() else {
      return .neither
    }
    return rpmatch(response)
  }

  var usage = "usage: xargs [-0opt] [-E eofstr] [-I replstr [-R replacements] [-S replsize]] [-J replstr] [-L number] [-n number [-x]] [-P maxprocs] [-s size] [utility [argument ...]]"
}
