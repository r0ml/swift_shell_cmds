
// Generated by Robert M. Lefkowitz <r0ml@liberally.net> in 2024
// from a file containing the following notice:

/*
  Copyright 2017, Conrad Meyer <cem@FreeBSD.org>.
 
  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are
  met:
 
  * Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright
    notice, this list of conditions and the following disclaimer in the
    documentation and/or other materials provided with the distribution.
 
  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
  z OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

import ShellTesting
import Darwin

@Suite("find tests") final class findTest : ShellTest {
  let cmd = "find"
  let suiteBundle = "shell_cmds_findTest"

  @Test func find_newer_link() async throws {
    let myDir = try tmpdir("")
    let f1 = try tmpfile("f1")
    let ll = try tmpfile("link")
    try ll.createSymbolicLink(to: f1)
//    let ll = try f1.createSymbolicLink("link")

    // touch -d 2017-12-31T10:00:00Z -h test/link

    /// Bah! This doesn't work because Foundation has no equivalent to AT_SYMLINK_NOFOLLOW for symbolic links
/*
    date = dateFormatter.date(from:isoDate)!
    try FileManager.default.setAttributes([.modificationDate: date], ofItemAtPath: ll.relativePath)
*/

    let t1 = try DateTime(fromISO8601: "2023-12-31T06:00:00Z")
    try ll.setTimes(modified: t1, accessed: t1)

    // touch -d 2017-12-31T11:00:00Z test/file2
    let d3 = try DateTime(fromISO8601: "2023-12-31T09:00:00Z")
    let file2 = try tmpfile("file2", "")
    try file2.setTimes(modified: d3)

//    FileManager.default.createFile(atPath: myDir.appending(component: "file2").path(percentEncoded: false), contents: nil, attributes: [.modificationDate: date])


    // touch -d 2017-12-31T12:00:00Z test/file1
    let d4 = try DateTime(fromISO8601: "2023-12-31T12:00:00Z")
    let file1 = try tmpfile("file1", "")
    try file1.setTimes(modified: d4)


//    let j = try captureStdoutLaunch(Self.self, "find", [myDir.relativePath, "-newer", myDir.appending(component: "link").relativePath])
    let res = """
\(myDir.string)
\(file2.string)
\(file1.string)

"""
    try await run(output: res, args: myDir, "-newer", ll )
//    #expect(j.1 == res)
  }
  
  @Test(.disabled("original test code implies a different result than the find shipped with macOS")) func find_samefile_link() async throws {
    let s = try tmpdir("test")

    let f3  = try tmpfile("test/file3", "")

    let l2 = try tmpfile("test/link2")
    try l2.createSymbolicLink(to: f3)

//    let l2 = try createSymbolicLink("test/link2")

//    let j = try captureStdoutLaunch(Self.self, "find", [s.relativePath, "-samefile", s.appending(component: "link2").relativePath])
    // FIXME: the find shipped with macOS produces "file3" here, NOT link2
//    #expect(j.1 == (s.appending(component: "link2").relativePath + "\n") )
    try await run(output: "link2\n", args: s, "-samefile", l2  )
  }
  
  @Test
  func newerBm_msprec() async throws {
    let myDir = try tmpdir("")
    let s = try tmpdir("scratch") // under myDir?
    let bl = try tmpfile("baseline", "")
    let fa = try tmpfile("scratch/file_a", "")
    try? await Task.sleep(nanoseconds: Darwin.NSEC_PER_SEC)
    let fb = try tmpfile("scratch/file_b", "")

//    let j = try captureStdoutLaunch(Self.self, "find", [s.relativePath, "-type", "f", "-newerBm", myDir.appending(component: "baseline").relativePath])

    let res = """
\(s.appending("file_a").string)
\(s.appending("file_b").string)

"""
    try await run(output: res, args: s, "-type", "f", "-newerBm", myDir.appending("baseline") )
  }

}


