
// Generated by Robert M. Lefkowitz <r0ml@liberally.net> in 2024
// from a file containing the following notice:

/*
 SPDX-License-Identifier: APSL-1.0

 Copyright (c) 2023 Apple Inc. All rights reserved.

 @APPLE_LICENSE_HEADER_START@

 "Portions Copyright (c) 1999 Apple Computer, Inc.  All Rights
 Reserved.  This file contains Original Code and/or Modifications of
 Original Code as defined in and that are subject to the Apple Public
 Source License Version 1.0 (the 'License').  You may not use this file
 except in compliance with the License.  Please obtain a copy of the
 License at http://www.apple.com/publicsource and read it before using
 this file.

 The Original Code and all software distributed under the License are
 distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 License for the specific language governing rights and limitations
 under the License."

 @APPLE_LICENSE_HEADER_END@

*/

import ShellTesting

@Suite("killall") final class killallTest : ShellTest {
  let cmd = "killall"
  let suiteBundle = "shell_cmds_killallTest"

  // I think the test works as follows:
  // 1) Spawn a subprocess.
  // 2) Have the subprocess spawn a process named "innocent_test_prog"
  // 3) run killall innocent_test_prog
  // 4) make sure all innocent_test_prog processes have been killed.
  @Test func argv0() async throws {
    // start three processes
    for _ in 0..<3 {
      try runKillableProcess()
    }
    
    let (_, j, _) = try shell("ps -x")
    let jj = j.split(separator: "\n").filter {!($0.matches(of: /innocent_test_prog/).isEmpty) }
    #expect(jj.count == 3)
    try await run(args: "innocent_test_prog")
    let (_, j2, _) = try shell("ps -x")
    let jj2 = j2.split(separator: "\n").filter {!($0.matches(of: /innocent_test_prog/).isEmpty) }
    #expect(jj2.count == 0)

    
  }
  
  
  func runKillableProcess() throws {
//    let t = FileManager.default.temporaryDirectory
//    let tt = t.appending(component: "innocent_test_prog")
//    try? FileManager.default.removeItem(at: tt)
    let tt = try tmpfile("innocent_test_prog")
    rm(tt)
    try FileManager.default.createSymbolicLink(at: tt, withDestinationURL: URL(filePath: "/bin/sleep"))
    
//    FileManager.default.changeCurrentDirectoryPath(t.path)
    let process = Process()
 //   print(tt.relativePath)
    process.executableURL = tt // URL(fileURLWithPath: "./innocent_test_prog")
//    process.currentDirectoryURL = t
    process.arguments = ["100"]
    try process.run()
//    process.waitUntilExit()
  }
  
  /// Returns the output of running `executable` with `args`. Throws an error if the process exits indicating failure.
  public func shell(_ cmd : String) throws -> (Int32, String, String) {
    let process = Process()
    let output = Pipe()
    let stderr = Pipe()
    
    let execu = "/bin/sh"
    
  //  print("launchPath \(execu)")
    
    process.launchPath = execu
    process.arguments = ["-c", cmd]
    process.standardOutput = output
    process.standardError = stderr
    process.launch()

    Task.detached {
      try await Task.sleep(nanoseconds: UInt64( Double(NSEC_PER_SEC) * 2 ) )
  //    print("gonna interrupt")
      process.interrupt()
    }
    
    process.waitUntilExit()
    let k1 = String(data: output.fileHandleForReading.readDataToEndOfFile(), encoding: .utf8) ?? ""
    let k2 = String(data: stderr.fileHandleForReading.readDataToEndOfFile(), encoding: .utf8) ?? ""
    return (process.terminationStatus, k1, k2)

  }

  
}

