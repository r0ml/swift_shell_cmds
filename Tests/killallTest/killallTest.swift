
// Generated by Robert M. Lefkowitz <r0ml@liberally.net> in 2024
// from a file containing the following notice:

/*
 SPDX-License-Identifier: APSL-1.0

 Copyright (c) 2023 Apple Inc. All rights reserved.

 @APPLE_LICENSE_HEADER_START@

 "Portions Copyright (c) 1999 Apple Computer, Inc.  All Rights
 Reserved.  This file contains Original Code and/or Modifications of
 Original Code as defined in and that are subject to the Apple Public
 Source License Version 1.0 (the 'License').  You may not use this file
 except in compliance with the License.  Please obtain a copy of the
 License at http://www.apple.com/publicsource and read it before using
 this file.

 The Original Code and all software distributed under the License are
 distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 License for the specific language governing rights and limitations
 under the License."

 @APPLE_LICENSE_HEADER_END@

*/

import ShellTesting
import Darwin

@Suite("killall") final class killallTest : ShellTest {
  let cmd = "killall"
  let suiteBundle = "shell_cmds_killallTest"

  // I think the test works as follows:
  // 1) Spawn a subprocess.
  // 2) Have the subprocess spawn a process named "innocent_test_prog"
  // 3) run killall innocent_test_prog
  // 4) make sure all innocent_test_prog processes have been killed.
  @Test func argv0() async throws {
    // start three processes
    for _ in 0..<3 {
      try await runKillableProcess()
    }
    
    let op = try await shell("ps -x")
    let jj = op.string.split(separator: "\n").filter {!($0.matches(of: /innocent_test_prog/).isEmpty) }
    #expect(jj.count == 3)
    try await run(args: "innocent_test_prog")
    let op2 = try await shell("ps -x")
    let jj2 = op2.string.split(separator: "\n").filter {!($0.matches(of: /innocent_test_prog/).isEmpty) }
    #expect(jj2.count == 0)

    
  }
  
  
  func runKillableProcess() async throws {
//    let t = FileManager.default.temporaryDirectory
//    let tt = t.appending(component: "innocent_test_prog")
//    try? FileManager.default.removeItem(at: tt)
    let tt = try tmpfile("innocent_test_prog")
    rm(tt)
    try tt.createSymbolicLink(to: FilePath("/bin/sleep"))

//    FileManager.default.changeCurrentDirectoryPath(t.path)
    let process = DarwinProcess()
 //   print(tt.relativePath)
    let _ = try await process.launch(tt.string, args: "100")
  }
  
  /// Returns the output of running `executable` with `args`. Throws an error if the process exits indicating failure.
  public func shell(_ cmd : String) async throws -> DarwinProcess.Output {

    let process = DarwinProcess()

    let pid = try await process.launch("/bin/sh", args: "-c", cmd)
    Task.detached {
      try await Task.sleep(nanoseconds: UInt64( Double(Darwin.NSEC_PER_SEC) * 2 ) )
  //    print("gonna interrupt")
      Darwin.kill(pid, SIGINT)
    }

    return try await process.value()

  }

  
}

