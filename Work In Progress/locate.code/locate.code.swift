
// Generated by Robert M. Lefkowitz <r0ml@liberally.net> in 2024 using ChatGPT
// from a file containing the following notice:

/*
 * SPDX-License-Identifier: BSD-4-Clause
 *
 * Copyright (c) 1995 Wolfram Schneider <wosch@FreeBSD.org>. Berlin.
 * Copyright (c) 1989, 1993
 *  The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * James A. Woods.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *  This product includes software developed by the University of
 *  California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * $FreeBSD$
 */

import Foundation

let BGBUFSIZE = NBG * 2

var buf1 = [UInt8](repeating: 0, count: MAXPATHLEN)
buf1[0] = 32
var buf2 = [UInt8](repeating: 0, count: MAXPATHLEN)
var bigrams = [UInt8](repeating: 0, count: BGBUFSIZE + 1)

#if LOOKUP
typealias bg_t = Int16
var big = Array(repeating: Array(repeating: bg_t(-1), count: Int(UCHAR_MAX) + 1), count: Int(UCHAR_MAX) + 1)
#else
typealias bg_t = Int
func bgindex(_ x: UnsafePointer<CChar>) -> Int {
    // implementation of bgindex function
}
#endif

func usage() {
    fputs("usage: locate.code common_bigrams < list > squozen_list\n", stderr)
    exit(1)
}

var argc = CommandLine.argc
var argv = CommandLine.unsafeArgv

var cp: UnsafeMutablePointer<CChar>?
var oldpath: UnsafeMutablePointer<CChar>?
var path: UnsafeMutablePointer<CChar>?
var ch: Int32, code: Int, count: Int, diffcount: Int, oldcount: Int
var i: UInt, j: UInt
var fp: UnsafeMutablePointer<FILE>?

while ((ch = getopt(argc, argv, "")) != -1) {
    switch(ch) {
    default:
        usage()
    }
}
argc -= optind
argv += optind

if argc != 1 {
    usage()
}

if let file = fopen(argv[0], "r") {
    fp = file
} else {
    perror(argv[0])
    exit(1)
}

fgets(&bigrams, BGBUFSIZE + 1, fp)
if fwrite(bigrams, 1, BGBUFSIZE, stdout) != BGBUFSIZE {
    perror("stdout")
    exit(1)
}
fclose(fp)

#if LOOKUP
for i in 0...UCHAR_MAX {
    for j in 0...UCHAR_MAX {
        big[Int(i)][Int(j)] = -1
    }
}

for (cp = bigrams, i = 0; cp.pointee != 0; i += 2, cp += 2) {
    big[Int(cp.pointee)][Int((cp + 1).pointee)] = bg_t(i)
}
#endif

oldpath = buf1
path = buf2
oldcount = 0

while fgets(path, Int32(buf2.count), stdin) != nil {
    if path.pointee == 10 {
        continue
    }

    for cp = path; cp.pointee != 0; cp += 1 {
        if cp.pointee == 10 {
            cp.pointee = 0
        }
    }

    for cp = path; cp.pointee == oldpath.pointee; cp += 1, oldpath += 1 {
        if cp.pointee == 0 {
            break
        }
    }

    count = cp - path
    diffcount = count - oldcount + OFFSET
    oldcount = count
    if diffcount < 0 || diffcount > 2 * OFFSET {
        if putchar(SWITCH) == EOF || putw(diffcount, stdout) == EOF {
            perror("stdout")
            exit(1)
        }
    } else {
        if putchar(diffcount) == EOF {
            perror("stdout")
            exit(1)
        }
    }

    while cp.pointee != 0 {
        if let code = BGINDEX(cp), code != bg_t(-1) {
            if putchar((code / 2) | PARITY) == EOF {
                perror("stdout")
                exit(1)
            }
            cp += 2
        } else {
            for _ in 0..<2 {
                if cp.pointee == 0 {
                    break
                }

                if cp.pointee < ASCII_MIN || cp.pointee > ASCII_MAX {
                    if putchar(UMLAUT) == EOF || putchar(Int(cp.pointee)) == EOF {
                        perror("stdout")
                        exit(1)
                    }
                } else {
                    if putchar(Int(cp.pointee)) == EOF {
                        perror("stdout")
                        exit(1)
                    }
                }
                cp += 1
            }
        }
    }

    if path == buf1 {
        path = buf2
        oldpath = buf1
    } else {
        path = buf1
        oldpath = buf2
    }
}

if fflush(stdout) != 0 || ferror(stdout) != 0 {
    exit(1)
}
exit(0)

#if !LOOKUP
func bgindex(_ bg: UnsafePointer<CChar>) -> Int {
    let bg0 = bg.pointee
    let bg1 = (bg + 1).pointee
    var p = bigrams
    while p.pointee != 0 {
        if p.pointee == bg0 && (p + 1).pointee == bg1 {
            break
        }
        p += 1
    }
    return p.pointee == 0 ? -1 : p - bigrams
}
#endif
